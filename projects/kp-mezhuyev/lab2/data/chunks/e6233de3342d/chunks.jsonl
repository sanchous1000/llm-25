{"id": "baa9112224b9bca3", "text": "# Llm Prompt\n\nTranslate to Russian (русский язык).\n\nLanguage code: ru.\n\n---\n\nUse a neutral tone (not overly formal or informal).\n\nUse correct Russian grammar — appropriate cases, suffixes, and endings depending on context.\n\nFor the following technical terms, use these specific translations to ensure consistency and clarity across the documentation:", "metadata": {"title": "Llm Prompt", "doc_id": "35b87a992feb", "source_path": "llm-prompt.md", "source_mtime": "2026-01-12T17:48:12.817774+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\llm-prompt.md", "section_header": "Llm Prompt", "section_header_level": 1}, "doc_id": "35b87a992feb", "source_path": "llm-prompt.md", "title": "Llm Prompt", "chunk_index": 0, "header": "Llm Prompt", "header_level": 1, "token_count": 71}
{"id": "0d6b9c5adf34f980", "text": "Russian (русский язык).\n\nLanguage code: ru.\n\n---\n\nUse a neutral tone (not overly formal or informal).\n\nUse correct Russian grammar — appropriate cases, suffixes, and endings depending on context.\n\nFor the following technical terms, use these specific translations to ensure consistency and clarity across the documentation:\n\n* production (meaning production software or environment): продакшн (do not change the ending, for example, translate `in production` as `в продакшн` (not `в продакшене`))\n* completion (meaning code auto-completion): автозавершение\n* editor (meaning component of IDE): редактор кода\n* adopt (meaning start to use): использовать (or `начать использовать`)\n* headers (meaning HTTP-headers): HTTP-заголовки\n* cookie sessions: сессии с использованием cookie\n* tested (adjective): протестированный\n* middleware: middleware (don't translate, but add `промежуточный слой` if clarification is needed)\n* path operation: операция пути (optionally clarify as `обработчик пути`)\n* path operation function: функция-обработчик пути (or `функция обработки пути`)\n* proprietary: проприетарный\n* benchmark: бенчмарк (add (`тест производительности`) if clarification is needed or use just `тест производительности`)\n* ASGI server: ASGI-сервер\n* In a hurry? : Нет времени?\n* response status code: статус-код ответа\n* HTTP status code: HTTP статус-код\n* issue (meaning GitHub issue): Issue (add `тикет\\обращение` if clarification is needed)\n* PR (meaning GitHub pull request): пулл-реквест (add `запрос на изменение` if clarification is needed)\n* run (meaning run the code): запустить (or `прогнать` if it's about testing the program)\n* to reach users: донести до пользователей (or `привлечь внимание пользователей` in the promotion context)\n* body (meaning HTTP request body): тело запроса\n* body (meaning HTTP response body): тело ответа\n* body parameter : body-параметр (or `параметр тела запроса`)\n* validate: валидировать (or `выполнить валидацию`)\n* requirements (meaning dependencies): зависимости\n* auto-reload: авто-перезагрузка (or `перезагрузить автоматически` if used as a verb)\n* show (meaning show on the screen): отобразить\n* parsing (noun): парсинг\n* origin (in web development): origin (add `источник` if clarification is needed)\n* include: включать (add `в себя` if it's appropriate, or use `содержать` as an alternative)\n* virtual environment: виртуальное окружение\n* framework: фреймворк\n* path paremeter: path-параметр\n* path (as in URL path): путь\n* form (as in HTML form): форма\n* media type: тип содержимого (or `медиа-тип`)\n* request: HTTP-запрос\n* response: HTTP-ответ\n* type hints: аннотации типов\n* type annotations: аннотации типов\n* context manager: менеджер контекста\n* code base: кодовая база\n* instantiate: создать экземпляр (avoid \"инстанцировать\")\n* load balancer: балансировщик нагрузки\n* load balance: балансировка нагрузки\n* worker process: воркер-процесс (or `процесс воркера`)\n* worker: воркер\n* lifespan: lifespan (do not translate when it's about lifespan events, but translate as `жизненный цикл` or `срок жизни` in other cases)\n* mount (verb): монтировать\n* mount (noun): точка монтирования / mount (keep in English if it's a FastAPI keyword)\n* plugin: плагин\n* plug-in: плагин\n* full stack: full stack (do not translate)\n* full-stack: full-stack (do not translate)\n* loop (as in async loop): цикл событий\n* Machine Learning: Машинное обучение\n* Deep Learning: Глубокое обучение\n* callback hell: callback hell (clarify as `ад обратных вызовов`)\n* on the fly: на лету\n* scratch the surface: поверхностно ознакомиться\n* tip: совет (or `подсказка` depending on context)\n* Pydantic model: Pydantic-модель (`модель Pydantic` and `Pydantic модель` are also fine)\n* declare: объявить\n* have the next best performance, after: быть на следующем месте по производительности после\n* timing attack: тайминговая атака (clarify `атака по времени` if needed)\n* OAuth2 scope: OAuth2 scope (clarify `область` if needed)\n* TLS Termination Proxy: прокси-сервер TSL-терминации\n* utilize (resources): использовать\n* сontent: содержимое (or `контент`)\n* raise exception: вызвать исключение (also possible to use `сгенерировать исключение` or `выбросить исключение`)\n* password flow: password flow (clarify as `аутентификация по паролю` if needed)\n* tutorial: руководство (or `учебник`)\n* too long; didn't read: слишком длинно; не читал\n* proxy with a stripped path prefix: прокси с функцией удаления префикса пути\n* nerd: умник\n* sub application: подприложение\n* webhook request: вебхук-запрос\n* serve (meaning providing access to something): «отдавать» (or `предоставлять доступ к`)\n* recap (noun): резюме\n* utility function: вспомогательная функция", "metadata": {"title": "Llm Prompt", "doc_id": "35b87a992feb", "source_path": "llm-prompt.md", "source_mtime": "2026-01-12T17:48:12.817774+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\llm-prompt.md", "section_header": "Llm Prompt", "section_header_level": 1}, "doc_id": "35b87a992feb", "source_path": "llm-prompt.md", "title": "Llm Prompt", "chunk_index": 1, "header": "Llm Prompt", "header_level": 1, "token_count": 1506}
{"id": "f614a3a5aa730a48", "text": "* webhook request: вебхук-запрос\n* serve (meaning providing access to something): «отдавать» (or `предоставлять доступ к`)\n* recap (noun): резюме\n* utility function: вспомогательная функция\n\nDo not add whitespace in `т.д.`, `т.п.`.", "metadata": {"title": "Llm Prompt", "doc_id": "35b87a992feb", "source_path": "llm-prompt.md", "source_mtime": "2026-01-12T17:48:12.817774+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\llm-prompt.md", "section_header": "Llm Prompt", "section_header_level": 1}, "doc_id": "35b87a992feb", "source_path": "llm-prompt.md", "title": "Llm Prompt", "chunk_index": 2, "header": "Llm Prompt", "header_level": 1, "token_count": 81}
{"id": "02701967a4842869", "text": "# Альтернативы, источники вдохновения и сравнения { #alternatives-inspiration-and-comparisons }\n\nЧто вдохновило **FastAPI**, сравнение с альтернативами и чему он у них научился.\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 0, "header": "Альтернативы, источники вдохновения и сравнения", "header_level": 1, "token_count": 74}
{"id": "5a7a71ae2fa06250", "text": "## Введение { #intro }\n\n**FastAPI** не существовал бы без предыдущих работ других людей.\n\nБыло создано множество инструментов, которые вдохновили на его появление.\n\nЯ несколько лет избегал создания нового фреймворка. Сначала пытался закрыть все возможности, которые сейчас предоставляет **FastAPI**, с помощью множества разных фреймворков, плагинов и инструментов.\n\nНо в какой-то момент не осталось другого варианта, кроме как создать что-то, что включает все эти возможности, взяв лучшие идеи из прежних инструментов и совместив их максимально удачным образом, используя возможности языка, которых прежде не было (аннотации типов в Python 3.6+).\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 1, "header": "Введение", "header_level": 2, "token_count": 268}
{"id": "bee16194ea8648ab", "text": "## Предшествующие инструменты { #previous-tools }\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 2, "header": "Предшествующие инструменты", "header_level": 2, "token_count": 17}
{"id": "f2eb70a9a396f0c6", "text": "### <a href=\"https://www.djangoproject.com/\" class=\"external-link\" target=\"_blank\">Django</a> { #django }\n\nЭто самый популярный Python-фреймворк, ему широко доверяют. Он используется для построения систем вроде Instagram.\n\nОн относительно тесно связан с реляционными базами данных (например, MySQL или PostgreSQL), поэтому использовать NoSQL-базу данных (например, Couchbase, MongoDB, Cassandra и т. п.) в качестве основного хранилища не очень просто.\n\nОн был создан для генерации HTML на бэкенде, а не для создания API, используемых современным фронтендом (например, React, Vue.js и Angular) или другими системами (например, устройствами <abbr title=\"Internet of Things – Интернет вещей\">IoT</abbr>), которые с ним общаются.\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 3, "header": "<a href=\"https://www.djangoproject.com/\" class=\"external-link\" target=\"_blank\">Django</a>", "header_level": 3, "token_count": 268}
{"id": "ac35d5ec2f1c7196", "text": "### <a href=\"https://www.django-rest-framework.org/\" class=\"external-link\" target=\"_blank\">Django REST Framework</a> { #django-rest-framework }\n\nDjango REST Framework был создан как гибкий набор инструментов для построения веб-API поверх Django, чтобы улучшить его возможности в части API.\n\nОн используется многими компаниями, включая Mozilla, Red Hat и Eventbrite.\n\nЭто был один из первых примеров **автоматической документации API**, и именно эта идея одной из первых вдохновила на «поиск» **FastAPI**.\n\n/// note | Заметка\n\nDjango REST Framework был создан Томом Кристи. Он же создал Starlette и Uvicorn, на которых основан **FastAPI**.\n\n///\n\n/// check | Вдохновило **FastAPI** на\n\nНаличие пользовательского веб-интерфейса с автоматической документацией API.\n\n///\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 4, "header": "<a href=\"https://www.django-rest-framework.org/\" class=\"external-link\" target=\"_blank\">Django REST Framework</a>", "header_level": 3, "token_count": 264}
{"id": "b69042501887ee3e", "text": "### <a href=\"https://flask.palletsprojects.com\" class=\"external-link\" target=\"_blank\">Flask</a> { #flask }\n\nFlask — это «микрофреймворк», он не включает интеграции с базами данных и многие другие вещи, которые в Django идут «из коробки».\n\nЭта простота и гибкость позволяет, например, использовать NoSQL-базы в качестве основной системы хранения данных.\n\nОн очень прост, его относительно легко интуитивно освоить, хотя местами документация довольно техническая.\n\nЕго также часто используют для приложений, которым не нужна база данных, управление пользователями или многие другие функции, предварительно встроенные в Django. Хотя многие из этих возможностей можно добавить плагинами.\n\nТакое разбиение на части и то, что это «микрофреймворк», который можно расширять ровно под нужды, — ключевая особенность, которую хотелось сохранить.\n\nС учётом простоты Flask он казался хорошим вариантом для создания API. Следующим было найти «Django REST Framework» для Flask.\n\n/// check | Вдохновило **FastAPI** на\n\nБыть микро-фреймворком. Облегчить комбинирование необходимых инструментов и компонентов.\n\nИметь простую и удобную систему маршрутизации.\n\n///\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 5, "header": "<a href=\"https://flask.palletsprojects.com\" class=\"external-link\" target=\"_blank\">Flask</a>", "header_level": 3, "token_count": 450}
{"id": "02701967a4842869", "text": "### <a href=\"https://requests.readthedocs.io\" class=\"external-link\" target=\"_blank\">Requests</a> { #requests }\n\n**FastAPI** на самом деле не альтернатива **Requests**. Их области применения очень различны.\n\nОбычно Requests используют даже внутри приложения FastAPI.\n\nИ всё же **FastAPI** во многом вдохновлялся Requests.\n\n**Requests** — это библиотека для взаимодействия с API (как клиент), а **FastAPI** — библиотека для создания API (как сервер).\n\nОни, в каком-то смысле, находятся на противоположных концах и дополняют друг друга.\n\nRequests имеет очень простой и понятный дизайн, им очень легко пользоваться, есть разумные значения по умолчанию. И при этом он очень мощный и настраиваемый.\n\nИменно поэтому на официальном сайте сказано:\n\n> Requests — один из самых загружаемых Python-пакетов всех времён\n\nПользоваться им очень просто. Например, чтобы сделать запрос `GET`, вы бы написали:\n\n```Python\nresponse = requests.get(\"http://example.com/some/url\")\n```\n\nСоответствующая в FastAPI API-операция пути могла бы выглядеть так:\n\n```Python hl_lines=\"1\"\n@app.get(\"/some/url\")\ndef read_url():\n    return {\"message\": \"Hello World\"}\n```\n\nПосмотрите, насколько похожи `requests.get(...)` и `@app.get(...)`.\n\n/// check | Вдохновило **FastAPI** на", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://requests.readthedocs.io\" class=\"external-link\" target=\"_blank\">Requests</a>", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 6, "header": "<a href=\"https://requests.readthedocs.io\" class=\"external-link\" target=\"_blank\">Requests</a>", "header_level": 3, "token_count": 450}
{"id": "5a7a71ae2fa06250", "text": "1\"\n@app.get(\"/some/url\")\ndef read_url():\n    return {\"message\": \"Hello World\"}\n```\n\nПосмотрите, насколько похожи `requests.get(...)` и `@app.get(...)`.\n\n/// check | Вдохновило **FastAPI** на\n\n* Иметь простой и понятный API.\n* Использовать названия HTTP-методов (операций) напрямую, простым и интуитивным образом.\n* Иметь разумные значения по умолчанию, но и мощные настройки.\n\n///", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://requests.readthedocs.io\" class=\"external-link\" target=\"_blank\">Requests</a>", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 7, "header": "<a href=\"https://requests.readthedocs.io\" class=\"external-link\" target=\"_blank\">Requests</a>", "header_level": 3, "token_count": 146}
{"id": "31ce98705b50d0aa", "text": "### <a href=\"https://swagger.io/\" class=\"external-link\" target=\"_blank\">Swagger</a> / <a href=\"https://github.com/OAI/OpenAPI-Specification/\" class=\"external-link\" target=\"_blank\">OpenAPI</a> { #swagger-openapi }\n\nГлавной возможностью, которую хотелось взять из Django REST Framework, была автоматическая документация API.\n\nЗатем я обнаружил, что есть стандарт для документирования API с использованием JSON (или YAML — расширения JSON), под названием Swagger.\n\nИ уже существовал веб-интерфейс для Swagger API. Поэтому возможность генерировать документацию Swagger для API позволила бы автоматически использовать этот веб-интерфейс.\n\nВ какой-то момент Swagger был передан Linux Foundation и переименован в OpenAPI.\n\nВот почему, говоря о версии 2.0, обычно говорят «Swagger», а о версии 3+ — «OpenAPI».\n\n/// check | Вдохновило **FastAPI** на\n\nИспользовать открытый стандарт для спецификаций API вместо самодельной схемы.\n\nИ интегрировать основанные на стандартах инструменты пользовательского интерфейса:\n\n* <a href=\"https://github.com/swagger-api/swagger-ui\" class=\"external-link\" target=\"_blank\">Swagger UI</a>\n* <a href=\"https://github.com/Rebilly/ReDoc\" class=\"external-link\" target=\"_blank\">ReDoc</a>\n\nЭти два инструмента выбраны за популярность и стабильность, но даже при беглом поиске можно найти десятки альтернативных интерфейсов для OpenAPI (которые можно использовать с **FastAPI**).\n\n///\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 8, "header": "<a href=\"https://swagger.io/\" class=\"external-link\" target=\"_blank\">Swagger</a> / <a href=\"https://github.com/OAI/OpenAPI-Specification/\" class=\"external-link\" target=\"_blank\">OpenAPI</a>", "header_level": 3, "token_count": 488}
{"id": "a7647da5e70f4924", "text": "### REST-фреймворки для Flask { #flask-rest-frameworks }\n\nСуществует несколько REST-фреймворков для Flask, но, вложив время и усилия в исследование, я обнаружил, что многие из них прекращены или заброшены, с несколькими нерешёнными Issue (тикет\\обращение), из-за которых они непригодны.\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 9, "header": "REST-фреймворки для Flask", "header_level": 3, "token_count": 125}
{"id": "7535ba386c046ecb", "text": "### <a href=\"https://marshmallow.readthedocs.io/en/stable/\" class=\"external-link\" target=\"_blank\">Marshmallow</a> { #marshmallow }\n\nОдна из основных возможностей, нужных системам API, — «<abbr title=\"также называемая маршаллингом или преобразованием\">сериализация</abbr>» данных, то есть преобразование данных из кода (Python) во что-то, что можно отправить по сети. Например, преобразование объекта с данными из базы в JSON-объект. Преобразование объектов `datetime` в строки и т. п.\n\nЕщё одна важная возможность, востребованная API, — валидация данных: убеждаться, что данные валидны с учётом заданных параметров. Например, что какое-то поле — `int`, а не произвольная строка. Это особенно полезно для входящих данных.\n\nБез системы валидации данных вам пришлось бы выполнять все проверки вручную в коде.\n\nИменно для этих возможностей и был создан Marshmallow. Это отличная библиотека, я много ей пользовался раньше.\n\nНо она появилась до того, как в Python появились аннотации типов. Поэтому для определения каждой <abbr title=\"описание того, как данные должны быть сформированы\">схемы</abbr> нужно использовать специальные утилиты и классы, предоставляемые Marshmallow.\n\n/// check | Вдохновило **FastAPI** на\n\nИспользовать код для автоматического определения «схем», задающих типы данных и их валидацию.\n\n///\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 10, "header": "<a href=\"https://marshmallow.readthedocs.io/en/stable/\" class=\"external-link\" target=\"_blank\">Marshmallow</a>", "header_level": 3, "token_count": 492}
{"id": "ea7d4dfec17c4930", "text": "### <a href=\"https://webargs.readthedocs.io/en/latest/\" class=\"external-link\" target=\"_blank\">Webargs</a> { #webargs }\n\nЕщё одна важная возможность для API — <abbr title=\"чтение и преобразование данных в объекты Python\">парсинг</abbr> данных из входящих HTTP-запросов.\n\nWebargs — это инструмент, созданный для этого поверх нескольких фреймворков, включая Flask.\n\nОн использует Marshmallow для валидации данных. И создан теми же разработчиками.\n\nЭто отличный инструмент, и я тоже много им пользовался до появления **FastAPI**.\n\n/// info | Информация\n\nWebargs был создан теми же разработчиками, что и Marshmallow.\n\n///\n\n/// check | Вдохновило **FastAPI** на\n\nАвтоматическую валидацию входящих данных HTTP-запроса.\n\n///\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 11, "header": "<a href=\"https://webargs.readthedocs.io/en/latest/\" class=\"external-link\" target=\"_blank\">Webargs</a>", "header_level": 3, "token_count": 259}
{"id": "f8226a2c34491f14", "text": "### <a href=\"https://apispec.readthedocs.io/en/stable/\" class=\"external-link\" target=\"_blank\">APISpec</a> { #apispec }\n\nMarshmallow и Webargs предоставляют валидацию, парсинг и сериализацию как плагины.\n\nНо документации всё ещё не было. Тогда появился APISpec.\n\nЭто плагин для многих фреймворков (есть плагин и для Starlette).\n\nОн работает так: вы пишете определение схемы в формате YAML внутри докстринга каждой функции, обрабатывающей маршрут.\n\nИ он генерирует схемы OpenAPI.\n\nТак это работает во Flask, Starlette, Responder и т. д.\n\nНо у нас снова возникает проблема: появляется микро-синтаксис внутри строки Python (большой YAML).\n\nРедактор кода мало чем может помочь. И если мы изменим параметры или схемы Marshmallow и забудем также изменить YAML в докстринге, сгенерированная схема устареет.\n\n/// info | Информация\n\nAPISpec был создан теми же разработчиками, что и Marshmallow.\n\n///\n\n/// check | Вдохновило **FastAPI** на\n\nПоддержку открытого стандарта для API — OpenAPI.\n\n///\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 12, "header": "<a href=\"https://apispec.readthedocs.io/en/stable/\" class=\"external-link\" target=\"_blank\">APISpec</a>", "header_level": 3, "token_count": 391}
{"id": "02701967a4842869", "text": "### <a href=\"https://flask-apispec.readthedocs.io/en/latest/\" class=\"external-link\" target=\"_blank\">Flask-apispec</a> { #flask-apispec }\n\nЭто плагин для Flask, который связывает Webargs, Marshmallow и APISpec.\n\nОн использует информацию из Webargs и Marshmallow, чтобы автоматически генерировать схемы OpenAPI с помощью APISpec.\n\nОтличный и недооценённый инструмент. Он заслуживает большей популярности, чем многие плагины для Flask. Возможно, из-за слишком краткой и абстрактной документации.\n\nЭто решило проблему необходимости писать YAML (ещё один синтаксис) в докстрингах Python.\n\nКомбинация Flask, Flask-apispec с Marshmallow и Webargs была моим любимым бэкенд-стеком до создания **FastAPI**.\n\nЕго использование привело к созданию нескольких full-stack генераторов на Flask. Это основные стеки, которые я (и несколько внешних команд) использовали до сих пор:\n\n* <a href=\"https://github.com/tiangolo/full-stack\" class=\"external-link\" target=\"_blank\">https://github.com/tiangolo/full-stack</a>\n* <a href=\"https://github.com/tiangolo/full-stack-flask-couchbase\" class=\"external-link\" target=\"_blank\">https://github.com/tiangolo/full-stack-flask-couchbase</a>\n* <a href=\"https://github.com/tiangolo/full-stack-flask-couchdb\" class=\"external-link\" target=\"_blank\">https://github.com/tiangolo/full-stack-flask-couchdb</a>\n\nИ эти же full-stack генераторы стали основой для [Генераторов проектов **FastAPI**](project-generation.md){.internal-link target=_blank}.\n\n/// info | Информация", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://flask-apispec.readthedocs.io/en/latest/\" class=\"external-link\" target=\"_blank\">Flask-apispec</a>", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 13, "header": "<a href=\"https://flask-apispec.readthedocs.io/en/latest/\" class=\"external-link\" target=\"_blank\">Flask-apispec</a>", "header_level": 3, "token_count": 506}
{"id": "5a7a71ae2fa06250", "text": "iangolo/full-stack-flask-couchdb</a>\n\nИ эти же full-stack генераторы стали основой для [Генераторов проектов **FastAPI**](project-generation.md){.internal-link target=_blank}.\n\n/// info | Информация\n\nFlask-apispec был создан теми же разработчиками, что и Marshmallow.\n\n///\n\n/// check | Вдохновило **FastAPI** на\n\nАвтоматическую генерацию схемы OpenAPI из того же кода, который определяет сериализацию и валидацию.\n\n///", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://flask-apispec.readthedocs.io/en/latest/\" class=\"external-link\" target=\"_blank\">Flask-apispec</a>", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 14, "header": "<a href=\"https://flask-apispec.readthedocs.io/en/latest/\" class=\"external-link\" target=\"_blank\">Flask-apispec</a>", "header_level": 3, "token_count": 150}
{"id": "02701967a4842869", "text": "### <a href=\"https://nestjs.com/\" class=\"external-link\" target=\"_blank\">NestJS</a> (и <a href=\"https://angular.io/\" class=\"external-link\" target=\"_blank\">Angular</a>) { #nestjs-and-angular }\n\nЭто даже не Python. NestJS — это JavaScript/TypeScript-фреймворк на NodeJS, вдохновлённый Angular.\n\nОн достигает чего-то отчасти похожего на то, что можно сделать с Flask-apispec.\n\nВ нём встроена система внедрения зависимостей, вдохновлённая Angular 2. Требуется предварительная регистрация «инжектируемых» компонентов (как и во всех известных мне системах внедрения зависимостей), что добавляет многословности и повторяемости кода.\n\nПоскольку параметры описываются с помощью типов TypeScript (аналог аннотаций типов в Python), поддержка редактора весьма хороша.\n\nНо так как данные о типах TypeScript не сохраняются после компиляции в JavaScript, он не может полагаться на типы для одновременного определения валидации, сериализации и документации. Из‑за этого и некоторых проектных решений для получения валидации, сериализации и автоматической генерации схем приходится добавлять декораторы во многих местах. В итоге это становится довольно многословным.\n\nОн плохо справляется с вложенными моделями. Если JSON-тело запроса — это объект JSON, содержащий внутренние поля, которые сами являются вложенными объектами JSON, это нельзя как следует задокументировать и провалидировать.", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://nestjs.com/\" class=\"external-link\" target=\"_blank\">NestJS</a> (и <a href=\"https://angular.io/\" class=\"external-link\" target=\"_blank\">Angular</a>)", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 15, "header": "<a href=\"https://nestjs.com/\" class=\"external-link\" target=\"_blank\">NestJS</a> (и <a href=\"https://angular.io/\" class=\"external-link\" target=\"_blank\">Angular</a>)", "header_level": 3, "token_count": 508}
{"id": "5a7a71ae2fa06250", "text": ". Если JSON-тело запроса — это объект JSON, содержащий внутренние поля, которые сами являются вложенными объектами JSON, это нельзя как следует задокументировать и провалидировать.\n\n/// check | Вдохновило **FastAPI** на\n\nИспользовать типы Python для отличной поддержки в редакторе кода.\n\nИметь мощную систему внедрения зависимостей. Найти способ минимизировать повторение кода.\n\n///", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://nestjs.com/\" class=\"external-link\" target=\"_blank\">NestJS</a> (и <a href=\"https://angular.io/\" class=\"external-link\" target=\"_blank\">Angular</a>)", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 16, "header": "<a href=\"https://nestjs.com/\" class=\"external-link\" target=\"_blank\">NestJS</a> (и <a href=\"https://angular.io/\" class=\"external-link\" target=\"_blank\">Angular</a>)", "header_level": 3, "token_count": 141}
{"id": "298c71b1e95dc086", "text": "### <a href=\"https://sanic.readthedocs.io/en/latest/\" class=\"external-link\" target=\"_blank\">Sanic</a> { #sanic }\n\nЭто был один из первых чрезвычайно быстрых Python-фреймворков на основе `asyncio`. Он был сделан очень похожим на Flask.\n\n/// note | Технические детали\n\nОн использовал <a href=\"https://github.com/MagicStack/uvloop\" class=\"external-link\" target=\"_blank\">`uvloop`</a> вместо стандартного цикла `asyncio` в Python. Это и сделало его таким быстрым.\n\nОн явно вдохновил Uvicorn и Starlette, которые сейчас быстрее Sanic в открытых бенчмарках.\n\n///\n\n/// check | Вдохновило **FastAPI** на\n\nПоиск способа достичь сумасшедшей производительности.\n\nИменно поэтому **FastAPI** основан на Starlette, так как это самый быстрый доступный фреймворк (по данным сторонних бенчмарков).\n\n///\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 17, "header": "<a href=\"https://sanic.readthedocs.io/en/latest/\" class=\"external-link\" target=\"_blank\">Sanic</a>", "header_level": 3, "token_count": 306}
{"id": "436365713ba490c3", "text": "### <a href=\"https://falconframework.org/\" class=\"external-link\" target=\"_blank\">Falcon</a> { #falcon }\n\nFalcon — ещё один высокопроизводительный Python-фреймворк, он минималистичен и служит основой для других фреймворков, таких как Hug.\n\nОн спроектирован так, что функции получают два параметра: «request» и «response». Затем вы «читаете» части из запроса и «пишете» части в ответ. Из‑за такого дизайна невозможно объявить параметры запроса и тело запроса стандартными аннотациями типов Python как параметры функции.\n\nПоэтому валидация данных, сериализация и документация должны выполняться в коде вручную, не автоматически. Либо должны быть реализованы во фреймворке поверх Falcon, как в Hug. Та же особенность есть и в других фреймворках, вдохновлённых дизайном Falcon — с одним объектом запроса и одним объектом ответа в параметрах.\n\n/// check | Вдохновило **FastAPI** на\n\nПоиск способов получить отличную производительность.\n\nВместе с Hug (так как Hug основан на Falcon) вдохновило **FastAPI** объявлять параметр `response` в функциях.\n\nХотя в FastAPI это необязательно, и используется в основном для установки HTTP-заголовков, cookie и альтернативных статус-кодов.\n\n///\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 18, "header": "<a href=\"https://falconframework.org/\" class=\"external-link\" target=\"_blank\">Falcon</a>", "header_level": 3, "token_count": 459}
{"id": "02701967a4842869", "text": "### <a href=\"https://moltenframework.com/\" class=\"external-link\" target=\"_blank\">Molten</a> { #molten }\n\nЯ обнаружил Molten на ранних этапах создания **FastAPI**. И у него были очень похожие идеи:\n\n* Основан на аннотациях типов Python.\n* Валидация и документация из этих типов.\n* Система внедрения зависимостей.\n\nОн не использует стороннюю библиотеку для валидации, сериализации и документации, такую как Pydantic, — у него своя. Поэтому такие определения типов данных будет сложнее переиспользовать.\n\nТребуются более многословные конфигурации. И так как он основан на WSGI (вместо ASGI), он не предназначен для использования преимуществ высокой производительности инструментов вроде Uvicorn, Starlette и Sanic.\n\nСистема внедрения зависимостей требует предварительной регистрации зависимостей, а зависимости разрешаются по объявленным типам. Поэтому невозможно объявить более одного «компонента», предоставляющего определённый тип.\n\nМаршруты объявляются в одном месте, используя функции, объявленные в других местах (вместо декораторов, которые можно разместить прямо над функцией, обрабатывающей эндпоинт). Это ближе к тому, как это делает Django, чем Flask (и Starlette). Это разделяет в коде вещи, которые довольно тесно связаны.\n\n/// check | Вдохновило **FastAPI** на", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://moltenframework.com/\" class=\"external-link\" target=\"_blank\">Molten</a>", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 19, "header": "<a href=\"https://moltenframework.com/\" class=\"external-link\" target=\"_blank\">Molten</a>", "header_level": 3, "token_count": 508}
{"id": "5a7a71ae2fa06250", "text": "ближе к тому, как это делает Django, чем Flask (и Starlette). Это разделяет в коде вещи, которые довольно тесно связаны.\n\n/// check | Вдохновило **FastAPI** на\n\nОпределять дополнительные проверки типов данных, используя значение «по умолчанию» атрибутов модели. Это улучшает поддержку в редакторе кода, и раньше этого не было в Pydantic.\n\nФактически это вдохновило на обновление частей Pydantic, чтобы поддерживать такой же стиль объявления валидации (вся эта функциональность теперь уже есть в Pydantic).\n\n///", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://moltenframework.com/\" class=\"external-link\" target=\"_blank\">Molten</a>", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 20, "header": "<a href=\"https://moltenframework.com/\" class=\"external-link\" target=\"_blank\">Molten</a>", "header_level": 3, "token_count": 202}
{"id": "02701967a4842869", "text": "### <a href=\"https://github.com/hugapi/hug\" class=\"external-link\" target=\"_blank\">Hug</a> { #hug }\n\nHug был одним из первых фреймворков, реализовавших объявление типов параметров API с использованием аннотаций типов Python. Это была отличная идея, которая вдохновила и другие инструменты.\n\nОн использовал собственные типы в объявлениях вместо стандартных типов Python, но это всё равно был огромный шаг вперёд.\n\nОн также был одним из первых фреймворков, генерировавших собственную схему, описывающую весь API в JSON.\n\nОн не был основан на стандартах вроде OpenAPI и JSON Schema. Поэтому интегрировать его с другими инструментами, такими как Swagger UI, было бы непросто. Но, опять же, это была очень инновационная идея.\n\nУ него есть интересная и необычная особенность: с помощью одного и того же фреймворка можно создавать и API, и CLI.\n\nТак как он основан на предыдущем стандарте для синхронных веб-фреймворков Python (WSGI), он не может работать с WebSocket и прочим, хотя также демонстрирует высокую производительность.\n\n/// info | Информация\n\nHug был создан Тимоти Кросли, тем же автором <a href=\"https://github.com/timothycrosley/isort\" class=\"external-link\" target=\"_blank\">`isort`</a>, отличного инструмента для автоматической сортировки импортов в файлах Python.\n\n///", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://github.com/hugapi/hug\" class=\"external-link\" target=\"_blank\">Hug</a>", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 21, "header": "<a href=\"https://github.com/hugapi/hug\" class=\"external-link\" target=\"_blank\">Hug</a>", "header_level": 3, "token_count": 506}
{"id": "5a7a71ae2fa06250", "text": "ом <a href=\"https://github.com/timothycrosley/isort\" class=\"external-link\" target=\"_blank\">`isort`</a>, отличного инструмента для автоматической сортировки импортов в файлах Python.\n\n///\n\n/// check | Идеи, вдохновившие **FastAPI**\n\nHug вдохновил части APIStar и был одним из наиболее многообещающих инструментов, которые я нашёл, наряду с APIStar.\n\nHug помог вдохновить **FastAPI** использовать аннотации типов Python для объявления параметров и автоматически генерировать схему, определяющую API.\n\nHug вдохновил **FastAPI** объявлять параметр `response` в функциях для установки HTTP-заголовков и cookie.\n\n///", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://github.com/hugapi/hug\" class=\"external-link\" target=\"_blank\">Hug</a>", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 22, "header": "<a href=\"https://github.com/hugapi/hug\" class=\"external-link\" target=\"_blank\">Hug</a>", "header_level": 3, "token_count": 231}
{"id": "02701967a4842869", "text": "### <a href=\"https://github.com/encode/apistar\" class=\"external-link\" target=\"_blank\">APIStar</a> (<= 0.5) { #apistar-0-5 }\n\nПрямо перед решением строить **FastAPI** я нашёл сервер **APIStar**. В нём было почти всё, что я искал, и отличный дизайн.\n\nЭто была одна из первых реализаций фреймворка, использующего аннотации типов Python для объявления параметров и запросов (до NestJS и Molten), которые я видел. Я обнаружил его примерно в то же время, что и Hug. Но APIStar использовал стандарт OpenAPI.\n\nВ нём были автоматические валидация данных, сериализация данных и генерация схемы OpenAPI на основе тех же аннотаций типов в нескольких местах.\n\nОпределение схемы тела запроса не использовало те же аннотации типов Python, как в Pydantic, — это было ближе к Marshmallow, поэтому поддержка редактора была бы хуже, но всё равно APIStar оставался лучшим доступным вариантом.\n\nНа тот момент у него были лучшие показатели в бенчмарках (его превосходил только Starlette).\n\nСначала у него не было веб‑UI для автоматической документации API, но я знал, что могу добавить к нему Swagger UI.\n\nУ него была система внедрения зависимостей. Она требовала предварительной регистрации компонентов, как и другие инструменты, обсуждавшиеся выше. Но всё же это была отличная возможность.", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://github.com/encode/apistar\" class=\"external-link\" target=\"_blank\">APIStar</a> (<= 0.5)", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 23, "header": "<a href=\"https://github.com/encode/apistar\" class=\"external-link\" target=\"_blank\">APIStar</a> (<= 0.5)", "header_level": 3, "token_count": 502}
{"id": "5a7a71ae2fa06250", "text": "ения зависимостей. Она требовала предварительной регистрации компонентов, как и другие инструменты, обсуждавшиеся выше. Но всё же это была отличная возможность.\n\nМне так и не удалось использовать его в полном проекте, поскольку не было интеграции с системой безопасности, поэтому я не мог заменить все возможности, которые имел с full-stack генераторами на основе Flask-apispec. В моём бэклоге было создать пулл-реквест (запрос на изменение), добавляющий эту функциональность.\n\nЗатем фокус проекта сместился.\n\nЭто перестал быть веб-фреймворк для API, так как автору нужно было сосредоточиться на Starlette.\n\nСейчас APIStar — это набор инструментов для валидации спецификаций OpenAPI, а не веб-фреймворк.\n\n/// info | Информация\n\nAPIStar был создан Томом Кристи. Тем самым человеком, который создал:\n\n* Django REST Framework\n* Starlette (на котором основан **FastAPI**)\n* Uvicorn (используется Starlette и **FastAPI**)\n\n///\n\n/// check | Вдохновило **FastAPI** на\n\nСуществование.\n\nИдея объявлять сразу несколько вещей (валидацию данных, сериализацию и документацию) с помощью одних и тех же типов Python, которые одновременно обеспечивают отличную поддержку в редакторе кода, показалась мне блестящей.", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://github.com/encode/apistar\" class=\"external-link\" target=\"_blank\">APIStar</a> (<= 0.5)", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 24, "header": "<a href=\"https://github.com/encode/apistar\" class=\"external-link\" target=\"_blank\">APIStar</a> (<= 0.5)", "header_level": 3, "token_count": 470}
{"id": "bee16194ea8648ab", "text": "и документацию) с помощью одних и тех же типов Python, которые одновременно обеспечивают отличную поддержку в редакторе кода, показалась мне блестящей.\n\nПосле долгих поисков похожего фреймворка и тестирования множества альтернатив APIStar был лучшим доступным вариантом.\n\nЗатем APIStar перестал существовать как сервер, а был создан Starlette — новая и лучшая основа для такой системы. Это стало окончательным вдохновением для создания **FastAPI**.\n\nЯ считаю **FastAPI** «духовным преемником» APIStar, который улучшает и расширяет возможности, систему типов и другие части, опираясь на уроки от всех этих предыдущих инструментов.\n\n///", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://github.com/encode/apistar\" class=\"external-link\" target=\"_blank\">APIStar</a> (<= 0.5)", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 25, "header": "<a href=\"https://github.com/encode/apistar\" class=\"external-link\" target=\"_blank\">APIStar</a> (<= 0.5)", "header_level": 3, "token_count": 264}
{"id": "5d05e815534d03bd", "text": "## Что используется в **FastAPI** { #used-by-fastapi }\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 26, "header": "Что используется в **FastAPI**", "header_level": 2, "token_count": 19}
{"id": "b747d58ac622959f", "text": "### <a href=\"https://docs.pydantic.dev/\" class=\"external-link\" target=\"_blank\">Pydantic</a> { #pydantic }\n\nPydantic — это библиотека для определения валидации данных, сериализации и документации (с использованием JSON Schema) на основе аннотаций типов Python.\n\nБлагодаря этому он чрезвычайно интуитивен.\n\nЕго можно сравнить с Marshmallow. Хотя в бенчмарках он быстрее Marshmallow. И поскольку он основан на тех же аннотациях типов Python, поддержка в редакторе кода отличная.\n\n/// check | **FastAPI** использует его для\n\nОбработки всей валидации данных, сериализации данных и автоматической документации моделей (на основе JSON Schema).\n\nЗатем **FastAPI** берёт эти данные JSON Schema и помещает их в OpenAPI, помимо всех прочих функций.\n\n///\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 27, "header": "<a href=\"https://docs.pydantic.dev/\" class=\"external-link\" target=\"_blank\">Pydantic</a>", "header_level": 3, "token_count": 264}
{"id": "02701967a4842869", "text": "### <a href=\"https://www.starlette.dev/\" class=\"external-link\" target=\"_blank\">Starlette</a> { #starlette }\n\nStarlette — это лёгкий <abbr title=\"Новый стандарт построения асинхронных веб-сервисов Python\">ASGI</abbr> фреймворк/набор инструментов, идеально подходящий для создания высокопроизводительных asyncio‑сервисов.\n\nОн очень простой и интуитивный. Спроектирован так, чтобы его было легко расширять, и чтобы компоненты были модульными.\n\nВ нём есть:\n\n* Впечатляющая производительность.\n* Поддержка WebSocket.\n* Фоновые задачи, выполняемые в том же процессе.\n* События запуска и завершения.\n* Тестовый клиент на базе HTTPX.\n* CORS, GZip, статические файлы, потоковые ответы.\n* Поддержка сессий и cookie.\n* 100% покрытие тестами.\n* 100% кодовой базы с аннотациями типов.\n* Мало жёстких зависимостей.\n\nВ настоящее время Starlette — самый быстрый из протестированных Python-фреймворков. Его превосходит только Uvicorn, который не фреймворк, а сервер.\n\nStarlette предоставляет весь базовый функционал веб-микрофреймворка.\n\nНо он не предоставляет автоматическую валидацию данных, сериализацию или документацию.", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://www.starlette.dev/\" class=\"external-link\" target=\"_blank\">Starlette</a>", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 28, "header": "<a href=\"https://www.starlette.dev/\" class=\"external-link\" target=\"_blank\">Starlette</a>", "header_level": 3, "token_count": 450}
{"id": "5a7a71ae2fa06250", "text": ".\n\nStarlette предоставляет весь базовый функционал веб-микрофреймворка.\n\nНо он не предоставляет автоматическую валидацию данных, сериализацию или документацию.\n\nЭто одна из главных вещей, которые **FastAPI** добавляет поверх, всё на основе аннотаций типов Python (с использованием Pydantic). Плюс система внедрения зависимостей, утилиты безопасности, генерация схемы OpenAPI и т. д.\n\n/// note | Технические детали\n\nASGI — это новый «стандарт», разрабатываемый участниками core-команды Django. Он всё ещё не является «стандартом Python» (PEP), хотя процесс идёт.\n\nТем не менее его уже используют как «стандарт» несколько инструментов. Это сильно улучшает совместимость: вы можете заменить Uvicorn на любой другой ASGI-сервер (например, Daphne или Hypercorn) или добавить совместимые с ASGI инструменты, такие как `python-socketio`.\n\n///\n\n/// check | **FastAPI** использует его для\n\nОбработки всех основных веб-частей. Добавляя возможности поверх.\n\nКласс `FastAPI` напрямую наследуется от класса `Starlette`.\n\nТак что всё, что вы можете сделать со Starlette, вы можете сделать напрямую с **FastAPI**, по сути это «Starlette на стероидах».\n\n///", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md", "section_header": "<a href=\"https://www.starlette.dev/\" class=\"external-link\" target=\"_blank\">Starlette</a>", "section_header_level": 3}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 29, "header": "<a href=\"https://www.starlette.dev/\" class=\"external-link\" target=\"_blank\">Starlette</a>", "header_level": 3, "token_count": 449}
{"id": "68266b44575af3c5", "text": "### <a href=\"https://www.uvicorn.dev/\" class=\"external-link\" target=\"_blank\">Uvicorn</a> { #uvicorn }\n\nUvicorn — молниеносный ASGI-сервер, построенный на uvloop и httptools.\n\nЭто не веб-фреймворк, а сервер. Например, он не предоставляет инструменты для маршрутизации по путям. Это предоставляет сверху фреймворк, такой как Starlette (или **FastAPI**).\n\nЭто рекомендуемый сервер для Starlette и **FastAPI**.\n\n/// check | **FastAPI** рекомендует его как\n\nОсновной веб-сервер для запуска приложений **FastAPI**.\n\nТакже вы можете использовать опцию командной строки `--workers`, чтобы получить асинхронный многопроцессный сервер.\n\nПодробнее см. раздел [Развёртывание](deployment/index.md){.internal-link target=_blank}.\n\n///\n\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 30, "header": "<a href=\"https://www.uvicorn.dev/\" class=\"external-link\" target=\"_blank\">Uvicorn</a>", "header_level": 3, "token_count": 274}
{"id": "9a809bb0ded370fb", "text": "## Бенчмарки и скорость { #benchmarks-and-speed }\n\nЧтобы понять, сравнить и увидеть разницу между Uvicorn, Starlette и FastAPI, см. раздел о [Бенчмарках](benchmarks.md){.internal-link target=_blank}.\n", "metadata": {"title": "Альтернативы, источники вдохновения и сравнения", "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "source_mtime": "2026-01-12T17:48:12.848917+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\alternatives.md"}, "doc_id": "187e4296b12e", "source_path": "docs\\alternatives.md", "title": "Альтернативы, источники вдохновения и сравнения", "chunk_index": 31, "header": "Бенчмарки и скорость", "header_level": 2, "token_count": 79}
{"id": "f5a2bea62daa2b7d", "text": "# Конкурентность и async / await { #concurrency-and-async-await }\n\nПодробности о синтаксисе `async def` для *функций-обработчиков пути* и немного фона об асинхронном коде, конкурентности и параллелизме.\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 0, "header": "Конкурентность и async / await", "header_level": 1, "token_count": 82}
{"id": "f5a2bea62daa2b7d", "text": "## Нет времени? { #in-a-hurry }\n\n<abbr title=\"too long; didn't read – слишком длинно; не читал\"><strong>TL;DR:</strong></abbr>\n\nЕсли вы используете сторонние библиотеки, которые нужно вызывать с `await`, например:\n\n```Python\nresults = await some_library()\n```\n\nТогда объявляйте *функции-обработчики пути* с `async def`, например:\n\n```Python hl_lines=\"2\"\n@app.get('/')\nasync def read_results():\n    results = await some_library()\n    return results\n```\n\n/// note | Примечание\n\n`await` можно использовать только внутри функций, объявленных с `async def`.\n\n///\n\n---\n\nЕсли вы используете стороннюю библиотеку, которая взаимодействует с чем-то (база данных, API, файловая система и т.д.) и не поддерживает использование `await` (сейчас это относится к большинству библиотек для БД), тогда объявляйте *функции-обработчики пути* как обычно, просто с `def`, например:\n\n```Python hl_lines=\"2\"\n@app.get('/')\ndef results():\n    results = some_library()\n    return results\n```\n\n---\n\nЕсли вашему приложению (по какой-то причине) не нужно ни с чем взаимодействовать и ждать ответа, используйте `async def`, даже если внутри не нужен `await`.\n\n---\n\nЕсли вы просто не уверены, используйте обычный `def`.\n\n---", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Нет времени?", "section_header_level": 2}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 1, "header": "Нет времени?", "header_level": 2, "token_count": 432}
{"id": "39a6ffc54e9e7e20", "text": "ни с чем взаимодействовать и ждать ответа, используйте `async def`, даже если внутри не нужен `await`.\n\n---\n\nЕсли вы просто не уверены, используйте обычный `def`.\n\n---\n\n**Примечание**: вы можете смешивать `def` и `async def` в *функциях-обработчиках пути* столько, сколько нужно, и объявлять каждую так, как лучше для вашего случая. FastAPI сделает с ними всё как надо.\n\nВ любом из случаев выше FastAPI всё равно работает асинхронно и очень быстро.\n\nНо следуя этим шагам, он сможет выполнить некоторые оптимизации производительности.", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Нет времени?", "section_header_level": 2}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 2, "header": "Нет времени?", "header_level": 2, "token_count": 210}
{"id": "c6ef90d8c35333b2", "text": "## Технические подробности { #technical-details }\n\nСовременные версии Python поддерживают **«асинхронный код»** с помощью **«сопрограмм»** (coroutines) и синтаксиса **`async` и `await`**.\n\nРазберём эту фразу по частям в разделах ниже:\n\n* **Асинхронный код**\n* **`async` и `await`**\n* **Сопрограммы**\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 3, "header": "Технические подробности", "header_level": 2, "token_count": 132}
{"id": "f5a2bea62daa2b7d", "text": "## Асинхронный код { #asynchronous-code }\n\nАсинхронный код значит, что в языке 💬 есть способ сказать компьютеру/программе 🤖, что в некоторый момент кода ему 🤖 придётся подождать, пока *что-то ещё* где-то в другом месте завершится. Назовём это *что-то ещё* «медленный файл» 📝.\n\nИ пока мы ждём завершения работы с «медленныи файлом» 📝, компьютер может заняться другой работой.\n\nЗатем компьютер/программа 🤖 будет возвращаться каждый раз, когда появится возможность (пока снова где-то идёт ожидание), или когда 🤖 завершит всю текущую работу. И он 🤖 проверит, не завершилась ли какая-либо из задач, которых он ждал, и сделает то, что нужно.\n\nДалее он 🤖 возьмёт первую завершившуюся задачу (скажем, наш «медленный файл» 📝) и продолжит делать с ней то, что требуется.\n\nЭто «ожидание чего-то ещё» обычно относится к операциям <abbr title=\"Input and Output – Ввод/вывод\">I/O</abbr>, которые относительно «медленные» (по сравнению со скоростью процессора и оперативной памяти), например ожидание:", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Асинхронный код", "section_header_level": 2}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 4, "header": "Асинхронный код", "header_level": 2, "token_count": 439}
{"id": "39a6ffc54e9e7e20", "text": "and Output – Ввод/вывод\">I/O</abbr>, которые относительно «медленные» (по сравнению со скоростью процессора и оперативной памяти), например ожидание:\n\n* отправки данных клиентом по сети\n* получения клиентом данных, отправленных вашей программой по сети\n* чтения системой содержимого файла на диске и передачи этих данных вашей программе\n* записи на диск содержимого, которое ваша программа передала системе\n* операции удалённого API\n* завершения операции базы данных\n* возврата результатов запроса к базе данных\n* и т.д.\n\nПоскольку основное время выполнения уходит на ожидание операций <abbr title=\"Input and Output – Ввод/вывод\">I/O</abbr>, их называют операциями, «ограниченными вводом-выводом» (I/O bound).\n\nЭто называется «асинхронным», потому что компьютеру/программе не нужно «синхронизироваться» с медленной задачей, простаивая и выжидая точный момент её завершения, чтобы забрать результат и продолжить работу.\n\nВместо этого, в «асинхронной» системе, уже завершившаяся задача может немного подождать (несколько микросекунд) в очереди, пока компьютер/программа завершит то, чем занимался, и затем вернётся, чтобы забрать результаты и продолжить работу с ними.", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Асинхронный код", "section_header_level": 2}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 5, "header": "Асинхронный код", "header_level": 2, "token_count": 451}
{"id": "fc5b76334e7f9887", "text": "икросекунд) в очереди, пока компьютер/программа завершит то, чем занимался, и затем вернётся, чтобы забрать результаты и продолжить работу с ними.\n\nДля «синхронного» (в противоположность «асинхронному») исполнения часто используют термин «последовательный», потому что компьютер/программа выполняет все шаги по порядку, прежде чем переключиться на другую задачу, даже если эти шаги включают ожидание.", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Асинхронный код", "section_header_level": 2}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 6, "header": "Асинхронный код", "header_level": 2, "token_count": 174}
{"id": "6bef8360b047f6a1", "text": "### Конкурентность и бургеры { #concurrency-and-burgers }\n\nТа идея **асинхронного** кода, описанная выше, иногда также называется **«конкурентностью»**. Она отличается от **«параллелизма»**.\n\nИ **конкурентность**, и **параллелизм** относятся к «разным вещам, происходящим примерно одновременно».\n\nНо различия между *конкурентностью* и *параллелизмом* довольно существенные.\n\nЧтобы их увидеть, представьте следующую историю про бургеры:\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 7, "header": "Конкурентность и бургеры", "header_level": 3, "token_count": 201}
{"id": "f5a2bea62daa2b7d", "text": "### Конкурентные бургеры { #concurrent-burgers }\n\nВы идёте со своей возлюбленной за фастфудом, вы стоите в очереди, пока кассир принимает заказы у людей перед вами. 😍\n\n<img src=\"/img/async/concurrent-burgers/concurrent-burgers-01.png\" class=\"illustration\">\n\nНаконец ваша очередь: вы заказываете 2 очень «навороченных» бургера — для вашей возлюбленной и для себя. 🍔🍔\n\n<img src=\"/img/async/concurrent-burgers/concurrent-burgers-02.png\" class=\"illustration\">\n\nКассир говорит что-то повару на кухне, чтобы они знали, что нужно приготовить ваши бургеры (хотя сейчас они готовят бургеры для предыдущих клиентов).\n\n<img src=\"/img/async/concurrent-burgers/concurrent-burgers-03.png\" class=\"illustration\">\n\nВы платите. 💸\n\nКассир выдаёт вам номер вашей очереди.\n\n<img src=\"/img/async/concurrent-burgers/concurrent-burgers-04.png\" class=\"illustration\">\n\nПока вы ждёте, вы вместе со своей возлюбленной идёте и выбираете столик, садитесь и долго болтаете (ваши бургеры очень «навороченные», поэтому им нужно время на приготовление).\n\nСидя за столиком со своей возлюбленной в ожидании бургеров, вы можете провести это время, восхищаясь тем, какая она классная, милая и умная ✨😍✨.\n\n<img src=\"/img/async/concurrent-burgers/concurrent-burgers-05.png\" class=\"illustration\">", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Конкурентные бургеры", "section_header_level": 3}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 8, "header": "Конкурентные бургеры", "header_level": 3, "token_count": 501}
{"id": "39a6ffc54e9e7e20", "text": "е провести это время, восхищаясь тем, какая она классная, милая и умная ✨😍✨.\n\n<img src=\"/img/async/concurrent-burgers/concurrent-burgers-05.png\" class=\"illustration\">\n\nПока вы ждёте и разговариваете, время от времени вы поглядываете на номер на табло, чтобы понять, не подошла ли уже ваша очередь.\n\nИ вот в какой-то момент ваша очередь наступает. Вы подходите к стойке, забираете свои бургеры и возвращаетесь к столику.\n\n<img src=\"/img/async/concurrent-burgers/concurrent-burgers-06.png\" class=\"illustration\">\n\nВы со своей возлюбленной едите бургеры и отлично проводите время. ✨\n\n<img src=\"/img/async/concurrent-burgers/concurrent-burgers-07.png\" class=\"illustration\">\n\n/// info | Информация\n\nПрекрасные иллюстрации от <a href=\"https://www.instagram.com/ketrinadrawsalot\" class=\"external-link\" target=\"_blank\">Ketrina Thompson</a>. 🎨\n\n///\n\n---\n\nПредставьте, что в этой истории вы — компьютер/программа 🤖.\n\nПока вы стоите в очереди, вы просто бездействуете 😴, ждёте своей очереди и не делаете ничего особо «продуктивного». Но очередь движется быстро, потому что кассир только принимает заказы (а не готовит их), так что это нормально.", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Конкурентные бургеры", "section_header_level": 3}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 9, "header": "Конкурентные бургеры", "header_level": 3, "token_count": 438}
{"id": "fc5b76334e7f9887", "text": "и не делаете ничего особо «продуктивного». Но очередь движется быстро, потому что кассир только принимает заказы (а не готовит их), так что это нормально.\n\nКогда приходит ваша очередь, вы выполняете действительно «продуктивную» работу: просматриваете меню, решаете, чего хотите, учитываете выбор своей возлюбленной, платите, проверяете, что дали правильную купюру/карту, что сумма списана корректно, что в заказе верные позиции и т.д.\n\nНо затем, хотя у вас ещё нет бургеров, ваша «работа» с кассиром поставлена «на паузу» ⏸, потому что нужно подождать 🕙, пока бургеры будут готовы.\n\nНо, отойдя от стойки и сев за столик с номерком, вы можете переключить 🔀 внимание на свою возлюбленную и «поработать» ⏯ 🤓 над этим. Снова очень «продуктивно» — флирт с вашей возлюбленной 😍.\n\nПотом кассир 💁 «говорит»: «Я закончил делать бургеры», — выводя ваш номер на табло, но вы не подпрыгиваете как сумасшедший в ту же секунду, как только номер сменился на ваш. Вы знаете, что ваши бургеры никто не украдёт, потому что у вас есть номер вашей очереди, а у других — их.", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Конкурентные бургеры", "section_header_level": 3}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 10, "header": "Конкурентные бургеры", "header_level": 3, "token_count": 485}
{"id": "c6ef90d8c35333b2", "text": "унду, как только номер сменился на ваш. Вы знаете, что ваши бургеры никто не украдёт, потому что у вас есть номер вашей очереди, а у других — их.\n\nПоэтому вы дожидаетесь, пока ваша возлюбленная закончит историю (завершится текущая работа ⏯ / выполняемая задача 🤓), мягко улыбаетесь и говорите, что идёте за бургерами ⏸.\n\nЗатем вы идёте к стойке 🔀, к исходной задаче, которая теперь завершена ⏯, забираете бургеры, благодарите и несёте их к столику. На этом шаг/задача взаимодействия со стойкой завершён ⏹. Это, в свою очередь, создаёт новую задачу — «есть бургеры» 🔀 ⏯, но предыдущая «получить бургеры» — завершена ⏹.", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Конкурентные бургеры", "section_header_level": 3}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 11, "header": "Конкурентные бургеры", "header_level": 3, "token_count": 313}
{"id": "f5a2bea62daa2b7d", "text": "### Параллельные бургеры { #parallel-burgers }\n\nТеперь представим, что это не «Конкурентные бургеры», а «Параллельные бургеры».\n\nВы идёте со своей возлюбленной за параллельным фастфудом.\n\nВы стоите в очереди, пока несколько (скажем, 8) кассиров, которые одновременно являются поварами, принимают заказы у людей перед вами.\n\nВсе перед вами ждут, пока их бургеры будут готовы, не отходя от стойки, потому что каждый из 8 кассиров сразу идёт готовить бургер перед тем, как принять следующий заказ.\n\n<img src=\"/img/async/parallel-burgers/parallel-burgers-01.png\" class=\"illustration\">\n\nНаконец ваша очередь: вы заказываете 2 очень «навороченных» бургера — для вашей возлюбленной и для себя.\n\nВы платите 💸.\n\n<img src=\"/img/async/parallel-burgers/parallel-burgers-02.png\" class=\"illustration\">\n\nКассир уходит на кухню.\n\nВы ждёте, стоя у стойки 🕙, чтобы никто не забрал ваши бургеры раньше вас, так как никаких номерков нет.\n\n<img src=\"/img/async/parallel-burgers/parallel-burgers-03.png\" class=\"illustration\">\n\nТак как вы со своей возлюбленной заняты тем, чтобы никто не встал перед вами и не забрал ваши бургеры, как только они появятся, вы не можете уделить внимание своей возлюбленной. 😞", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Параллельные бургеры", "section_header_level": 3}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 12, "header": "Параллельные бургеры", "header_level": 3, "token_count": 488}
{"id": "39a6ffc54e9e7e20", "text": "яты тем, чтобы никто не встал перед вами и не забрал ваши бургеры, как только они появятся, вы не можете уделить внимание своей возлюбленной. 😞\n\nЭто «синхронная» работа, вы «синхронизированы» с кассиром/поваром 👨‍🍳. Вам нужно ждать 🕙 и находиться там в точный момент, когда кассир/повар 👨‍🍳 закончит бургеры и вручит их вам, иначе их может забрать кто-то другой.\n\n<img src=\"/img/async/parallel-burgers/parallel-burgers-04.png\" class=\"illustration\">\n\nЗатем ваш кассир/повар 👨‍🍳 наконец возвращается с вашими бургерами, после долгого ожидания 🕙 у стойки.\n\n<img src=\"/img/async/parallel-burgers/parallel-burgers-05.png\" class=\"illustration\">\n\nВы берёте бургеры и идёте со своей возлюбленной к столику.\n\nВы просто их съедаете — и всё. ⏹\n\n<img src=\"/img/async/parallel-burgers/parallel-burgers-06.png\" class=\"illustration\">\n\nРазговоров и флирта было немного, потому что большую часть времени вы ждали 🕙 у стойки. 😞\n\n/// info | Информация\n\nПрекрасные иллюстрации от <a href=\"https://www.instagram.com/ketrinadrawsalot\" class=\"external-link\" target=\"_blank\">Ketrina Thompson</a>. 🎨\n\n///\n\n---", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Параллельные бургеры", "section_header_level": 3}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 13, "header": "Параллельные бургеры", "header_level": 3, "token_count": 460}
{"id": "fc5b76334e7f9887", "text": "ки. 😞\n\n/// info | Информация\n\nПрекрасные иллюстрации от <a href=\"https://www.instagram.com/ketrinadrawsalot\" class=\"external-link\" target=\"_blank\">Ketrina Thompson</a>. 🎨\n\n///\n\n---\n\nВ этом сценарии «параллельных бургеров» вы — компьютер/программа 🤖 с двумя процессорами (вы и ваша возлюбленная), оба ждут 🕙 и уделяют внимание ⏯ тому, чтобы «ждать у стойки» 🕙 долгое время.\n\nВ ресторане 8 процессоров (кассиров/поваров). Тогда как в «конкурентных бургерах» могло быть только 2 (один кассир и один повар).\n\nИ всё же финальный опыт — не самый лучший. 😞\n\n---\n\nЭто была параллельная версия истории про бургеры. 🍔\n\nДля более «жизненного» примера представьте банк.\n\nДо недавнего времени в большинстве банков было несколько кассиров 👨‍💼👨‍💼👨‍💼👨‍💼 и длинная очередь 🕙🕙🕙🕙🕙🕙🕙🕙.\n\nВсе кассиры делают всю работу с одним клиентом за другим 👨‍💼⏯.\n\nИ вам приходится долго 🕙 стоять в очереди, иначе вы потеряете свою очередь.\n\nВы вряд ли захотите взять свою возлюбленную 😍 с собой, чтобы заняться делами в банке 🏦.", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Параллельные бургеры", "section_header_level": 3}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 14, "header": "Параллельные бургеры", "header_level": 3, "token_count": 497}
{"id": "0ddca374054e19b2", "text": "### Вывод про бургеры { #burger-conclusion }\n\nВ этом сценарии «фастфуда с вашей возлюбленной», так как много ожидания 🕙, гораздо логичнее иметь конкурентную систему ⏸🔀⏯.\n\nТак обстоит дело и с большинством веб-приложений.\n\nОчень много пользователей, но ваш сервер ждёт 🕙, пока их не самое хорошее соединение отправит их запросы.\n\nА затем снова ждёт 🕙, пока отправятся ответы.\n\nЭто «ожидание» 🕙 измеряется микросекундами, но если всё сложить, то в сумме получается много ожидания.\n\nВот почему асинхронный ⏸🔀⏯ код очень уместен для веб-API.\n\nИменно такая асинхронность сделала NodeJS популярным (хотя NodeJS — не параллельный), и это сильная сторона Go как языка программирования.\n\nТого же уровня производительности вы получаете с **FastAPI**.\n\nА так как можно одновременно использовать параллелизм и асинхронность, вы получаете производительность выше, чем у большинства протестированных фреймворков на NodeJS и на уровне Go, который — компилируемый язык, ближе к C <a href=\"https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=query&l=zijmkf-1\" class=\"external-link\" target=\"_blank\">(всё благодаря Starlette)</a>.\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 15, "header": "Вывод про бургеры", "header_level": 3, "token_count": 472}
{"id": "f5a2bea62daa2b7d", "text": "### Конкурентность лучше параллелизма? { #is-concurrency-better-than-parallelism }\n\nНет! Мораль истории не в этом.\n\nКонкурентность отличается от параллелизма. И она лучше в **конкретных** сценариях, где много ожидания. Поэтому при разработке веб-приложений она обычно намного лучше параллелизма. Но не во всём.\n\nЧтобы уравновесить это, представьте такую короткую историю:\n\n> Вам нужно убрать большой грязный дом.\n\n*Да, это вся история*.\n\n---\n\nЗдесь нигде нет ожидания 🕙, просто очень много работы в разных местах дома.\n\nМожно организовать «очереди» как в примере с бургерами — сначала гостиная, потом кухня, — но так как вы ничего не ждёте 🕙, а просто убираете и убираете, очереди ни на что не повлияют.\n\nНа завершение уйдёт одинаковое время — с очередями (конкурентностью) и без них — и объём выполненной работы будет одинаковым.\n\nНо в этом случае, если бы вы могли привести 8 бывших кассиров/поваров, а теперь — уборщиков, и каждый из них (плюс вы) взял бы свою зону дома для уборки, вы могли бы сделать всю работу **параллельно**, с дополнительной помощью, и завершить гораздо быстрее.", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Конкурентность лучше параллелизма?", "section_header_level": 3}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 16, "header": "Конкурентность лучше параллелизма?", "header_level": 3, "token_count": 494}
{"id": "39a6ffc54e9e7e20", "text": "взял бы свою зону дома для уборки, вы могли бы сделать всю работу **параллельно**, с дополнительной помощью, и завершить гораздо быстрее.\n\nВ этом сценарии каждый уборщик (включая вас) был бы процессором, выполняющим свою часть работы.\n\nИ так как основное время выполнения уходит на реальную работу (а не ожидание), а работу в компьютере выполняет <abbr title=\"Central Processing Unit – Центральный процессор\">CPU</abbr>, такие задачи называют «ограниченными процессором» (CPU bound).\n\n---\n\nТипичные примеры CPU-bound операций — те, которые требуют сложной математической обработки.\n\nНапример:", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Конкурентность лучше параллелизма?", "section_header_level": 3}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 17, "header": "Конкурентность лучше параллелизма?", "header_level": 3, "token_count": 239}
{"id": "fc5b76334e7f9887", "text": "называют «ограниченными процессором» (CPU bound).\n\n---\n\nТипичные примеры CPU-bound операций — те, которые требуют сложной математической обработки.\n\nНапример:\n\n* Обработка **аудио** или **изображений**.\n* **Компьютерное зрение**: изображение состоит из миллионов пикселей, каждый пиксель имеет 3 значения/цвета; обычно требуется вычислить что-то для всех этих пикселей одновременно.\n* **Машинное обучение**: обычно требует множества умножений «матриц» и «векторов». Представьте огромную таблицу с числами и умножение всех этих чисел «одновременно».\n* **Глубокое обучение**: это подполе Машинного обучения, так что всё вышесказанное применимо. Просто это не одна таблица чисел, а их огромный набор, и во многих случаях вы используете специальный процессор, чтобы строить и/или использовать такие модели.", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Конкурентность лучше параллелизма?", "section_header_level": 3}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 18, "header": "Конкурентность лучше параллелизма?", "header_level": 3, "token_count": 339}
{"id": "44fd529d98f94c17", "text": "### Конкурентность + параллелизм: Веб + Машинное обучение { #concurrency-parallelism-web-machine-learning }\n\nС **FastAPI** вы можете использовать преимущества конкурентности, что очень распространено в веб-разработке (это та же основная «фишка» NodeJS).\n\nНо вы также можете использовать выгоды параллелизма и многопроцессности (когда несколько процессов работают параллельно) для рабочих нагрузок, **ограниченных процессором** (CPU bound), как в системах Машинного обучения.\n\nПлюс к этому простой факт, что Python — основной язык для **Data Science**, Машинного обучения и особенно Глубокого обучения, делает FastAPI очень хорошим выбором для веб-API и приложений в области Data Science / Машинного обучения (среди многих других).\n\nКак добиться такого параллелизма в продакшн, см. раздел [Развёртывание](deployment/index.md){.internal-link target=_blank}.\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 19, "header": "Конкурентность + параллелизм: Веб + Машинное обучение", "header_level": 3, "token_count": 323}
{"id": "e356b937dca22a74", "text": "## `async` и `await` { #async-and-await }\n\nВ современных версиях Python есть очень интуитивный способ определять асинхронный код. Это делает его похожим на обычный «последовательный» код, а «ожидание» выполняется за вас в нужные моменты.\n\nКогда есть операция, которой нужно подождать перед тем, как вернуть результат, и она поддерживает эти новые возможности Python, вы можете написать так:\n\n```Python\nburgers = await get_burgers(2)\n```\n\nКлюч здесь — `await`. Он говорит Python, что нужно подождать ⏸, пока `get_burgers(2)` закончит своё дело 🕙, прежде чем сохранять результат в `burgers`. Благодаря этому Python будет знать, что за это время можно заняться чем-то ещё 🔀 ⏯ (например, принять другой запрос).\n\nЧтобы `await` работал, он должен находиться внутри функции, которая поддерживает такую асинхронность. Для этого просто объявите её с `async def`:\n\n```Python hl_lines=\"1\"\nasync def get_burgers(number: int):\n    # Сделать что-то асинхронное, чтобы приготовить бургеры\n    return burgers\n```\n\n...вместо `def`:\n\n```Python hl_lines=\"2\"\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 20, "header": "`async` и `await`", "header_level": 2, "token_count": 398}
{"id": "782a0219010e4284", "text": "# Это не асинхронный код\ndef get_sequential_burgers(number: int):\n    # Сделать что-то последовательное, чтобы приготовить бургеры\n    return burgers\n```\n\nС `async def` Python знает, что внутри этой функции нужно учитывать выражения `await` и что выполнение такой функции можно «приостанавливать» ⏸ и идти делать что-то ещё 🔀, чтобы потом вернуться.\n\nКогда вы хотите вызвать функцию, объявленную с `async def`, нужно её «ожидать». Поэтому вот так не сработает:\n\n```Python\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 21, "header": "Это не асинхронный код", "header_level": 1, "token_count": 180}
{"id": "1d1bc3486e3fd88d", "text": "# Это не сработает, потому что get_burgers определена с: async def\nburgers = get_burgers(2)\n```\n\n---\n\nИтак, если вы используете библиотеку, которую можно вызывать с `await`, вам нужно создать *функцию-обработчик пути*, которая её использует, с `async def`, например:\n\n```Python hl_lines=\"2-3\"\n@app.get('/burgers')\nasync def read_burgers():\n    burgers = await get_burgers(2)\n    return burgers\n```\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 22, "header": "Это не сработает, потому что get_burgers определена с: async def", "header_level": 1, "token_count": 137}
{"id": "c8aed22595500b6e", "text": "### Более технические подробности { #more-technical-details }\n\nВы могли заметить, что `await` можно использовать только внутри функций, определённых с `async def`.\n\nНо при этом функции, определённые с `async def`, нужно «ожидать». Значит, функции с `async def` тоже можно вызывать только из функций, определённых с `async def`.\n\nТак что же с «яйцом и курицей» — как вызвать первую `async` функцию?\n\nЕсли вы работаете с **FastAPI**, вам не о чем беспокоиться, потому что этой «первой» функцией будет ваша *функция-обработчик пути*, а FastAPI знает, как сделать всё правильно.\n\nНо если вы хотите использовать `async` / `await` без FastAPI, вы тоже можете это сделать.\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 23, "header": "Более технические подробности", "header_level": 3, "token_count": 247}
{"id": "f5a2bea62daa2b7d", "text": "### Пишите свой асинхронный код { #write-your-own-async-code }\n\nStarlette (и **FastAPI**) основаны на <a href=\"https://anyio.readthedocs.io/en/stable/\" class=\"external-link\" target=\"_blank\">AnyIO</a>, что делает их совместимыми и со стандартной библиотекой Python <a href=\"https://docs.python.org/3/library/asyncio-task.html\" class=\"external-link\" target=\"_blank\">asyncio</a>, и с <a href=\"https://trio.readthedocs.io/en/stable/\" class=\"external-link\" target=\"_blank\">Trio</a>.\n\nВ частности, вы можете напрямую использовать <a href=\"https://anyio.readthedocs.io/en/stable/\" class=\"external-link\" target=\"_blank\">AnyIO</a> для продвинутых сценариев конкурентности, где в вашем коде нужны более сложные паттерны.\n\nИ даже если вы не используете FastAPI, вы можете писать свои асинхронные приложения с <a href=\"https://anyio.readthedocs.io/en/stable/\" class=\"external-link\" target=\"_blank\">AnyIO</a>, чтобы они были максимально совместимыми и получали его преимущества (например, *структурную конкурентность*).", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Пишите свой асинхронный код", "section_header_level": 3}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 24, "header": "Пишите свой асинхронный код", "header_level": 3, "token_count": 347}
{"id": "39a6ffc54e9e7e20", "text": "thedocs.io/en/stable/\" class=\"external-link\" target=\"_blank\">AnyIO</a>, чтобы они были максимально совместимыми и получали его преимущества (например, *структурную конкурентность*).\n\nЯ создал ещё одну библиотеку поверх AnyIO, тонкий слой, чтобы немного улучшить аннотации типов и получить более качественное **автозавершение**, **ошибки прямо в редакторе** и т.д. Там также есть дружелюбное введение и руководство, чтобы помочь вам **понять** и писать **свой собственный асинхронный код**: <a href=\"https://asyncer.tiangolo.com/\" class=\"external-link\" target=\"_blank\">Asyncer</a>. Она особенно полезна, если вам нужно **комбинировать асинхронный код с обычным** (блокирующим/синхронным) кодом.", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md", "section_header": "Пишите свой асинхронный код", "section_header_level": 3}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 25, "header": "Пишите свой асинхронный код", "header_level": 3, "token_count": 288}
{"id": "6e25009a59788e2f", "text": "### Другие формы асинхронного кода { #other-forms-of-asynchronous-code }\n\nТакой стиль использования `async` и `await` относительно новый в языке.\n\nНо он сильно упрощает работу с асинхронным кодом.\n\nТакой же (или почти такой же) синтаксис недавно появился в современных версиях JavaScript (в браузере и NodeJS).\n\nДо этого работа с асинхронным кодом была заметно сложнее и труднее для понимания.\n\nВ предыдущих версиях Python можно было использовать потоки или <a href=\"https://www.gevent.org/\" class=\"external-link\" target=\"_blank\">Gevent</a>. Но такой код гораздо сложнее понимать, отлаживать и держать в голове.\n\nВ прежних версиях NodeJS/браузерного JavaScript вы бы использовали «callbacks» (обратные вызовы), что приводит к «callback hell» (ад обратных вызовов).\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 26, "header": "Другие формы асинхронного кода", "header_level": 3, "token_count": 300}
{"id": "7cf5e06b0b42d3ec", "text": "## Сопрограммы { #coroutines }\n\n**Сопрограмма** (coroutine) — это просто «навороченное» слово для того, что возвращает функция `async def`. Python знает, что это похоже на функцию: её можно запустить, она когда-нибудь завершится, но её выполнение может приостанавливаться ⏸ внутри, когда встречается `await`.\n\nЧасто всю функциональность использования асинхронного кода с `async` и `await` кратко называют «сопрограммами». Это сопоставимо с ключевой особенностью Go — «goroutines».\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 27, "header": "Сопрограммы", "header_level": 2, "token_count": 188}
{"id": "cdeb42f794bb1210", "text": "## Заключение { #conclusion }\n\nВернёмся к той же фразе:\n\n> Современные версии Python поддерживают **«асинхронный код»** с помощью **«сопрограмм»** (coroutines) и синтаксиса **`async` и `await`**.\n\nТеперь это должно звучать понятнее. ✨\n\nИменно это «движет» FastAPI (через Starlette) и обеспечивает столь впечатляющую производительность.\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 28, "header": "Заключение", "header_level": 2, "token_count": 148}
{"id": "53c030540cb5c74c", "text": "## Очень технические подробности { #very-technical-details }\n\n/// warning | Предупреждение\n\nСкорее всего, этот раздел можно пропустить.\n\nЗдесь — очень технические подробности о том, как **FastAPI** работает «под капотом».\n\nЕсли у вас есть достаточно технических знаний (сопрограммы, потоки, блокировки и т.д.) и вам интересно, как FastAPI обрабатывает `async def` по сравнению с обычным `def`, — вперёд.\n\n///\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 29, "header": "Очень технические подробности", "header_level": 2, "token_count": 172}
{"id": "90ea123fc9f6aa10", "text": "### Функции-обработчики пути { #path-operation-functions }\n\nКогда вы объявляете *функцию-обработчик пути* обычным `def` вместо `async def`, она запускается во внешнем пуле потоков, который затем «ожидается», вместо прямого вызова (прямой вызов заблокировал бы сервер).\n\nЕсли вы пришли из другого async-фреймворка, который работает иначе, и привыкли объявлять тривиальные *функции-обработчики пути*, выполняющие только вычисления, через простой `def` ради крошечной выгоды в производительности (около 100 наносекунд), обратите внимание: в **FastAPI** эффект будет противоположным. В таких случаях лучше использовать `async def`, если только ваши *функции-обработчики пути* не используют код, выполняющий блокирующий <abbr title=\"Input/Output – Ввод/вывод: чтение или запись на диск, сетевые соединения.\">I/O</abbr>.\n\nТем не менее, в обоих случаях велика вероятность, что **FastAPI** [всё равно будет быстрее](index.md#performance){.internal-link target=_blank} (или как минимум сопоставим) с вашим предыдущим фреймворком.\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 30, "header": "Функции-обработчики пути", "header_level": 3, "token_count": 420}
{"id": "d84d262d1d5cf75e", "text": "### Зависимости { #dependencies }\n\nТо же относится к [зависимостям](tutorial/dependencies/index.md){.internal-link target=_blank}. Если зависимость — это обычная функция `def`, а не `async def`, она запускается во внешнем пуле потоков.\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 31, "header": "Зависимости", "header_level": 3, "token_count": 84}
{"id": "87a4950f848865b2", "text": "### Подзависимости { #sub-dependencies }\n\nУ вас может быть несколько зависимостей и [подзависимостей](tutorial/dependencies/sub-dependencies.md){.internal-link target=_blank}, которые требуют друг друга (в виде параметров определений функций): часть из них может быть объявлена с `async def`, а часть — обычным `def`. Всё будет работать, а те, что объявлены обычным `def`, будут вызываться во внешнем потоке (из пула), а не «ожидаться».\n\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 32, "header": "Подзависимости", "header_level": 3, "token_count": 159}
{"id": "7552fc2821bce5f3", "text": "### Другие служебные функции { #other-utility-functions }\n\nЛюбые другие служебные функции, которые вы вызываете напрямую, можно объявлять обычным `def` или `async def`, и FastAPI не будет влиять на то, как вы их вызываете.\n\nВ отличие от функций, которые FastAPI вызывает за вас: *функции-обработчики пути* и зависимости.\n\nЕсли служебная функция — обычная функция с `def`, она будет вызвана напрямую (как вы и пишете в коде), не в пуле потоков; если функция объявлена с `async def`, тогда при её вызове в вашем коде вы должны использовать `await`.\n\n---\n\nСнова: это очень технические подробности, полезные, вероятно, только если вы целенаправленно их ищете.\n\nИначе вам достаточно руководствоваться рекомендациями из раздела выше: <a href=\"#in-a-hurry\">Нет времени?</a>.\n", "metadata": {"title": "Конкурентность и async / await", "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "source_mtime": "2026-01-12T17:48:12.857622+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\async.md"}, "doc_id": "67b5ba5ffc65", "source_path": "docs\\async.md", "title": "Конкурентность и async / await", "chunk_index": 33, "header": "Другие служебные функции", "header_level": 3, "token_count": 303}
{"id": "b3f814160a920f9e", "text": "# Бенчмарки (тесты производительности) { #benchmarks }\n\nНезависимые бенчмарки TechEmpower показывают, что приложения **FastAPI** под управлением Uvicorn — <a href=\"https://www.techempower.com/benchmarks/#section=test&runid=7464e520-0dc2-473d-bd34-dbdfd7e85911&hw=ph&test=query&l=zijzen-7\" class=\"external-link\" target=\"_blank\">одни из самых быстрых Python‑фреймворков</a>, уступающие только Starlette и самому Uvicorn (используются внутри FastAPI).\n\nНо при просмотре бенчмарков и сравнений следует иметь в виду следующее.\n\n", "metadata": {"title": "Бенчмарки (тесты производительности)", "doc_id": "afcf26068d41", "source_path": "docs\\benchmarks.md", "source_mtime": "2026-01-12T17:48:12.865533+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\benchmarks.md"}, "doc_id": "afcf26068d41", "source_path": "docs\\benchmarks.md", "title": "Бенчмарки (тесты производительности)", "chunk_index": 0, "header": "Бенчмарки (тесты производительности)", "header_level": 1, "token_count": 206}
{"id": "b3f814160a920f9e", "text": "## Бенчмарки и скорость { #benchmarks-and-speed }\n\nПри проверке бенчмарков часто можно увидеть, что инструменты разных типов сравнивают как эквивалентные.\n\nВ частности, часто сравнивают вместе Uvicorn, Starlette и FastAPI (среди многих других инструментов).\n\nЧем проще задача, которую решает инструмент, тем выше его производительность. И большинство бенчмарков не тестируют дополнительные возможности, предоставляемые инструментом.\n\nИерархия выглядит так:\n\n* **Uvicorn**: ASGI-сервер\n    * **Starlette**: (использует Uvicorn) веб-микрофреймворк\n        * **FastAPI**: (использует Starlette) API-микрофреймворк с рядом дополнительных возможностей для создания API, включая валидацию данных и т. п.", "metadata": {"title": "Бенчмарки (тесты производительности)", "doc_id": "afcf26068d41", "source_path": "docs\\benchmarks.md", "source_mtime": "2026-01-12T17:48:12.865533+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\benchmarks.md", "section_header": "Бенчмарки и скорость", "section_header_level": 2}, "doc_id": "afcf26068d41", "source_path": "docs\\benchmarks.md", "title": "Бенчмарки (тесты производительности)", "chunk_index": 1, "header": "Бенчмарки и скорость", "header_level": 2, "token_count": 285}
{"id": "5e8abc9fe2623190", "text": "ворк\n        * **FastAPI**: (использует Starlette) API-микрофреймворк с рядом дополнительных возможностей для создания API, включая валидацию данных и т. п.\n\n* **Uvicorn**:\n    * Будет иметь наилучшую производительность, так как помимо самого сервера у него немного дополнительного кода.\n    * Вы не будете писать приложение непосредственно на Uvicorn. Это означало бы, что Ваш код должен включать как минимум весь код, предоставляемый Starlette (или **FastAPI**). И если Вы так сделаете, то в конечном итоге Ваше приложение будет иметь те же накладные расходы, что и при использовании фреймворка, минимизирующего код Вашего приложения и Ваши ошибки.\n    * Если Вы сравниваете Uvicorn, сравнивайте его с Daphne, Hypercorn, uWSGI и т. д. — серверами приложений.\n* **Starlette**:\n    * Будет на следующем месте по производительности после Uvicorn. Фактически Starlette запускается под управлением Uvicorn, поэтому он может быть только «медленнее» Uvicorn из‑за выполнения большего объёма кода.\n    * Зато он предоставляет Вам инструменты для создания простых веб‑приложений с маршрутизацией по путям и т. п.\n    * Если Вы сравниваете Starlette, сравнивайте его с Sanic, Flask, Django и т. д. — веб‑фреймворками (или микрофреймворками).\n* **FastAPI**:\n    * Точно так же, как Starlette использует Uvicorn и не может быть быстрее него, **FastAPI** использует Starlette, поэтому не может быть быстрее его.\n    * FastAPI предоставляет больше возможностей поверх Starlette — те, которые почти всегда нужны при создании API, такие как валидация и сериализация данных. В довесок Вы ещё и получаете автоматическую документацию (автоматическая документация даже не увеличивает накладные расходы при работе приложения, так как она создаётся при запуске).\n    * Если бы Вы не использовали FastAPI, а использовали Starlette напрямую (или другой инструмент вроде Sanic, Flask, Responder и т. д.), Вам пришлось бы самостоятельно реализовать валидацию и сериализацию данных. То есть, в итоге, Ваше приложение имело бы такие же накладные расходы, как если бы оно было создано с использованием FastAPI. И во многих случаях валидация и сериализация данных представляют собой самый большой объём кода, написанного в приложениях.\n    * Таким образом, используя FastAPI, Вы экономите время разработки, уменьшаете количество ошибок, строк кода и, вероятно, получите ту же производительность (или лучше), как и если бы не использовали его (поскольку Вам пришлось бы реализовать все его возможности в своём коде).\n    * Если Вы сравниваете FastAPI, сравнивайте его с фреймворком веб‑приложений (или набором инструментов), который обеспечивает валидацию данных, сериализацию и документацию, такими как Flask-apispec, NestJS, Molten и им подобные. Фреймворки с интегрированной автоматической валидацией данных, сериализацией и документацией.", "metadata": {"title": "Бенчмарки (тесты производительности)", "doc_id": "afcf26068d41", "source_path": "docs\\benchmarks.md", "source_mtime": "2026-01-12T17:48:12.865533+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\benchmarks.md", "section_header": "Бенчмарки и скорость", "section_header_level": 2}, "doc_id": "afcf26068d41", "source_path": "docs\\benchmarks.md", "title": "Бенчмарки (тесты производительности)", "chunk_index": 2, "header": "Бенчмарки и скорость", "header_level": 2, "token_count": 1081}
{"id": "71420e4f84729f6a", "text": "# Переменные окружения { #environment-variables }\n\n/// tip | Совет\n\nЕсли вы уже знаете, что такое «переменные окружения» и как их использовать, можете пропустить это.\n\n///\n\nПеременная окружения (также известная как «**env var**») - это переменная, которая живет **вне** кода Python, в **операционной системе**, и может быть прочитана вашим кодом Python (или другими программами).\n\nПеременные окружения могут быть полезны для работы с **настройками** приложений, как часть **установки** Python и т.д.\n\n", "metadata": {"title": "Переменные окружения", "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "source_mtime": "2026-01-12T17:48:12.872158+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\environment-variables.md"}, "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "title": "Переменные окружения", "chunk_index": 0, "header": "Переменные окружения", "header_level": 1, "token_count": 179}
{"id": "ad627deca4d198fd", "text": "## Создание и использование переменных окружения { #create-and-use-env-vars }\n\nМожно **создавать** и использовать переменные окружения в **оболочке (терминале)**, не прибегая к помощи Python:\n\n//// tab | Linux, macOS, Windows Bash\n\n<div class=\"termy\">\n\n```console\n// Вы можете создать переменную окружения MY_NAME с помощью\n$ export MY_NAME=\"Wade Wilson\"\n\n// Затем её можно использовать в других программах, например\n$ echo \"Hello $MY_NAME\"\n\nHello Wade Wilson\n```\n\n</div>\n\n////\n\n//// tab | Windows PowerShell\n\n<div class=\"termy\">\n\n```console\n// Создайте переменную окружения MY_NAME\n$ $Env:MY_NAME = \"Wade Wilson\"\n\n// Используйте её с другими программами, например\n$ echo \"Hello $Env:MY_NAME\"\n\nHello Wade Wilson\n```\n\n</div>\n\n////\n\n", "metadata": {"title": "Переменные окружения", "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "source_mtime": "2026-01-12T17:48:12.872158+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\environment-variables.md"}, "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "title": "Переменные окружения", "chunk_index": 1, "header": "Создание и использование переменных окружения", "header_level": 2, "token_count": 229}
{"id": "71420e4f84729f6a", "text": "## Чтение переменных окружения в python { #read-env-vars-in-python }\n\nТак же существует возможность создания переменных окружения **вне** Python, в терминале (или любым другим способом), а затем **чтения их в Python**.\n\nНапример, у вас есть файл `main.py`:\n\n```Python hl_lines=\"3\"\nimport os\n\nname = os.getenv(\"MY_NAME\", \"World\")\nprint(f\"Hello {name} from Python\")\n```\n\n/// tip | Совет\n\nВторой аргумент <a href=\"https://docs.python.org/3.8/library/os.html#os.getenv\" class=\"external-link\" target=\"_blank\">`os.getenv()`</a> - это возвращаемое по умолчанию значение.\n\nЕсли значение не указано, то по умолчанию оно равно `None`. В данном случае мы указываем `«World»` в качестве значения по умолчанию.\n\n///\n\nЗатем можно запустить эту программу на Python:\n\n//// tab | Linux, macOS, Windows Bash\n\n<div class=\"termy\">\n\n```console\n// Здесь мы еще не устанавливаем переменную окружения\n$ python main.py\n\n// Поскольку мы не задали переменную окружения, мы получим значение по умолчанию\n\nHello World from Python\n\n// Но если мы сначала создадим переменную окружения\n$ export MY_NAME=\"Wade Wilson\"\n\n// А затем снова запустим программу\n$ python main.py\n\n// Теперь она прочитает переменную окружения\n\nHello Wade Wilson from Python\n```\n\n</div>\n\n////\n\n//// tab | Windows PowerShell\n\n<div class=\"termy\">\n\n```console\n// Здесь мы еще не устанавливаем переменную окружения\n$ python main.py\n\n// Поскольку мы не задали переменную окружения, мы получим значение по умолчанию\n\nHello World from Python", "metadata": {"title": "Переменные окружения", "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "source_mtime": "2026-01-12T17:48:12.872158+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\environment-variables.md", "section_header": "Чтение переменных окружения в python", "section_header_level": 2}, "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "title": "Переменные окружения", "chunk_index": 2, "header": "Чтение переменных окружения в python", "header_level": 2, "token_count": 486}
{"id": "ad627deca4d198fd", "text": "\">\n\n```console\n// Здесь мы еще не устанавливаем переменную окружения\n$ python main.py\n\n// Поскольку мы не задали переменную окружения, мы получим значение по умолчанию\n\nHello World from Python\n\n// Но если мы сначала создадим переменную окружения\n$ $Env:MY_NAME = \"Wade Wilson\"\n\n// А затем снова запустим программу\n$ python main.py\n\n// Теперь она может прочитать переменную окружения\n\nHello Wade Wilson from Python\n```\n\n</div>\n\n////\n\nПоскольку переменные окружения могут быть установлены вне кода, но могут быть прочитаны кодом, и их не нужно хранить (фиксировать в `git`) вместе с остальными файлами, их принято использовать для конфигураций или **настроек**.\n\nВы также можете создать переменную окружения только для **конкретного вызова программы**, которая будет доступна только для этой программы и только на время ее выполнения.\n\nДля этого создайте её непосредственно перед самой программой, в той же строке:\n\n<div class=\"termy\">\n\n```console\n// Создайте переменную окружения MY_NAME в строке для этого вызова программы\n$ MY_NAME=\"Wade Wilson\" python main.py\n\n// Теперь она может прочитать переменную окружения\n\nHello Wade Wilson from Python\n\n// После этого переменная окружения больше не существует\n$ python main.py\n\nHello World from Python\n```\n\n</div>\n\n/// tip | Совет\n\nПодробнее об этом можно прочитать на сайте <a href=\"https://12factor.net/config\" class=\"external-link\" target=\"_blank\">The Twelve-Factor App: Config</a>.\n\n///", "metadata": {"title": "Переменные окружения", "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "source_mtime": "2026-01-12T17:48:12.872158+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\environment-variables.md", "section_header": "Чтение переменных окружения в python", "section_header_level": 2}, "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "title": "Переменные окружения", "chunk_index": 3, "header": "Чтение переменных окружения в python", "header_level": 2, "token_count": 477}
{"id": "39013d6aa2eab7c9", "text": "## Типизация и Валидация { #types-and-validation }\n\nЭти переменные окружения могут работать только с **текстовыми строками**, поскольку они являются внешними по отношению к Python и должны быть совместимы с другими программами и остальной системой (и даже с различными операционными системами, такими как Linux, Windows, macOS).\n\nЭто означает, что **любое значение**, считанное в Python из переменной окружения, **будет `str`**, и любое преобразование к другому типу или любая проверка должны быть выполнены в коде.\n\nПодробнее об использовании переменных окружения для работы с **настройками приложения** вы узнаете в [Расширенное руководство пользователя - Настройки и переменные среды](./advanced/settings.md){.internal-link target=_blank}.\n\n", "metadata": {"title": "Переменные окружения", "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "source_mtime": "2026-01-12T17:48:12.872158+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\environment-variables.md"}, "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "title": "Переменные окружения", "chunk_index": 4, "header": "Типизация и Валидация", "header_level": 2, "token_count": 257}
{"id": "0bb57b719abad50e", "text": "## Переменная окружения `PATH` { #path-environment-variable }\n\nСуществует **специальная** переменная окружения **`PATH`**, которая используется операционными системами (Linux, macOS, Windows) для поиска программ для запуска.\n\nЗначение переменной `PATH` - это длинная строка, состоящая из каталогов, разделенных двоеточием `:` в Linux и macOS, и точкой с запятой `;` в Windows.\n\nНапример, переменная окружения `PATH` может выглядеть следующим образом:\n\n//// tab | Linux, macOS\n\n```plaintext\n/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\n```\n\nЭто означает, что система должна искать программы в каталогах:\n\n* `/usr/local/bin`\n* `/usr/bin`\n* `/bin`\n* `/usr/sbin`\n* `/sbin`\n\n////\n\n//// tab | Windows\n\n```plaintext\nC:\\Program Files\\Python312\\Scripts;C:\\Program Files\\Python312;C:\\Windows\\System32\n```\n\nЭто означает, что система должна искать программы в каталогах:\n\n* `C:\\Program Files\\Python312\\Scripts`\n* `C:\\Program Files\\Python312`\n* `C:\\Windows\\System32`\n\n////\n\nКогда вы вводите **команду** в терминале, операционная система **ищет** программу в **каждой из тех директорий**, которые перечислены в переменной окружения `PATH`.\n\nНапример, когда вы вводите `python` в терминале, операционная система ищет программу под названием `python` в **первой директории** в этом списке.\n\nЕсли она ее находит, то **использует ее**. В противном случае она продолжает искать в **других каталогах**.\n\n", "metadata": {"title": "Переменные окружения", "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "source_mtime": "2026-01-12T17:48:12.872158+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\environment-variables.md"}, "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "title": "Переменные окружения", "chunk_index": 5, "header": "Переменная окружения `PATH`", "header_level": 2, "token_count": 499}
{"id": "71420e4f84729f6a", "text": "### Установка Python и обновление `PATH` { #installing-python-and-updating-the-path }\n\nПри установке Python вас могут спросить, нужно ли обновить переменную окружения `PATH`.\n\n//// tab | Linux, macOS\n\nДопустим, вы устанавливаете Python, и он оказывается в каталоге `/opt/custompython/bin`.\n\nЕсли вы скажете «да», чтобы обновить переменную окружения `PATH`, то программа установки добавит `/opt/custompython/bin` в переменную окружения `PATH`.\n\nЭто может выглядеть следующим образом:\n\n```plaintext\n/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/custompython/bin\n```\n\nТаким образом, когда вы набираете `python` в терминале, система найдет программу Python в `/opt/custompython/bin` (последний каталог) и использует ее.\n\n////\n\n//// tab | Windows\n\nДопустим, вы устанавливаете Python, и он оказывается в каталоге `C:\\opt\\custompython\\bin`.\n\nЕсли вы согласитесь обновить переменную окружения `PATH`, то программа установки добавит `C:\\opt\\custompython\\bin` в переменную окружения `PATH`.\n\n```plaintext\nC:\\Program Files\\Python312\\Scripts;C:\\Program Files\\Python312;C:\\Windows\\System32;C:\\opt\\custompython\\bin\n```\n\nТаким образом, когда вы набираете `python` в терминале, система найдет программу Python в `C:\\opt\\custompython\\bin` (последний каталог) и использует ее.\n\n////\n\nИтак, если вы напечатаете:\n\n<div class=\"termy\">\n\n```console\n$ python\n```\n\n</div>\n\n//// tab | Linux, macOS\n\nСистема **найдет** программу `python` в `/opt/custompython/bin` и запустит ее.", "metadata": {"title": "Переменные окружения", "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "source_mtime": "2026-01-12T17:48:12.872158+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\environment-variables.md", "section_header": "Установка Python и обновление `PATH`", "section_header_level": 3}, "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "title": "Переменные окружения", "chunk_index": 6, "header": "Установка Python и обновление `PATH`", "header_level": 3, "token_count": 500}
{"id": "ad627deca4d198fd", "text": "Итак, если вы напечатаете:\n\n<div class=\"termy\">\n\n```console\n$ python\n```\n\n</div>\n\n//// tab | Linux, macOS\n\nСистема **найдет** программу `python` в `/opt/custompython/bin` и запустит ее.\n\nЭто примерно эквивалентно набору текста:\n\n<div class=\"termy\">\n\n```console\n$ /opt/custompython/bin/python\n```\n\n</div>\n\n////\n\n//// tab | Windows\n\nСистема **найдет** программу `python` в каталоге `C:\\opt\\custompython\\bin\\python` и запустит ее.\n\nЭто примерно эквивалентно набору текста:\n\n<div class=\"termy\">\n\n```console\n$ C:\\opt\\custompython\\bin\\python\n```\n\n</div>\n\n////\n\nЭта информация будет полезна при изучении [Виртуальных окружений](virtual-environments.md){.internal-link target=_blank}.", "metadata": {"title": "Переменные окружения", "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "source_mtime": "2026-01-12T17:48:12.872158+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\environment-variables.md", "section_header": "Установка Python и обновление `PATH`", "section_header_level": 3}, "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "title": "Переменные окружения", "chunk_index": 7, "header": "Установка Python и обновление `PATH`", "header_level": 3, "token_count": 229}
{"id": "45de77083e452886", "text": "## Вывод { #conclusion }\n\nБлагодаря этому вы должны иметь базовое представление о том, что такое **переменные окружения** и как использовать их в Python.\n\nПодробнее о них вы также можете прочитать в <a href=\"https://en.wikipedia.org/wiki/Environment_variable\" class=\"external-link\" target=\"_blank\">статье о переменных окружения на википедии</a>.\n\nВо многих случаях не всегда очевидно, как переменные окружения могут быть полезны и применимы. Но они постоянно появляются в различных сценариях разработки, поэтому знать о них полезно.\n\nНапример, эта информация понадобится вам в следующем разделе, посвященном [Виртуальным окружениям](virtual-environments.md).\n", "metadata": {"title": "Переменные окружения", "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "source_mtime": "2026-01-12T17:48:12.872158+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\environment-variables.md"}, "doc_id": "e3a9ac51dc8a", "source_path": "docs\\environment-variables.md", "title": "Переменные окружения", "chunk_index": 8, "header": "Вывод", "header_level": 2, "token_count": 249}
{"id": "a8bdff0f34337baa", "text": "# FastAPI CLI { #fastapi-cli }\n\n**FastAPI CLI** это программа командной строки, которую вы можете использовать для запуска вашего FastAPI приложения, для управления FastAPI-проектом, а также для многих других вещей.\n\n`fastapi-cli` устанавливается вместе со стандартным пакетом FastAPI (при запуске команды `pip install \"fastapi[standard]\"`). Данный пакет предоставляет доступ к программе `fastapi` через терминал.\n\nЧтобы запустить приложение FastAPI в режиме разработки, вы можете использовать команду `fastapi dev`:\n\n<div class=\"termy\">\n\n```console\n$ <font color=\"#4E9A06\">fastapi</font> dev <u style=\"text-decoration-style:solid\">main.py</u>\n\n  <span style=\"background-color:#009485\"><font color=\"#D3D7CF\"> FastAPI </font></span>  Starting development server 🚀\n\n             Searching for package file structure from directories with\n             <font color=\"#3465A4\">__init__.py</font> files\n             Importing from <font color=\"#75507B\">/home/user/code/</font><font color=\"#AD7FA8\">awesomeapp</font>\n\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> module </font></span>  🐍 main.py\n\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> code </font></span>  Importing the FastAPI app object from the module with the\n             following code:\n\n             <u style=\"text-decoration-style:solid\">from </u><u style=\"text-decoration-style:solid\"><b>main</b></u><u style=\"text-decoration-style:solid\"> import </u><u style=\"text-decoration-style:solid\"><b>app</b></u>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> app </font></span>  Using import string: <font color=\"#3465A4\">main:app</font>", "metadata": {"title": "FastAPI CLI", "doc_id": "a1c559ee2aec", "source_path": "docs\\fastapi-cli.md", "source_mtime": "2026-01-12T17:48:12.876721+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\fastapi-cli.md", "section_header": "FastAPI CLI", "section_header_level": 1}, "doc_id": "a1c559ee2aec", "source_path": "docs\\fastapi-cli.md", "title": "FastAPI CLI", "chunk_index": 0, "header": "FastAPI CLI", "header_level": 1, "token_count": 499}
{"id": "77d5191da8c13633", "text": "><u style=\"text-decoration-style:solid\"><b>app</b></u>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> app </font></span>  Using import string: <font color=\"#3465A4\">main:app</font>\n\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Server started at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://127.0.0.1:8000</u></font>\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Documentation at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://127.0.0.1:8000/docs</u></font>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> tip </font></span>  Running in development mode, for production use:\n             <b>fastapi run</b>\n\n             Logs:", "metadata": {"title": "FastAPI CLI", "doc_id": "a1c559ee2aec", "source_path": "docs\\fastapi-cli.md", "source_mtime": "2026-01-12T17:48:12.876721+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\fastapi-cli.md", "section_header": "FastAPI CLI", "section_header_level": 1}, "doc_id": "a1c559ee2aec", "source_path": "docs\\fastapi-cli.md", "title": "FastAPI CLI", "chunk_index": 1, "header": "FastAPI CLI", "header_level": 1, "token_count": 241}
{"id": "b94637eb51d0eb47", "text": ".0.0.1:8000/docs</u></font>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> tip </font></span>  Running in development mode, for production use:\n             <b>fastapi run</b>\n\n             Logs:\n\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Will watch for changes in these directories:\n             <b>[</b><font color=\"#4E9A06\">&apos;/home/user/code/awesomeapp&apos;</font><b>]</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Uvicorn running on <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://127.0.0.1:8000</u></font> <b>(</b>Press CTRL+C to\n             quit<b>)</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started reloader process <b>[</b><font color=\"#34E2E2\"><b>383138</b></font><b>]</b> using WatchFiles\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started server process <b>[</b><font color=\"#34E2E2\"><b>383153</b></font><b>]</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Waiting for application startup.\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Application startup complete.\n```\n\n</div>\n\nПриложение командной строки `fastapi` это и есть **FastAPI CLI**.\n\nFastAPI CLI берет путь к вашей Python-программе (напр. `main.py`) и автоматически находит объект `FastAPI` (обычно это `app`), затем определяет правильный процесс импорта и запускает сервер приложения.", "metadata": {"title": "FastAPI CLI", "doc_id": "a1c559ee2aec", "source_path": "docs\\fastapi-cli.md", "source_mtime": "2026-01-12T17:48:12.876721+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\fastapi-cli.md", "section_header": "FastAPI CLI", "section_header_level": 1}, "doc_id": "a1c559ee2aec", "source_path": "docs\\fastapi-cli.md", "title": "FastAPI CLI", "chunk_index": 2, "header": "FastAPI CLI", "header_level": 1, "token_count": 505}
{"id": "f39e2be5610fb4d8", "text": "программе (напр. `main.py`) и автоматически находит объект `FastAPI` (обычно это `app`), затем определяет правильный процесс импорта и запускает сервер приложения.\n\nДля работы в режиме продакшн вместо `fastapi dev` нужно использовать `fastapi run`. \n\nВнутри **FastAPI CLI** используется <a href=\"https://www.uvicorn.dev\" class=\"external-link\" target=\"_blank\">Uvicorn</a>, высокопроизводительный, готовый к работе в продакшне ASGI-сервер.", "metadata": {"title": "FastAPI CLI", "doc_id": "a1c559ee2aec", "source_path": "docs\\fastapi-cli.md", "source_mtime": "2026-01-12T17:48:12.876721+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\fastapi-cli.md", "section_header": "FastAPI CLI", "section_header_level": 1}, "doc_id": "a1c559ee2aec", "source_path": "docs\\fastapi-cli.md", "title": "FastAPI CLI", "chunk_index": 3, "header": "FastAPI CLI", "header_level": 1, "token_count": 164}
{"id": "0ba5932f08f63972", "text": "## `fastapi dev` { #fastapi-dev }\n\nВызов `fastapi dev` запускает режим разработки.\n\nПо умолчанию включена авто-перезагрузка (**auto-reload**), благодаря этому при изменении кода происходит перезагрузка сервера приложения. Эта установка требует значительных ресурсов и делает систему менее стабильной. Используйте её только при разработке. Приложение слушает входящие подключения на IP `127.0.0.1`. Это IP адрес вашей машины, предназначенный для внутренних коммуникаций (`localhost`).\n\n", "metadata": {"title": "FastAPI CLI", "doc_id": "a1c559ee2aec", "source_path": "docs\\fastapi-cli.md", "source_mtime": "2026-01-12T17:48:12.876721+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\fastapi-cli.md"}, "doc_id": "a1c559ee2aec", "source_path": "docs\\fastapi-cli.md", "title": "FastAPI CLI", "chunk_index": 4, "header": "`fastapi dev`", "header_level": 2, "token_count": 185}
{"id": "d9d980a3c14c33ed", "text": "## `fastapi run` { #fastapi-run }\n\nВызов `fastapi run` по умолчанию запускает FastAPI в режиме продакшн.\n\nПо умолчанию авто-перезагрузка (**auto-reload**) отключена. Приложение слушает входящие подключения на IP `0.0.0.0`, т.е. на всех доступных адресах компьютера. Таким образом, приложение будет находиться в публичном доступе для любого, кто может подсоединиться к вашей машине. Продуктовые приложения запускаются именно так, например, с помощью контейнеров.\n\nВ большинстве случаев вы будете (и должны) использовать прокси-сервер (\"termination proxy\"), который будет поддерживать HTTPS поверх вашего приложения. Всё будет зависеть от того, как вы развертываете приложение: за вас это либо сделает ваш провайдер, либо вам придется сделать настройки самостоятельно.\n\n/// tip | Подсказка\n\nВы можете больше узнать об этом в [документации по развертыванию](deployment/index.md){.internal-link target=_blank}.\n\n///\n", "metadata": {"title": "FastAPI CLI", "doc_id": "a1c559ee2aec", "source_path": "docs\\fastapi-cli.md", "source_mtime": "2026-01-12T17:48:12.876721+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\fastapi-cli.md"}, "doc_id": "a1c559ee2aec", "source_path": "docs\\fastapi-cli.md", "title": "FastAPI CLI", "chunk_index": 5, "header": "`fastapi run`", "header_level": 2, "token_count": 342}
{"id": "a4512580df001c5f", "text": "# Возможности { #features }\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 0, "header": "Возможности", "header_level": 1, "token_count": 9}
{"id": "45184fde4728cc69", "text": "## Возможности FastAPI { #fastapi-features }\n\n**FastAPI** предлагает вам следующее:\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 1, "header": "Возможности FastAPI", "header_level": 2, "token_count": 28}
{"id": "b70711b58700f501", "text": "### Основано на открытых стандартах { #based-on-open-standards }\n\n* <a href=\"https://github.com/OAI/OpenAPI-Specification\" class=\"external-link\" target=\"_blank\"><strong>OpenAPI</strong></a> для создания API, включая объявления <abbr title=\"также известные как HTTP-методы, например: POST, GET, PUT, DELETE\">операций</abbr> <abbr title=\"также известен как: эндпоинты, маршруты)\">пути</abbr>, параметров, тел запросов, безопасности и т. д.\n* Автоматическая документация моделей данных с помощью <a href=\"https://json-schema.org/\" class=\"external-link\" target=\"_blank\"><strong>JSON Schema</strong></a> (так как сама спецификация OpenAPI основана на JSON Schema).\n* Разработан вокруг этих стандартов, после тщательного их изучения. Это не дополнительная надстройка поверх.\n* Это также позволяет использовать автоматическую **генерацию клиентского кода** на многих языках.\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 2, "header": "Основано на открытых стандартах", "header_level": 3, "token_count": 313}
{"id": "d5dfbdc699e18c09", "text": "### Автоматическая документация { #automatic-docs }\n\nИнтерактивная документация для API и исследовательские веб-интерфейсы. Поскольку фреймворк основан на OpenAPI, существует несколько вариантов документирования, 2 из них включены по умолчанию.\n\n* <a href=\"https://github.com/swagger-api/swagger-ui\" class=\"external-link\" target=\"_blank\"><strong>Swagger UI</strong></a>, с интерактивным исследованием, вызовом и тестированием вашего API прямо из браузера.\n\n![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)\n\n* Альтернативная документация API в <a href=\"https://github.com/Rebilly/ReDoc\" class=\"external-link\" target=\"_blank\"><strong>ReDoc</strong></a>.\n\n![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 3, "header": "Автоматическая документация", "header_level": 3, "token_count": 260}
{"id": "91bdaae93cf9df6f", "text": "### Только современный Python { #just-modern-python }\n\nВсе основано на стандартных **аннотациях типов Python** (благодаря Pydantic). Не нужно изучать новый синтаксис. Только стандартный современный Python.\n\nЕсли вам нужно освежить знания о типах в Python (даже если вы не используете FastAPI), выделите 2 минуты и просмотрите краткое руководство: [Типы Python](python-types.md){.internal-link target=_blank}.\n\nВы пишете стандартный Python с типами:\n\n```Python\nfrom datetime import date\n\nfrom pydantic import BaseModel\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 4, "header": "Только современный Python", "header_level": 3, "token_count": 181}
{"id": "54a26b11272b9431", "text": "# Объявляем параметр как `str`\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 5, "header": "Объявляем параметр как `str`", "header_level": 1, "token_count": 12}
{"id": "ef8c9600cf45a6d7", "text": "# и получаем поддержку редактора кода внутри функции\ndef main(user_id: str):\n    return user_id\n\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 6, "header": "и получаем поддержку редактора кода внутри функции", "header_level": 1, "token_count": 33}
{"id": "a07c6820ac57bd4a", "text": "# Модель Pydantic\nclass User(BaseModel):\n    id: int\n    name: str\n    joined: date\n```\n\nЭто можно использовать так:\n\n```Python\nmy_user: User = User(id=3, name=\"John Doe\", joined=\"2018-07-19\")\n\nsecond_user_data = {\n    \"id\": 4,\n    \"name\": \"Mary\",\n    \"joined\": \"2018-11-30\",\n}\n\nmy_second_user: User = User(**second_user_data)\n```\n\n/// info | Информация\n\n`**second_user_data` означает:\n\nПередать ключи и значения словаря `second_user_data` в качестве аргументов \"ключ-значение\", эквивалентно: `User(id=4, name=\"Mary\", joined=\"2018-11-30\")`\n\n///\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 7, "header": "Модель Pydantic", "header_level": 1, "token_count": 188}
{"id": "29f6aeea7839bcd0", "text": "### Поддержка редакторов (IDE) { #editor-support }\n\nВесь фреймворк был продуман так, чтобы быть простым и интуитивно понятным в использовании, все решения были проверены на множестве редакторов еще до начала разработки, чтобы обеспечить наилучшие условия при написании кода.\n\nВ опросах Python‑разработчиков видно, <a href=\"https://www.jetbrains.com/research/python-developers-survey-2017/#tools-and-features\" class=\"external-link\" target=\"_blank\">что одной из самых часто используемых функций является «автозавершение»</a>.\n\nВся структура **FastAPI** основана на удовлетворении этой возможности. Автозавершение работает везде.\n\nВам редко нужно будет возвращаться к документации.\n\nВот как ваш редактор может вам помочь:\n\n* в <a href=\"https://code.visualstudio.com/\" class=\"external-link\" target=\"_blank\">Visual Studio Code</a>:\n\n![editor support](https://fastapi.tiangolo.com/img/vscode-completion.png)\n\n* в <a href=\"https://www.jetbrains.com/pycharm/\" class=\"external-link\" target=\"_blank\">PyCharm</a>:\n\n![editor support](https://fastapi.tiangolo.com/img/pycharm-completion.png)\n\nВы будете получать автозавершение кода даже там, где вы считали это невозможным раньше. Как пример, ключ `price` внутри тела JSON (который может быть вложенным), приходящего в запросе.\n\nБольше никаких неправильных имён ключей, метания по документации или прокручивания кода вверх и вниз в попытках узнать — использовали вы ранее `username` или `user_name`.\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 8, "header": "Поддержка редакторов (IDE)", "header_level": 3, "token_count": 501}
{"id": "5f96e22a8932ba6a", "text": "### Краткость { #short }\n\nFastAPI имеет продуманные значения **по умолчанию** для всего, с опциональными настройками везде. Все параметры могут быть тонко подстроены так, чтобы делать то, что вам нужно, и определять необходимый вам API.\n\nНо по умолчанию всё **«просто работает»**.\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 9, "header": "Краткость", "header_level": 3, "token_count": 109}
{"id": "f6eb436dda4d2142", "text": "### Проверка значений { #validation }\n\n* Проверка значений для большинства (или всех?) **типов данных** Python, включая:\n    * Объекты JSON (`dict`).\n    * Массив JSON (`list`) с определёнными типами элементов.\n    * Строковые (`str`) поля с ограничением минимальной и максимальной длины.\n    * Числа (`int`, `float`) с минимальными и максимальными значениями и т. п.\n\n* Проверка для более экзотических типов, таких как:\n    * URL.\n    * Email.\n    * UUID.\n    * ...и другие.\n\nВсе проверки обрабатываются хорошо зарекомендовавшим себя и надёжным **Pydantic**.\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 10, "header": "Проверка значений", "header_level": 3, "token_count": 215}
{"id": "d173989f58a6fafd", "text": "### Безопасность и аутентификация { #security-and-authentication }\n\nВстроенные функции безопасности и аутентификации. Без каких‑либо компромиссов с базами данных или моделями данных.\n\nВсе схемы безопасности, определённые в OpenAPI, включая:\n\n* HTTP Basic.\n* **OAuth2** (также с **токенами JWT**). Ознакомьтесь с руководством [OAuth2 с JWT](tutorial/security/oauth2-jwt.md){.internal-link target=_blank}.\n* Ключи API в:\n    * Заголовках.\n    * Параметрах запросов.\n    * Cookies и т.п.\n\nВдобавок все функции безопасности от Starlette (включая **сессионные cookies**).\n\nВсе инструменты и компоненты спроектированы для многократного использования и легко интегрируются с вашими системами, хранилищами данных, реляционными и NoSQL базами данных и т. д.\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 11, "header": "Безопасность и аутентификация", "header_level": 3, "token_count": 277}
{"id": "9d821a248718d91c", "text": "### Внедрение зависимостей { #dependency-injection }\n\nFastAPI включает в себя чрезвычайно простую в использовании, но чрезвычайно мощную систему <abbr title='известную как: \"components\", \"resources\", \"services\", \"providers\"'><strong>Внедрения зависимостей</strong></abbr>.\n\n* Даже зависимости могут иметь зависимости, создавая иерархию или **«граф» зависимостей**.\n* Всё **автоматически обрабатывается** фреймворком.\n* Все зависимости могут запрашивать данные из запросов и **дополнять операции пути** ограничениями и автоматической документацией.\n* **Автоматическая проверка** даже для параметров *операций пути*, определённых в зависимостях.\n* Поддержка сложных систем аутентификации пользователей, **соединений с базами данных** и т. д.\n* **Никаких компромиссов** с базами данных, интерфейсами и т. д. Но при этом — лёгкая интеграция со всеми ними.\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 12, "header": "Внедрение зависимостей", "header_level": 3, "token_count": 345}
{"id": "d690d2bfe66aa712", "text": "### Нет ограничений на \"Плагины\" { #unlimited-plug-ins }\n\nИли, другими словами, нет необходимости в них — просто импортируйте и используйте нужный вам код.\n\nЛюбая интеграция разработана настолько простой в использовании (с зависимостями), что вы можете создать «плагин» для своего приложения в пару строк кода, используя ту же структуру и синтаксис, что и для ваших *операций пути*.\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 13, "header": "Нет ограничений на \"Плагины\"", "header_level": 3, "token_count": 155}
{"id": "e0df6b3dec1542e1", "text": "### Проверен { #tested }\n\n* 100% <abbr title=\"Количество автоматически проверяемого кода\">покрытие тестами</abbr>.\n* 100% <abbr title=\"Аннотации типов Python, благодаря которым ваш редактор и внешние инструменты могут обеспечить вам лучшую поддержку\">аннотирование типов</abbr> в кодовой базе.\n* Используется в продакшн‑приложениях.\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 14, "header": "Проверен", "header_level": 3, "token_count": 134}
{"id": "c8a576eabcc53f5a", "text": "## Возможности Starlette { #starlette-features }\n\n**FastAPI** основан на <a href=\"https://www.starlette.dev/\" class=\"external-link\" target=\"_blank\"><strong>Starlette</strong></a> и полностью совместим с ним. Так что любой дополнительный код Starlette, который у вас есть, также будет работать.\n\nНа самом деле, `FastAPI` — это подкласс `Starlette`. Таким образом, если вы уже знаете или используете Starlette, большая часть функционала будет работать так же.\n\nС **FastAPI** вы получаете все возможности **Starlette** (так как FastAPI — это всего лишь Starlette на стероидах):\n\n* Серьёзно впечатляющая производительность. Это <a href=\"https://github.com/encode/starlette#performance\" class=\"external-link\" target=\"_blank\">один из самых быстрых фреймворков на Python, наравне с **NodeJS** и **Go**</a>.\n* Поддержка **WebSocket**.\n* Фоновые задачи в том же процессе.\n* События запуска и выключения.\n* Тестовый клиент построен на HTTPX.\n* **CORS**, GZip, статические файлы, потоковые ответы.\n* Поддержка **сессий и cookie**.\n* 100% покрытие тестами.\n* 100% аннотирование типов в кодовой базе.\n\n", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md"}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 15, "header": "Возможности Starlette", "header_level": 2, "token_count": 392}
{"id": "a4512580df001c5f", "text": "## Возможности Pydantic { #pydantic-features }\n\n**FastAPI** полностью совместим с (и основан на) <a href=\"https://docs.pydantic.dev/\" class=\"external-link\" target=\"_blank\"><strong>Pydantic</strong></a>. Поэтому любой дополнительный код Pydantic, который у вас есть, также будет работать.\n\nВключая внешние библиотеки, также основанные на Pydantic, такие как <abbr title=\"Object-Relational Mapper\">ORM</abbr>’ы, <abbr title=\"Object-Document Mapper\">ODM</abbr>’ы для баз данных.\n\nЭто также означает, что во многих случаях вы можете передавать тот же объект, который получили из запроса, **непосредственно в базу данных**, так как всё проверяется автоматически.\n\nИ наоборот, во многих случаях вы можете просто передать объект, полученный из базы данных, **непосредственно клиенту**.\n\nС **FastAPI** вы получаете все возможности **Pydantic** (так как FastAPI основан на Pydantic для обработки данных):", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md", "section_header": "Возможности Pydantic", "section_header_level": 2}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 16, "header": "Возможности Pydantic", "header_level": 2, "token_count": 312}
{"id": "45184fde4728cc69", "text": "осто передать объект, полученный из базы данных, **непосредственно клиенту**.\n\nС **FastAPI** вы получаете все возможности **Pydantic** (так как FastAPI основан на Pydantic для обработки данных):\n\n* **Никакой нервотрёпки**:\n    * Не нужно изучать новые схемы в микроязыках.\n    * Если вы знаете типы в Python, вы знаете, как использовать Pydantic.\n* Прекрасно сочетается с вашим **<abbr title=\"Integrated Development Environment - Интегрированная среда разработки: попросту «редактора кода»\">IDE</abbr>/<abbr title=\"Программа, проверяющая ошибки в коде\">linter</abbr>/мозгом**:\n    * Потому что структуры данных pydantic — это всего лишь экземпляры классов, определённых вами; автозавершение, проверка кода, mypy и ваша интуиция — всё будет работать с вашими валидированными данными.\n* Валидация **сложных структур**:\n    * Использование иерархических моделей Pydantic; `List`, `Dict` и т. п. из модуля `typing` (входит в стандартную библиотеку Python).\n    * Валидаторы позволяют чётко и легко определять, проверять и документировать сложные схемы данных в виде JSON Schema.\n    * У вас могут быть глубоко **вложенные объекты JSON**, и все они будут проверены и аннотированы.\n* **Расширяемость**:\n    * Pydantic позволяет определять пользовательские типы данных или расширять проверку методами модели с помощью декораторов валидаторов.\n* 100% покрытие тестами.", "metadata": {"title": "Возможности", "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "source_mtime": "2026-01-12T17:48:12.882972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\features.md", "section_header": "Возможности Pydantic", "section_header_level": 2}, "doc_id": "df5498e6d3fc", "source_path": "docs\\features.md", "title": "Возможности", "chunk_index": 17, "header": "Возможности Pydantic", "header_level": 2, "token_count": 517}
{"id": "6e032443bfb5e00e", "text": "# Помочь FastAPI - Получить помощь { #help-fastapi-get-help }\n\nНравится ли Вам **FastAPI**?\n\nХотели бы Вы помочь FastAPI, другим пользователям и автору?\n\nИли Вы хотите получить помощь по **FastAPI**?\n\nЕсть несколько очень простых способов помочь (иногда достаточно всего лишь одного-двух кликов).\n\nИ также есть несколько способов получить помощь.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 0, "header": "Помочь FastAPI - Получить помощь", "header_level": 1, "token_count": 127}
{"id": "de61e29062a52fc7", "text": "## Подписаться на новостную рассылку { #subscribe-to-the-newsletter }\n\nВы можете подписаться на редкую [новостную рассылку **FastAPI и его друзья**](newsletter.md){.internal-link target=_blank} и быть в курсе о:\n\n* Новостях о FastAPI и его друзьях \n* Руководствах \n* Возможностях \n* Ломающих изменениях \n* Подсказках и хитростях \n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 1, "header": "Подписаться на новостную рассылку", "header_level": 2, "token_count": 131}
{"id": "d36fecd0a108f965", "text": "## Подписаться на FastAPI в X (Twitter) { #follow-fastapi-on-x-twitter }\n\n<a href=\"https://x.com/fastapi\" class=\"external-link\" target=\"_blank\">Подписаться на @fastapi в **X (Twitter)**</a> для получения наисвежайших новостей о **FastAPI**. \n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 2, "header": "Подписаться на FastAPI в X (Twitter)", "header_level": 2, "token_count": 78}
{"id": "f4da05904387bd76", "text": "## Добавить **FastAPI** звезду на GitHub { #star-fastapi-in-github }\n\nВы можете добавить FastAPI \"звезду\" на GitHub (кликнув на кнопку звезды в правом верхнем углу): <a href=\"https://github.com/fastapi/fastapi\" class=\"external-link\" target=\"_blank\">https://github.com/fastapi/fastapi</a>. ⭐\n\nЧем больше звёзд, тем легче другим пользователям найти проект и увидеть, что он уже оказался полезным для многих.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 3, "header": "Добавить **FastAPI** звезду на GitHub", "header_level": 2, "token_count": 152}
{"id": "f2e0e18b1e8af38d", "text": "## Отслеживать свежие выпуски в репозитории на GitHub { #watch-the-github-repository-for-releases }\n\nВы можете \"отслеживать\" FastAPI на GitHub (кликнув по кнопке \"watch\" наверху справа): <a href=\"https://github.com/fastapi/fastapi\" class=\"external-link\" target=\"_blank\">https://github.com/fastapi/fastapi</a>. \n\nТам же Вы можете выбрать \"Releases only\".\n\nС такой настройкой Вы будете получать уведомления на вашу электронную почту каждый раз, когда появится новый релиз (новая версия) **FastAPI** с исправлениями ошибок и новыми возможностями.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 4, "header": "Отслеживать свежие выпуски в репозитории на GitHub", "header_level": 2, "token_count": 192}
{"id": "6e032443bfb5e00e", "text": "## Связаться с автором { #connect-with-the-author }\n\nМожно связаться со <a href=\"https://tiangolo.com\" class=\"external-link\" target=\"_blank\">мной (Sebastián Ramírez / `tiangolo`)</a>, автором.\n\nВы можете:", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md", "section_header": "Связаться с автором", "section_header_level": 2}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 5, "header": "Связаться с автором", "header_level": 2, "token_count": 70}
{"id": "de61e29062a52fc7", "text": "автором { #connect-with-the-author }\n\nМожно связаться со <a href=\"https://tiangolo.com\" class=\"external-link\" target=\"_blank\">мной (Sebastián Ramírez / `tiangolo`)</a>, автором.\n\nВы можете:\n\n* <a href=\"https://github.com/tiangolo\" class=\"external-link\" target=\"_blank\">Подписаться на меня на **GitHub**</a>.\n    * Посмотреть другие мои проекты с открытым кодом, которые могут быть полезны Вам.\n    * Подписаться, чтобы видеть, когда я создаю новый проект с открытым кодом.\n* <a href=\"https://x.com/tiangolo\" class=\"external-link\" target=\"_blank\">Подписаться на меня в **X (Twitter)**</a> или в <a href=\"https://fosstodon.org/@tiangolo\" class=\"external-link\" target=\"_blank\">Mastodon</a>.\n    * Поделиться со мной, как Вы используете FastAPI (я обожаю это читать).\n    * Узнавать, когда я делаю объявления или выпускаю новые инструменты.\n    * Вы также можете <a href=\"https://x.com/fastapi\" class=\"external-link\" target=\"_blank\">подписаться на @fastapi в X (Twitter)</a> (это отдельный аккаунт).\n* <a href=\"https://www.linkedin.com/in/tiangolo/\" class=\"external-link\" target=\"_blank\">Подписаться на меня в **LinkedIn**</a>.\n    * Узнавать, когда я делаю объявления или выпускаю новые инструменты (хотя чаще я использую X (Twitter) ‍).\n* Читать, что я пишу (или подписаться на меня) на <a href=\"https://dev.to/tiangolo\" class=\"external-link\" target=\"_blank\">**Dev.to**</a> или <a href=\"https://medium.com/@tiangolo\" class=\"external-link\" target=\"_blank\">**Medium**</a>.\n    * Читать другие идеи, статьи и о созданных мной инструментах.\n    * Подписаться, чтобы читать, когда я публикую что-то новое.", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md", "section_header": "Связаться с автором", "section_header_level": 2}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 6, "header": "Связаться с автором", "header_level": 2, "token_count": 574}
{"id": "d36fecd0a108f965", "text": "blank\">**Medium**</a>.\n    * Читать другие идеи, статьи и о созданных мной инструментах.\n    * Подписаться, чтобы читать, когда я публикую что-то новое.", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md", "section_header": "Связаться с автором", "section_header_level": 2}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 7, "header": "Связаться с автором", "header_level": 2, "token_count": 64}
{"id": "24df969d689c0a25", "text": "## Оставить сообщение в X (Twitter) о **FastAPI** { #tweet-about-fastapi }\n\n<a href=\"https://x.com/compose/tweet?text=I'm loving @fastapi because... https://github.com/fastapi/fastapi\" class=\"external-link\" target=\"_blank\">Оставьте сообщение в X (Twitter) о **FastAPI**</a> и позвольте мне и другим узнать, почему он Вам нравится. \n\nЯ люблю узнавать о том, как **FastAPI** используется, что Вам понравилось в нём, в каких проектах/компаниях Вы его используете и т.д.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 8, "header": "Оставить сообщение в X (Twitter) о **FastAPI**", "header_level": 2, "token_count": 167}
{"id": "c0c3248c5cff83ac", "text": "## Оставить голос за FastAPI { #vote-for-fastapi }\n\n* <a href=\"https://www.slant.co/options/34241/~fastapi-review\" class=\"external-link\" target=\"_blank\">Голосуйте за **FastAPI** в Slant</a>.\n* <a href=\"https://alternativeto.net/software/fastapi/about/\" class=\"external-link\" target=\"_blank\">Голосуйте за **FastAPI** в AlternativeTo</a>.\n* <a href=\"https://stackshare.io/pypi-fastapi\" class=\"external-link\" target=\"_blank\">Расскажите, что Вы используете **FastAPI** на StackShare</a>.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 9, "header": "Оставить голос за FastAPI", "header_level": 2, "token_count": 148}
{"id": "67e82e1c113fdc81", "text": "## Помочь другим с вопросами на GitHub { #help-others-with-questions-in-github }\n\nВы можете попробовать помочь другим с их вопросами в:\n\n* <a href=\"https://github.com/fastapi/fastapi/discussions/categories/questions?discussions_q=category%3AQuestions+is%3Aunanswered\" class=\"external-link\" target=\"_blank\">GitHub Discussions</a>\n* <a href=\"https://github.com/fastapi/fastapi/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3Aquestion+-label%3Aanswered+\" class=\"external-link\" target=\"_blank\">GitHub Issues</a>\n\nВо многих случаях Вы уже можете знать ответы на эти вопросы. \n\nЕсли Вы много помогаете людям с их вопросами, Вы станете официальным [Экспертом FastAPI](fastapi-people.md#fastapi-experts){.internal-link target=_blank}. \n\nТолько помните, самое важное — постарайтесь быть добрыми. Люди приходят со своими разочарованиями и часто задают вопросы не лучшим образом, но постарайтесь, насколько можете, быть доброжелательными. \n\nИдея сообщества **FastAPI** — быть доброжелательным и гостеприимным. В то же время не допускайте травлю или неуважительное поведение по отношению к другим. Мы должны заботиться друг о друге.\n\n---\n\nКак помочь другим с вопросами (в обсуждениях или Issues):\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 10, "header": "Помочь другим с вопросами на GitHub", "header_level": 2, "token_count": 439}
{"id": "96727d64f85223c8", "text": "### Понять вопрос { #understand-the-question }\n\n* Убедитесь, что поняли **цель** и кейс использования задающего вопрос.\n\n* Затем проверьте, что вопрос (в подавляющем большинстве это вопросы) сформулирован **ясно**.\n\n* Во многих случаях спрашивают о воображаемом решении пользователя, но может быть решение **получше**. Если Вы лучше поймёте проблему и кейс, сможете предложить **альтернативное решение**.\n\n* Если вопрос непонятен, запросите больше **деталей**.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 11, "header": "Понять вопрос", "header_level": 3, "token_count": 186}
{"id": "b49bca2a60b31d1e", "text": "### Воспроизвести проблему { #reproduce-the-problem }\n\nВ большинстве случаев и вопросов есть что-то связанное с **исходным кодом** автора.\n\nВо многих случаях предоставляют только фрагмент кода, но этого недостаточно, чтобы **воспроизвести проблему**.\n\n* Попросите предоставить <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\" class=\"external-link\" target=\"_blank\">минимальный воспроизводимый пример</a>, который Вы сможете **скопировать-вставить** и запустить локально, чтобы увидеть ту же ошибку или поведение, или лучше понять их кейс.\n\n* Если чувствуете себя особенно великодушными, можете попытаться **создать такой пример** сами, основываясь только на описании проблемы. Просто помните, что это может занять много времени, и, возможно, сначала лучше попросить уточнить проблему.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 12, "header": "Воспроизвести проблему", "header_level": 3, "token_count": 316}
{"id": "0046207337c02f35", "text": "### Предложить решение { #suggest-solutions }\n\n* После того как Вы поняли вопрос, Вы можете дать возможный **ответ**.\n\n* Во многих случаях лучше понять **исходную проблему или кейс**, потому что может существовать способ решить её лучше, чем то, что пытаются сделать.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 13, "header": "Предложить решение", "header_level": 3, "token_count": 107}
{"id": "76a9bf673ff22408", "text": "### Попросить закрыть { #ask-to-close }\n\nЕсли Вам ответили, велика вероятность, что Вы решили их проблему, поздравляю, **Вы — герой**! \n\n* Теперь, если проблема решена, можно попросить их:\n    * В GitHub Discussions: пометить комментарий как **answer** (ответ).\n    * В GitHub Issues: **закрыть** Issue.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 14, "header": "Попросить закрыть", "header_level": 3, "token_count": 116}
{"id": "2eb61fbf89cb638c", "text": "## Отслеживать репозиторий на GitHub { #watch-the-github-repository }\n\nВы можете \"отслеживать\" FastAPI на GitHub (кликнув по кнопке \"watch\" наверху справа): <a href=\"https://github.com/fastapi/fastapi\" class=\"external-link\" target=\"_blank\">https://github.com/fastapi/fastapi</a>. \n\nЕсли Вы выберете \"Watching\" вместо \"Releases only\", то будете получать уведомления, когда кто-либо создаёт новый вопрос или Issue. Вы также можете указать, что хотите получать уведомления только о новых Issues, или обсуждениях, или пулл-реквестах и т.д.\n\nТогда Вы можете попробовать помочь им с решением этих вопросов.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 15, "header": "Отслеживать репозиторий на GitHub", "header_level": 2, "token_count": 222}
{"id": "517f83aa8fb054a5", "text": "## Задать вопросы { #ask-questions }\n\nВы можете <a href=\"https://github.com/fastapi/fastapi/discussions/new?category=questions\" class=\"external-link\" target=\"_blank\">создать новый вопрос</a> в репозитории GitHub, например:\n\n* Задать **вопрос** или спросить о **проблеме**.\n* Предложить новую **возможность**.\n\n**Заметка**: если Вы это сделаете, то я попрошу Вас также помогать другим. \n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 16, "header": "Задать вопросы", "header_level": 2, "token_count": 139}
{"id": "fe43a23af4d71bb9", "text": "## Проверять пулл-реквесты { #review-pull-requests }\n\nВы можете помочь мне проверять пулл-реквесты других участников.\n\nИ, снова, постарайтесь быть доброжелательными. \n\n---\n\nО том, что нужно иметь в виду и как проверять пулл-реквест:\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 17, "header": "Проверять пулл-реквесты", "header_level": 2, "token_count": 102}
{"id": "f90d4d025bd97f14", "text": "### Понять проблему { #understand-the-problem }\n\n* Во-первых, убедитесь, что **поняли проблему**, которую пулл-реквест пытается решить. Возможно, это обсуждалось более подробно в GitHub Discussion или Issue.\n\n* Также есть вероятность, что пулл-реквест не нужен, так как проблему можно решить **другим путём**. Тогда Вы можете предложить или спросить об этом.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 18, "header": "Понять проблему", "header_level": 3, "token_count": 146}
{"id": "d5660a651afb27ed", "text": "### Не переживайте о стиле { #dont-worry-about-style }\n\n* Не стоит слишком беспокоиться о таких вещах, как стиль сообщений в коммитах — при слиянии я выполню squash и настрою коммит вручную.\n\n* Также не беспокойтесь о правилах стиля, это уже проверяют автоматизированные инструменты.\n\nЕсли будет нужна какая-то другая стилистика или единообразие, я попрошу об этом напрямую или добавлю поверх свои коммиты с нужными изменениями.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 19, "header": "Не переживайте о стиле", "header_level": 3, "token_count": 181}
{"id": "5295cc92da840739", "text": "### Проверить код { #check-the-code }\n\n* Проверьте и прочитайте код, посмотрите, логичен ли он, **запустите его локально** и проверьте, действительно ли он решает проблему.\n\n* Затем оставьте **комментарий**, что Вы это сделали, так я пойму, что Вы действительно проверили код.\n\n/// info | Информация\n\nК сожалению, я не могу просто доверять PR-ам только потому, что у них есть несколько одобрений.\n\nНесколько раз было так, что у PR-ов было 3, 5 или больше одобрений, вероятно из-за привлекательного описания, но когда я их проверял, они оказывались сломанными, содержали баги или вовсе не решали заявленную проблему. \n\nПоэтому очень важно действительно прочитать и запустить код и сообщить мне об этом в комментарии. \n\n///\n\n* Если PR можно упростить, Вы можете попросить об этом, но не нужно быть слишком придирчивым — может быть много субъективных мнений (и у меня тоже ), поэтому лучше сосредоточиться на фундаментальных вещах.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 20, "header": "Проверить код", "header_level": 3, "token_count": 378}
{"id": "cae4ba60ec40fb63", "text": "### Тестировать { #tests }\n\n* Помогите мне проверить, что у PR есть **тесты**.\n\n* Проверьте, что тесты **падают** до PR. \n\n* Затем проверьте, что тесты **проходят** после PR. \n\n* Многие PR не имеют тестов — Вы можете **напомнить** добавить тесты или даже **предложить** некоторые тесты сами. Это одна из самых трудозатратных частей, и здесь Вы можете очень помочь.\n\n* Затем добавьте комментарий, что Вы попробовали, чтобы я знал, что Вы это проверили. \n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 21, "header": "Тестировать", "header_level": 3, "token_count": 188}
{"id": "008dafa30b3fe0f9", "text": "## Создать пулл-реквест { #create-a-pull-request }\n\nВы можете [сделать вклад](contributing.md){.internal-link target=_blank} в исходный код пулл-реквестами, например:\n\n* Исправить опечатку, найденную в документации.\n* Поделиться статьёй, видео или подкастом о FastAPI, которые Вы создали или нашли, <a href=\"https://github.com/fastapi/fastapi/edit/master/docs/en/data/external_links.yml\" class=\"external-link\" target=\"_blank\">изменив этот файл</a>.\n    * Убедитесь, что добавили свою ссылку в начало соответствующего раздела.\n* Помочь с [переводом документации](contributing.md#translations){.internal-link target=_blank} на Ваш язык.\n    * Вы также можете проверять переводы, сделанные другими.\n* Предложить новые разделы документации.\n* Исправить существующую проблему/баг.\n    * Убедитесь, что добавили тесты.\n* Добавить новую возможность.\n    * Убедитесь, что добавили тесты.\n    * Убедитесь, что добавили документацию, если это уместно.\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 22, "header": "Создать пулл-реквест", "header_level": 2, "token_count": 342}
{"id": "d9edc974a0c1d43d", "text": "## Помочь поддерживать FastAPI { #help-maintain-fastapi }\n\nПомогите мне поддерживать **FastAPI**! \n\nПредстоит ещё много работы, и, по большей части, **ВЫ** можете её сделать.\n\nОсновные задачи, которые Вы можете выполнить прямо сейчас:\n\n* [Помочь другим с вопросами на GitHub](#help-others-with-questions-in-github){.internal-link target=_blank} (смотрите секцию выше).\n* [Проверять пулл-реквесты](#review-pull-requests){.internal-link target=_blank} (смотрите секцию выше).\n\nИменно эти две задачи **забирают больше всего времени**. Это основная работа по поддержке FastAPI.\n\nЕсли Вы можете помочь мне с этим, **Вы помогаете поддерживать FastAPI** и делаете так, чтобы он продолжал **развиваться быстрее и лучше**. \n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 23, "header": "Помочь поддерживать FastAPI", "header_level": 2, "token_count": 276}
{"id": "d732ba4be66ef021", "text": "## Подключиться к чату { #join-the-chat }\n\nПодключайтесь к  <a href=\"https://discord.gg/VQjSZaeJmf\" class=\"external-link\" target=\"_blank\">серверу чата в Discord</a>  и общайтесь с другими участниками сообщества FastAPI.\n\n/// tip | Подсказка\n\nПо вопросам — задавайте их в <a href=\"https://github.com/fastapi/fastapi/discussions/new?category=questions\" class=\"external-link\" target=\"_blank\">GitHub Discussions</a>, так гораздо выше шанс, что Вы получите помощь от [Экспертов FastAPI](fastapi-people.md#fastapi-experts){.internal-link target=_blank}.\n\nИспользуйте чат только для прочих общих бесед.\n\n///\n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 24, "header": "Подключиться к чату", "header_level": 2, "token_count": 208}
{"id": "3256eacc38be41ca", "text": "### Не используйте чат для вопросов { #dont-use-the-chat-for-questions }\n\nИмейте в виду, что в чатах, благодаря \"свободному общению\", легко задать вопросы, которые слишком общие и на которые сложнее ответить, поэтому Вы можете не получить ответы.\n\nНа GitHub шаблон поможет Вам правильно сформулировать вопрос, чтобы Вам было легче получить хороший ответ или даже решить проблему самостоятельно ещё до того, как спросите. И на GitHub я могу следить за тем, чтобы всегда отвечать на всё, даже если это занимает время. А с чатами я не могу сделать этого лично. \n\nКроме того, переписка в чатах хуже ищется, чем на GitHub, поэтому вопросы и ответы могут теряться среди остальных сообщений. И только те, что на GitHub, учитываются для получения лычки [Эксперт FastAPI](fastapi-people.md#fastapi-experts){.internal-link target=_blank}, так что вероятнее всего Вы получите больше внимания именно на GitHub.\n\nС другой стороны, в чатах тысячи пользователей, так что почти всегда есть шанс найти там кого-то для разговора. \n\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 25, "header": "Не используйте чат для вопросов", "header_level": 3, "token_count": 402}
{"id": "766ee5296ea4634c", "text": "## Спонсировать автора { #sponsor-the-author }\n\nЕсли Ваш **продукт/компания** зависят от **FastAPI** или связаны с ним и Вы хотите донести до пользователей информацию о себе, Вы можете спонсировать автора (меня) через <a href=\"https://github.com/sponsors/tiangolo\" class=\"external-link\" target=\"_blank\">GitHub Sponsors</a>. В зависимости от уровня поддержки Вы можете получить дополнительные бонусы, например, бейдж в документации. \n\n---\n\nСпасибо!\n", "metadata": {"title": "Помочь FastAPI - Получить помощь", "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "source_mtime": "2026-01-12T17:48:12.883481+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\help-fastapi.md"}, "doc_id": "53d97414f637", "source_path": "docs\\help-fastapi.md", "title": "Помочь FastAPI - Получить помощь", "chunk_index": 26, "header": "Спонсировать автора", "header_level": 2, "token_count": 164}
{"id": "a25cba9f9adf896b", "text": "# История, проектирование и будущее { #history-design-and-future }\n\nОднажды, <a href=\"https://github.com/fastapi/fastapi/issues/3#issuecomment-454956920\" class=\"external-link\" target=\"_blank\">один из пользователей **FastAPI** задал вопрос</a>:\n\n> Какова история этого проекта? Создаётся впечатление, что он явился из ниоткуда и завоевал мир за несколько недель [...]\n\nЧто ж, вот небольшая часть истории проекта.\n\n", "metadata": {"title": "История, проектирование и будущее", "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "source_mtime": "2026-01-12T17:48:12.890110+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\history-design-future.md"}, "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "title": "История, проектирование и будущее", "chunk_index": 0, "header": "История, проектирование и будущее", "header_level": 1, "token_count": 154}
{"id": "e9dbc1bccfc03aae", "text": "## Альтернативы { #alternatives }\n\nВ течение нескольких лет я, возглавляя различные команды разработчиков, создавал довольно сложные API для машинного обучения, распределённых систем, асинхронных задач, баз данных NoSQL и т.д.\n\nВ рамках работы над этими проектами я исследовал, проверял и использовал многие фреймворки.\n\nВо многом история **FastAPI** - история его предшественников.\n\nКак написано в разделе [Альтернативы](alternatives.md){.internal-link target=_blank}:\n\n<blockquote markdown=\"1\">\n\n**FastAPI** не существовал бы, если б не было более ранних работ других людей.\n\nОни создали большое количество инструментов, которые и вдохновили меня на создание **FastAPI**.\n\nЯ всячески избегал создания нового фреймворка в течение нескольких лет. Сначала я пытался собрать все нужные возможности, которые ныне есть в **FastAPI**, используя множество различных фреймворков, плагинов и инструментов.\n\nНо в какой-то момент не осталось другого выбора, кроме как создать что-то, что предоставляло бы все эти возможности сразу. Взять самые лучшие идеи из предыдущих инструментов и, используя введённые в Python аннотации типов (которых не было до версии 3.6), объединить их.\n\n</blockquote>\n\n", "metadata": {"title": "История, проектирование и будущее", "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "source_mtime": "2026-01-12T17:48:12.890110+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\history-design-future.md"}, "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "title": "История, проектирование и будущее", "chunk_index": 1, "header": "Альтернативы", "header_level": 2, "token_count": 469}
{"id": "2561562851916ac7", "text": "## Исследования { #investigation }\n\nБлагодаря опыту использования существующих альтернатив, мы с коллегами изучили их основные идеи и скомбинировали собранные знания наилучшим образом.\n\nНапример, стало ясно, что необходимо брать за основу стандартные аннотации типов Python.\n\nТакже наилучшим подходом является использование уже существующих стандартов.\n\nИтак, прежде чем приступить к написанию **FastAPI**, я потратил несколько месяцев на изучение OpenAPI, JSON Schema, OAuth2, и т.п. для понимания их взаимосвязей, совпадений и различий.\n\n", "metadata": {"title": "История, проектирование и будущее", "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "source_mtime": "2026-01-12T17:48:12.890110+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\history-design-future.md"}, "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "title": "История, проектирование и будущее", "chunk_index": 2, "header": "Исследования", "header_level": 2, "token_count": 216}
{"id": "1e09d73fbdd85160", "text": "## Проектирование { #design }\n\nЗатем я потратил некоторое время на придумывание \"API\" разработчика, который я хотел иметь как пользователь (как разработчик, использующий FastAPI).\n\nЯ проверил несколько идей на самых популярных редакторах кода: PyCharm, VS Code, редакторы на базе Jedi.\n\nДанные по редакторам я взял из <a href=\"https://www.jetbrains.com/research/python-developers-survey-2018/#development-tools\" class=\"external-link\" target=\"_blank\">опроса Python-разработчиков</a>, который охватывает около 80% пользователей.\n\nЭто означает, что **FastAPI** был специально проверен на редакторах, используемых 80% Python-разработчиками. И поскольку большинство других редакторов, как правило, работают аналогичным образом, все его преимущества должны работать практически для всех редакторов.\n\nТаким образом, я смог найти наилучшие способы сократить дублирование кода, обеспечить повсеместное автозавершение, проверку типов и ошибок и т.д.\n\nИ все это, чтобы все пользователи могли получать наилучший опыт разработки.\n\n", "metadata": {"title": "История, проектирование и будущее", "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "source_mtime": "2026-01-12T17:48:12.890110+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\history-design-future.md"}, "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "title": "История, проектирование и будущее", "chunk_index": 3, "header": "Проектирование", "header_level": 2, "token_count": 372}
{"id": "3bebbd1e404abb82", "text": "## Зависимости { #requirements }\n\nПротестировав несколько вариантов, я решил, что в качестве основы буду использовать <a href=\"https://docs.pydantic.dev/\" class=\"external-link\" target=\"_blank\">**Pydantic**</a> и его преимущества.\n\nПо моим предложениям был изменён код этого фреймворка, чтобы сделать его полностью совместимым с JSON Schema, поддержать различные способы определения ограничений и улучшить поддержку в редакторах кода (проверки типов, автозавершение) на основе тестов в нескольких редакторах.\n\nВ то же время, я принимал участие в разработке <a href=\"https://www.starlette.dev/\" class=\"external-link\" target=\"_blank\">**Starlette**</a>, ещё один из основных компонентов FastAPI.\n\n", "metadata": {"title": "История, проектирование и будущее", "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "source_mtime": "2026-01-12T17:48:12.890110+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\history-design-future.md"}, "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "title": "История, проектирование и будущее", "chunk_index": 4, "header": "Зависимости", "header_level": 2, "token_count": 258}
{"id": "c4de38aa31e1b449", "text": "## Разработка { #development }\n\nК тому времени, когда я начал создавать **FastAPI**, большинство необходимых деталей уже существовало, дизайн был определён, зависимости и прочие инструменты были готовы, а знания о стандартах и спецификациях были четкими и свежими.\n\n", "metadata": {"title": "История, проектирование и будущее", "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "source_mtime": "2026-01-12T17:48:12.890110+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\history-design-future.md"}, "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "title": "История, проектирование и будущее", "chunk_index": 5, "header": "Разработка", "header_level": 2, "token_count": 109}
{"id": "a79a39929db986d6", "text": "## Будущее { #future }\n\nСейчас уже ясно, что **FastAPI** со своими идеями стал полезен многим людям.\n\nПри сравнении с альтернативами, выбор падает на него, поскольку он лучше подходит для множества вариантов использования.\n\nМногие разработчики и команды уже используют **FastAPI** в своих проектах (включая меня и мою команду).\n\nНо, тем не менее, грядёт добавление ещё многих улучшений и возможностей.\n\nУ **FastAPI** великое будущее.\n\nИ [ваш вклад в это](help-fastapi.md){.internal-link target=_blank} - очень ценнен.\n", "metadata": {"title": "История, проектирование и будущее", "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "source_mtime": "2026-01-12T17:48:12.890110+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\history-design-future.md"}, "doc_id": "3ba9f30d9c7e", "source_path": "docs\\history-design-future.md", "title": "История, проектирование и будущее", "chunk_index": 6, "header": "Будущее", "header_level": 2, "token_count": 217}
{"id": "1900cf3ecc101b4c", "text": "# FastAPI { #fastapi }\n\n<style>\n.md-content .md-typeset h1 { display: none; }\n</style>\n\n<p align=\"center\">\n  <a href=\"https://fastapi.tiangolo.com\"><img src=\"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" alt=\"FastAPI\"></a>\n</p>\n<p align=\"center\">\n    <em>Фреймворк FastAPI: высокая производительность, прост в изучении, быстрый в разработке, готов к продакшн</em>\n</p>\n<p align=\"center\">\n<a href=\"https://github.com/fastapi/fastapi/actions?query=workflow%3ATest+event%3Apush+branch%3Amaster\" target=\"_blank\">\n    <img src=\"https://github.com/fastapi/fastapi/actions/workflows/test.yml/badge.svg?event=push&branch=master\" alt=\"Тест\">\n</a>\n<a href=\"https://coverage-badge.samuelcolvin.workers.dev/redirect/fastapi/fastapi\" target=\"_blank\">\n    <img src=\"https://coverage-badge.samuelcolvin.workers.dev/fastapi/fastapi.svg\" alt=\"Покрытие\">\n</a>\n<a href=\"https://pypi.org/project/fastapi\" target=\"_blank\">\n    <img src=\"https://img.shields.io/pypi/v/fastapi?color=%2334D058&label=pypi%20package\" alt=\"Версия пакета\">\n</a>\n<a href=\"https://pypi.org/project/fastapi\" target=\"_blank\">\n    <img src=\"https://img.shields.io/pypi/pyversions/fastapi.svg?color=%2334D058\" alt=\"Поддерживаемые версии Python\">\n</a>\n</p>\n\n---\n\n**Документация**: <a href=\"https://fastapi.tiangolo.com/ru\" target=\"_blank\">https://fastapi.tiangolo.com</a>\n\n**Исходный код**: <a href=\"https://github.com/fastapi/fastapi\" target=\"_blank\">https://github.com/fastapi/fastapi</a>\n\n---", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "FastAPI", "section_header_level": 1}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 0, "header": "FastAPI", "header_level": 1, "token_count": 466}
{"id": "d7202fa05c28e8a2", "text": "href=\"https://fastapi.tiangolo.com/ru\" target=\"_blank\">https://fastapi.tiangolo.com</a>\n\n**Исходный код**: <a href=\"https://github.com/fastapi/fastapi\" target=\"_blank\">https://github.com/fastapi/fastapi</a>\n\n---\n\nFastAPI — это современный, быстрый (высокопроизводительный) веб-фреймворк для создания API на Python, основанный на стандартных аннотациях типов Python.\n\nКлючевые особенности:", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "FastAPI", "section_header_level": 1}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 1, "header": "FastAPI", "header_level": 1, "token_count": 135}
{"id": "f682d43091f0f456", "text": "енный, быстрый (высокопроизводительный) веб-фреймворк для создания API на Python, основанный на стандартных аннотациях типов Python.\n\nКлючевые особенности:\n\n* **Скорость**: Очень высокая производительность, на уровне **NodeJS** и **Go** (благодаря Starlette и Pydantic). [Один из самых быстрых доступных фреймворков Python](#performance).\n* **Быстрота разработки**: Увеличьте скорость разработки фич примерно на 200–300%. *\n* **Меньше ошибок**: Сократите примерно на 40% количество ошибок, вызванных человеком (разработчиком). *\n* **Интуитивность**: Отличная поддержка редактора кода. <abbr title=\"также известное как: автодополнение, IntelliSense\">Автозавершение</abbr> везде. Меньше времени на отладку.\n* **Простота**: Разработан так, чтобы его было легко использовать и осваивать. Меньше времени на чтение документации.\n* **Краткость**: Минимизируйте дублирование кода. Несколько возможностей из каждого объявления параметров. Меньше ошибок.\n* **Надежность**: Получите код, готовый к продакшн. С автоматической интерактивной документацией.\n* **На основе стандартов**: Основан на открытых стандартах API и полностью совместим с ними: <a href=\"https://github.com/OAI/OpenAPI-Specification\" class=\"external-link\" target=\"_blank\">OpenAPI</a> (ранее известный как Swagger) и <a href=\"https://json-schema.org/\" class=\"external-link\" target=\"_blank\">JSON Schema</a>.", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "FastAPI", "section_header_level": 1}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 2, "header": "FastAPI", "header_level": 1, "token_count": 511}
{"id": "a4c5b76d05a34be4", "text": "a href=\"https://github.com/OAI/OpenAPI-Specification\" class=\"external-link\" target=\"_blank\">OpenAPI</a> (ранее известный как Swagger) и <a href=\"https://json-schema.org/\" class=\"external-link\" target=\"_blank\">JSON Schema</a>.\n\n<small>* оценка на основе тестов внутренней команды разработчиков, создающих продакшн-приложения.</small>", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "FastAPI", "section_header_level": 1}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 3, "header": "FastAPI", "header_level": 1, "token_count": 109}
{"id": "4bfd2e2135d56297", "text": "## Спонсоры { #sponsors }\n\n<!-- sponsors -->\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 4, "header": "Спонсоры", "header_level": 2, "token_count": 15}
{"id": "acf7344f35b3000d", "text": "### Ключевой-спонсор { #keystone-sponsor }\n\n{% for sponsor in sponsors.keystone -%}\n<a href=\"{{ sponsor.url }}\" target=\"_blank\" title=\"{{ sponsor.title }}\"><img src=\"{{ sponsor.img }}\" style=\"border-radius:15px\"></a>\n{% endfor -%}\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 5, "header": "Ключевой-спонсор", "header_level": 3, "token_count": 64}
{"id": "acace34fc412931f", "text": "### Золотые и серебряные спонсоры { #gold-and-silver-sponsors }\n\n{% for sponsor in sponsors.gold -%}\n<a href=\"{{ sponsor.url }}\" target=\"_blank\" title=\"{{ sponsor.title }}\"><img src=\"{{ sponsor.img }}\" style=\"border-radius:15px\"></a>\n{% endfor -%}\n{%- for sponsor in sponsors.silver -%}\n<a href=\"{{ sponsor.url }}\" target=\"_blank\" title=\"{{ sponsor.title }}\"><img src=\"{{ sponsor.img }}\" style=\"border-radius:15px\"></a>\n{% endfor %}\n\n<!-- /sponsors -->\n\n<a href=\"https://fastapi.tiangolo.com/ru/fastapi-people/#sponsors\" class=\"external-link\" target=\"_blank\">Другие спонсоры</a>\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 6, "header": "Золотые и серебряные спонсоры", "header_level": 3, "token_count": 164}
{"id": "1900cf3ecc101b4c", "text": "## Мнения { #opinions }\n\n\"_[...] В последнее время я много где использую **FastAPI**. [...] На самом деле я планирую использовать его для всех **ML-сервисов моей команды в Microsoft**. Некоторые из них интегрируются в основной продукт **Windows**, а некоторые — в продукты **Office**._\"\n\n<div style=\"text-align: right; margin-right: 10%;\">Kabir Khan - <strong>Microsoft</strong> <a href=\"https://github.com/fastapi/fastapi/pull/26\" target=\"_blank\"><small>(ref)</small></a></div>\n\n---\n\n\"_Мы начали использовать библиотеку **FastAPI**, чтобы поднять **REST**-сервер, к которому можно обращаться за **предсказаниями**. [для Ludwig]_\"\n\n<div style=\"text-align: right; margin-right: 10%;\">Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala - <strong>Uber</strong> <a href=\"https://eng.uber.com/ludwig-v0-2/\" target=\"_blank\"><small>(ref)</small></a></div>\n\n---\n\n\"_**Netflix** рада объявить об открытом релизе нашего фреймворка оркестрации **антикризисного управления**: **Dispatch**! [создан с помощью **FastAPI**]_\"\n\n<div style=\"text-align: right; margin-right: 10%;\">Kevin Glisson, Marc Vilanova, Forest Monsen - <strong>Netflix</strong> <a href=\"https://netflixtechblog.com/introducing-dispatch-da4b8a2a8072\" target=\"_blank\"><small>(ref)</small></a></div>\n\n---\n\n\"_Я в полном восторге от **FastAPI**. Это так весело!_\"", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "Мнения", "section_header_level": 2}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 7, "header": "Мнения", "header_level": 2, "token_count": 455}
{"id": "d7202fa05c28e8a2", "text": "href=\"https://netflixtechblog.com/introducing-dispatch-da4b8a2a8072\" target=\"_blank\"><small>(ref)</small></a></div>\n\n---\n\n\"_Я в полном восторге от **FastAPI**. Это так весело!_\"\n\n<div style=\"text-align: right; margin-right: 10%;\">Brian Okken - <strong>Ведущий подкаста <a href=\"https://pythonbytes.fm/episodes/show/123/time-to-right-the-py-wrongs?time_in_sec=855\" target=\"_blank\">Python Bytes</a></strong> <a href=\"https://x.com/brianokken/status/1112220079972728832\" target=\"_blank\"><small>(ref)</small></a></div>\n\n---\n\n\"_Честно говоря, то, что вы создали, выглядит очень солидно и отполировано. Во многих смыслах это то, чем я хотел видеть **Hug** — очень вдохновляет видеть, как кто-то это создал._\"\n\n<div style=\"text-align: right; margin-right: 10%;\">Timothy Crosley - <strong>Создатель <a href=\"https://github.com/hugapi/hug\" target=\"_blank\">Hug</a></strong> <a href=\"https://news.ycombinator.com/item?id=19455465\" target=\"_blank\"><small>(ref)</small></a></div>\n\n---\n\n\"_Если вы хотите изучить один **современный фреймворк** для создания REST API, посмотрите **FastAPI** [...] Он быстрый, простой в использовании и лёгкий в изучении [...]_\"\n\n\"_Мы переключились на **FastAPI** для наших **API** [...] Думаю, вам тоже понравится [...]_\"", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "Мнения", "section_header_level": 2}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 8, "header": "Мнения", "header_level": 2, "token_count": 449}
{"id": "f682d43091f0f456", "text": "быстрый, простой в использовании и лёгкий в изучении [...]_\"\n\n\"_Мы переключились на **FastAPI** для наших **API** [...] Думаю, вам тоже понравится [...]_\"\n\n<div style=\"text-align: right; margin-right: 10%;\">Ines Montani - Matthew Honnibal - <strong>Основатели <a href=\"https://explosion.ai\" target=\"_blank\">Explosion AI</a> — создатели <a href=\"https://spacy.io\" target=\"_blank\">spaCy</a></strong> <a href=\"https://x.com/_inesmontani/status/1144173225322143744\" target=\"_blank\"><small>(ref)</small></a> - <a href=\"https://x.com/honnibal/status/1144031421859655680\" target=\"_blank\"><small>(ref)</small></a></div>\n\n---\n\n\"_Если кто-то собирается делать продакшн-API на Python, я настоятельно рекомендую **FastAPI**. Он **прекрасно спроектирован**, **прост в использовании** и **отлично масштабируется**, стал **ключевым компонентом** нашей стратегии API-first и приводит в действие множество автоматизаций и сервисов, таких как наш Virtual TAC Engineer._\"\n\n<div style=\"text-align: right; margin-right: 10%;\">Deon Pillsbury - <strong>Cisco</strong> <a href=\"https://www.linkedin.com/posts/deonpillsbury_cisco-cx-python-activity-6963242628536487936-trAp/\" target=\"_blank\"><small>(ref)</small></a></div>\n\n---", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "Мнения", "section_header_level": 2}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 9, "header": "Мнения", "header_level": 2, "token_count": 422}
{"id": "6e38bbb3ad5c7f1e", "text": "## **Typer**, FastAPI для CLI { #typer-the-fastapi-of-clis }\n\n<a href=\"https://typer.tiangolo.com\" target=\"_blank\"><img src=\"https://typer.tiangolo.com/img/logo-margin/logo-margin-vector.svg\" style=\"width: 20%;\"></a>\n\nЕсли вы создаёте приложение <abbr title=\"Command Line Interface – Интерфейс командной строки\">CLI</abbr> для использования в терминале вместо веб-API, посмотрите <a href=\"https://typer.tiangolo.com/\" class=\"external-link\" target=\"_blank\">**Typer**</a>.\n\n**Typer** — младший брат FastAPI. И он задуман как **FastAPI для CLI**. ⌨️ 🚀\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 10, "header": "**Typer**, FastAPI для CLI", "header_level": 2, "token_count": 183}
{"id": "f63f374e523043a4", "text": "## Зависимости { #requirements }\n\nFastAPI стоит на плечах гигантов:\n\n* <a href=\"https://www.starlette.dev/\" class=\"external-link\" target=\"_blank\">Starlette</a> для части, связанной с вебом.\n* <a href=\"https://docs.pydantic.dev/\" class=\"external-link\" target=\"_blank\">Pydantic</a> для части, связанной с данными.\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 11, "header": "Зависимости", "header_level": 2, "token_count": 108}
{"id": "7a1aabf335a3ada0", "text": "## Установка { #installation }\n\nСоздайте и активируйте <a href=\"https://fastapi.tiangolo.com/ru/virtual-environments/\" class=\"external-link\" target=\"_blank\">виртуальное окружение</a>, затем установите FastAPI:\n\n<div class=\"termy\">\n\n```console\n$ pip install \"fastapi[standard]\"\n\n---> 100%\n```\n\n</div>\n\n**Примечание**: Обязательно заключите `\"fastapi[standard]\"` в кавычки, чтобы это работало во всех терминалах.\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 12, "header": "Установка", "header_level": 2, "token_count": 139}
{"id": "7166d4b48b0bf1d1", "text": "## Пример { #example }\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 13, "header": "Пример", "header_level": 2, "token_count": 7}
{"id": "82ffb0a61f1a7428", "text": "### Создание { #create-it }\n\nСоздайте файл `main.py` со следующим содержимым:\n\n```Python\nfrom typing import Union\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: Union[str, None] = None):\n    return {\"item_id\": item_id, \"q\": q}\n```\n\n<details markdown=\"1\">\n<summary>Или используйте <code>async def</code>...</summary>\n\nЕсли ваш код использует `async` / `await`, используйте `async def`:\n\n```Python hl_lines=\"9  14\"\nfrom typing import Union\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/\")\nasync def read_root():\n    return {\"Hello\": \"World\"}\n\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int, q: Union[str, None] = None):\n    return {\"item_id\": item_id, \"q\": q}\n```\n\n**Примечание**:\n\nЕсли не уверены, посмотрите раздел _«Нет времени?»_ о <a href=\"https://fastapi.tiangolo.com/ru/async/#in-a-hurry\" target=\"_blank\">`async` и `await` в документации</a>.\n\n</details>\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 14, "header": "Создание", "header_level": 3, "token_count": 310}
{"id": "2360f722b740c9eb", "text": "### Запуск { #run-it }\n\nЗапустите сервер командой:\n\n<div class=\"termy\">\n\n```console\n$ fastapi dev main.py\n\n ╭────────── FastAPI CLI - Development mode ───────────╮\n │                                                     │\n │  Serving at: http://127.0.0.1:8000                  │\n │                                                     │\n │  API docs: http://127.0.0.1:8000/docs               │\n │                                                     │\n │  Running in development mode, for production use:   │\n │                                                     │\n │  fastapi run                                        │\n │                                                     │\n ╰─────────────────────────────────────────────────────╯\n\nINFO:     Will watch for changes in these directories: ['/home/user/code/awesomeapp']\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [2248755] using WatchFiles\nINFO:     Started server process [2248757]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n```\n\n</div>\n\n<details markdown=\"1\">\n<summary>О команде <code>fastapi dev main.py</code>...</summary>\n\nКоманда `fastapi dev` читает ваш файл `main.py`, находит в нём приложение **FastAPI** и запускает сервер с помощью <a href=\"https://www.uvicorn.dev\" class=\"external-link\" target=\"_blank\">Uvicorn</a>.\n\nПо умолчанию `fastapi dev` запускается с включённой авто-перезагрузкой для локальной разработки.\n\nПодробнее в <a href=\"https://fastapi.tiangolo.com/ru/fastapi-cli/\" target=\"_blank\">документации по FastAPI CLI</a>.\n\n</details>\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 15, "header": "Запуск", "header_level": 3, "token_count": 420}
{"id": "06ade7bd50bdff7b", "text": "### Проверка { #check-it }\n\nОткройте браузер на <a href=\"http://127.0.0.1:8000/items/5?q=somequery\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/items/5?q=somequery</a>.\n\nВы увидите JSON-ответ:\n\n```JSON\n{\"item_id\": 5, \"q\": \"somequery\"}\n```\n\nВы уже создали API, который:\n\n* Получает HTTP-запросы по _путям_ `/` и `/items/{item_id}`.\n* Оба _пути_ используют `GET` <em>операции</em> (также известные как HTTP _методы_).\n* _Путь_ `/items/{item_id}` имеет _параметр пути_ `item_id`, который должен быть `int`.\n* _Путь_ `/items/{item_id}` имеет необязательный `str` _параметр запроса_ `q`.\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 16, "header": "Проверка", "header_level": 3, "token_count": 242}
{"id": "45be2f80495da5d4", "text": "### Интерактивная документация API { #interactive-api-docs }\n\nПерейдите на <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a>.\n\nВы увидите автоматическую интерактивную документацию API (предоставлена <a href=\"https://github.com/swagger-api/swagger-ui\" class=\"external-link\" target=\"_blank\">Swagger UI</a>):\n\n![Swagger UI](https://fastapi.tiangolo.com/img/index/index-01-swagger-ui-simple.png)\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 17, "header": "Интерактивная документация API", "header_level": 3, "token_count": 144}
{"id": "8798f20f052a9e96", "text": "### Альтернативная документация API { #alternative-api-docs }\n\nТеперь откройте <a href=\"http://127.0.0.1:8000/redoc\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/redoc</a>.\n\nВы увидите альтернативную автоматическую документацию (предоставлена <a href=\"https://github.com/Rebilly/ReDoc\" class=\"external-link\" target=\"_blank\">ReDoc</a>):\n\n![ReDoc](https://fastapi.tiangolo.com/img/index/index-02-redoc-simple.png)\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 18, "header": "Альтернативная документация API", "header_level": 3, "token_count": 155}
{"id": "878f3dbff820ab29", "text": "## Пример обновления { #example-upgrade }\n\nТеперь измените файл `main.py`, чтобы принимать тело запроса из `PUT` запроса.\n\nОбъявите тело, используя стандартные типы Python, спасибо Pydantic.\n\n```Python hl_lines=\"4  9-12  25-27\"\nfrom typing import Union\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    is_offer: Union[bool, None] = None\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: Union[str, None] = None):\n    return {\"item_id\": item_id, \"q\": q}\n\n\n@app.put(\"/items/{item_id}\")\ndef update_item(item_id: int, item: Item):\n    return {\"item_name\": item.name, \"item_id\": item_id}\n```\n\nСервер `fastapi dev` должен перезагрузиться автоматически.\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 19, "header": "Пример обновления", "header_level": 2, "token_count": 254}
{"id": "1706fecd872f5aeb", "text": "### Обновление интерактивной документации API { #interactive-api-docs-upgrade }\n\nПерейдите на <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a>.\n\n* Интерактивная документация API будет автоматически обновлена, включая новое тело:\n\n![Swagger UI](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)\n\n* Нажмите кнопку «Try it out», это позволит вам заполнить параметры и напрямую взаимодействовать с API:\n\n![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-04-swagger-03.png)\n\n* Затем нажмите кнопку «Execute», интерфейс свяжется с вашим API, отправит параметры, получит результаты и отобразит их на экране:\n\n![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-05-swagger-04.png)\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 20, "header": "Обновление интерактивной документации API", "header_level": 3, "token_count": 259}
{"id": "9b01c2f0d39f124d", "text": "### Обновление альтернативной документации API { #alternative-api-docs-upgrade }\n\nТеперь откройте <a href=\"http://127.0.0.1:8000/redoc\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/redoc</a>.\n\n* Альтернативная документация также отразит новый параметр запроса и тело:\n\n![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 21, "header": "Обновление альтернативной документации API", "header_level": 3, "token_count": 128}
{"id": "1900cf3ecc101b4c", "text": "### Подведём итоги { #recap }\n\nИтак, вы объявляете **один раз** типы параметров, тела запроса и т.д. как параметры функции.\n\nВы делаете это с помощью стандартных современных типов Python.\n\nВам не нужно изучать новый синтаксис, методы или классы конкретной библиотеки и т.п.\n\nТолько стандартный **Python**.\n\nНапример, для `int`:\n\n```Python\nitem_id: int\n```\n\nили для более сложной модели `Item`:\n\n```Python\nitem: Item\n```\n\n...и с этим единственным объявлением вы получаете:", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "Подведём итоги", "section_header_level": 3}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 22, "header": "Подведём итоги", "header_level": 3, "token_count": 188}
{"id": "d7202fa05c28e8a2", "text": "ример, для `int`:\n\n```Python\nitem_id: int\n```\n\nили для более сложной модели `Item`:\n\n```Python\nitem: Item\n```\n\n...и с этим единственным объявлением вы получаете:\n\n* Поддержку редактора кода, включая:\n    * Автозавершение.\n    * Проверку типов.\n* Валидацию данных:\n    * Автоматические и понятные ошибки, когда данные некорректны.\n    * Валидацию даже для глубоко вложенных объектов JSON.\n* <abbr title=\"также известное как: сериализация, парсинг, маршалинг\">Преобразование</abbr> входных данных: из сети в данные и типы Python. Чтение из:\n    * JSON.\n    * Параметров пути.\n    * Параметров запроса.\n    * Cookies.\n    * HTTP-заголовков.\n    * Форм.\n    * Файлов.\n* <abbr title=\"также известное как: сериализация, парсинг, маршалинг\">Преобразование</abbr> выходных данных: из данных и типов Python в данные сети (например, JSON):\n    * Преобразование типов Python (`str`, `int`, `float`, `bool`, `list` и т.д.).\n    * Объекты `datetime`.\n    * Объекты `UUID`.\n    * Модели баз данных.\n    * ...и многое другое.\n* Автоматическую интерактивную документацию API, включая 2 альтернативных интерфейса:\n    * Swagger UI.\n    * ReDoc.\n\n---\n\nВозвращаясь к предыдущему примеру кода, **FastAPI** будет:", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "Подведём итоги", "section_header_level": 3}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 23, "header": "Подведём итоги", "header_level": 3, "token_count": 471}
{"id": "f682d43091f0f456", "text": "ую интерактивную документацию API, включая 2 альтернативных интерфейса:\n    * Swagger UI.\n    * ReDoc.\n\n---\n\nВозвращаясь к предыдущему примеру кода, **FastAPI** будет:\n\n* Валидировать наличие `item_id` в пути для `GET` и `PUT` запросов.\n* Валидировать, что `item_id` имеет тип `int` для `GET` и `PUT` запросов.\n    * Если это не так, клиент увидит полезную понятную ошибку.\n* Проверять, есть ли необязательный параметр запроса с именем `q` (например, `http://127.0.0.1:8000/items/foo?q=somequery`) для `GET` запросов.\n    * Поскольку параметр `q` объявлен с `= None`, он необязателен.\n    * Без `None` он был бы обязательным (как тело запроса в случае с `PUT`).\n* Для `PUT` запросов к `/items/{item_id}` читать тело запроса как JSON:\n    * Проверять, что есть обязательный атрибут `name`, который должен быть `str`.\n    * Проверять, что есть обязательный атрибут `price`, который должен быть `float`.\n    * Проверять, что есть необязательный атрибут `is_offer`, который должен быть `bool`, если он присутствует.\n    * Всё это также будет работать для глубоко вложенных объектов JSON.\n* Автоматически преобразовывать из и в JSON.\n* Документировать всё с помощью OpenAPI, что может быть использовано:\n    * Системами интерактивной документации.\n    * Системами автоматической генерации клиентского кода для многих языков.\n* Предоставлять 2 веб-интерфейса интерактивной документации напрямую.", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "Подведём итоги", "section_header_level": 3}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 24, "header": "Подведём итоги", "header_level": 3, "token_count": 520}
{"id": "a4c5b76d05a34be4", "text": "ации.\n    * Системами автоматической генерации клиентского кода для многих языков.\n* Предоставлять 2 веб-интерфейса интерактивной документации напрямую.\n\n---\n\nМы только поверхностно ознакомились, но вы уже понимаете, как всё это работает.\n\nПопробуйте изменить строку:\n\n```Python\n    return {\"item_name\": item.name, \"item_id\": item_id}\n```\n\n...из:\n\n```Python\n        ... \"item_name\": item.name ...\n```\n\n...на:\n\n```Python\n        ... \"item_price\": item.price ...\n```\n\n...и посмотрите, как ваш редактор кода будет автоматически дополнять атрибуты и знать их типы:\n\n![editor support](https://fastapi.tiangolo.com/img/vscode-completion.png)\n\nБолее полный пример с дополнительными возможностями см. в <a href=\"https://fastapi.tiangolo.com/ru/tutorial/\">Учебник - Руководство пользователя</a>.\n\n**Осторожно, спойлер**: учебник - руководство включает:", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "Подведём итоги", "section_header_level": 3}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 25, "header": "Подведём итоги", "header_level": 3, "token_count": 309}
{"id": "4bfd2e2135d56297", "text": "ями см. в <a href=\"https://fastapi.tiangolo.com/ru/tutorial/\">Учебник - Руководство пользователя</a>.\n\n**Осторожно, спойлер**: учебник - руководство включает:\n\n* Объявление **параметров** из других источников: **HTTP-заголовки**, **cookies**, **поля формы** и **файлы**.\n* Как задать **ограничения валидации** вроде `maximum_length` или `regex`.\n* Очень мощную и простую в использовании систему **<abbr title=\"также известная как: компоненты, ресурсы, провайдеры, сервисы, инъекции\">внедрения зависимостей</abbr>**.\n* Безопасность и аутентификацию, включая поддержку **OAuth2** с **JWT токенами** и **HTTP Basic** аутентификацию.\n* Более продвинутые (но столь же простые) приёмы объявления **глубоко вложенных JSON-моделей** (спасибо Pydantic).\n* Интеграцию **GraphQL** с <a href=\"https://strawberry.rocks\" class=\"external-link\" target=\"_blank\">Strawberry</a> и другими библиотеками.\n* Множество дополнительных функций (благодаря Starlette), таких как:\n    * **WebSockets**\n    * чрезвычайно простые тесты на основе HTTPX и `pytest`\n    * **CORS**\n    * **сессии с использованием cookie**\n    * ...и многое другое.", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "Подведём итоги", "section_header_level": 3}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 26, "header": "Подведём итоги", "header_level": 3, "token_count": 447}
{"id": "1900cf3ecc101b4c", "text": "### Разверните приложение (опционально) { #deploy-your-app-optional }\n\nПри желании вы можете развернуть своё приложение FastAPI в <a href=\"https://fastapicloud.com\" class=\"external-link\" target=\"_blank\">FastAPI Cloud</a>, присоединяйтесь к списку ожидания, если ещё не сделали этого. \n\nЕсли у вас уже есть аккаунт **FastAPI Cloud** (мы пригласили вас из списка ожидания ), вы можете развернуть ваше приложение одной командой.\n\nПеред развертыванием убедитесь, что вы вошли в систему:\n\n<div class=\"termy\">\n\n```console\n$ fastapi login\n\nYou are logged in to FastAPI Cloud 🚀\n```\n\n</div>\n\nЗатем разверните приложение:\n\n<div class=\"termy\">\n\n```console\n$ fastapi deploy\n\nDeploying to FastAPI Cloud...\n\n✅ Deployment successful!\n\n🐔 Ready the chicken! Your app is ready at https://myapp.fastapicloud.dev\n```\n\n</div>\n\nВот и всё! Теперь вы можете открыть ваше приложение по этой ссылке. \n\n#### О FastAPI Cloud { #about-fastapi-cloud }\n\n**<a href=\"https://fastapicloud.com\" class=\"external-link\" target=\"_blank\">FastAPI Cloud</a>** создан тем же автором и командой, что и **FastAPI**.\n\nОн упрощает процесс **создания образа**, **развертывания** и **доступа** к API при минимальных усилиях.\n\nОн переносит тот же **опыт разработчика**, что и при создании приложений на FastAPI, на их **развертывание** в облаке. \n\nFastAPI Cloud — основной спонсор и источник финансирования для проектов с открытым исходным кодом из экосистемы *FastAPI and friends*.", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "Разверните приложение (опционально)", "section_header_level": 3}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 27, "header": "Разверните приложение (опционально)", "header_level": 3, "token_count": 506}
{"id": "d7202fa05c28e8a2", "text": "**развертывание** в облаке. \n\nFastAPI Cloud — основной спонсор и источник финансирования для проектов с открытым исходным кодом из экосистемы *FastAPI and friends*. \n\n#### Развертывание у других облачных провайдеров { #deploy-to-other-cloud-providers }\n\nFastAPI — это open source и стандартизированный фреймворк. Вы можете развернуть приложения FastAPI у любого облачного провайдера на ваш выбор.\n\nСледуйте руководствам вашего облачного провайдера по развертыванию приложений FastAPI.", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md", "section_header": "Разверните приложение (опционально)", "section_header_level": 3}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 28, "header": "Разверните приложение (опционально)", "header_level": 3, "token_count": 174}
{"id": "b93b46ac6cb668af", "text": "## Производительность { #performance }\n\nНезависимые бенчмарки TechEmpower показывают приложения **FastAPI**, работающие под управлением Uvicorn, как <a href=\"https://www.techempower.com/benchmarks/#section=test&runid=7464e520-0dc2-473d-bd34-dbdfd7e85911&hw=ph&test=query&l=zijzen-7\" class=\"external-link\" target=\"_blank\">один из самых быстрых доступных фреймворков Python</a>, уступающий только самим Starlette и Uvicorn (используются внутри FastAPI). (*)\n\nЧтобы узнать больше, см. раздел <a href=\"https://fastapi.tiangolo.com/ru/benchmarks/\" class=\"internal-link\" target=\"_blank\">Бенчмарки</a>.\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 29, "header": "Производительность", "header_level": 2, "token_count": 222}
{"id": "6242f4fdd69c03ea", "text": "## Зависимости { #dependencies }\n\nFastAPI зависит от Pydantic и Starlette.\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 30, "header": "Зависимости", "header_level": 2, "token_count": 23}
{"id": "c7c6bc77c0fca799", "text": "### Зависимости `standard` { #standard-dependencies }\n\nКогда вы устанавливаете FastAPI с помощью `pip install \"fastapi[standard]\"`, он идёт с группой опциональных зависимостей `standard`:\n\nИспользуется Pydantic:\n\n* <a href=\"https://github.com/JoshData/python-email-validator\" target=\"_blank\"><code>email-validator</code></a> — для проверки адресов электронной почты.\n\nИспользуется Starlette:\n\n* <a href=\"https://www.python-httpx.org\" target=\"_blank\"><code>httpx</code></a> — обязателен, если вы хотите использовать `TestClient`.\n* <a href=\"https://jinja.palletsprojects.com\" target=\"_blank\"><code>jinja2</code></a> — обязателен, если вы хотите использовать конфигурацию шаблонов по умолчанию.\n* <a href=\"https://github.com/Kludex/python-multipart\" target=\"_blank\"><code>python-multipart</code></a> — обязателен, если вы хотите поддерживать <abbr title=\"преобразование строки, полученной из HTTP-запроса, в данные Python\">«парсинг»</abbr> форм через `request.form()`.\n\nИспользуется FastAPI:\n\n* <a href=\"https://www.uvicorn.dev\" target=\"_blank\"><code>uvicorn</code></a> — сервер, который загружает и обслуживает ваше приложение. Включает `uvicorn[standard]`, содержащий некоторые зависимости (например, `uvloop`), нужные для высокой производительности.\n* `fastapi-cli[standard]` — чтобы предоставить команду `fastapi`.\n    * Включает `fastapi-cloud-cli`, который позволяет развернуть ваше приложение FastAPI в <a href=\"https://fastapicloud.com\" class=\"external-link\" target=\"_blank\">FastAPI Cloud</a>.\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 31, "header": "Зависимости `standard`", "header_level": 3, "token_count": 503}
{"id": "ffa828a2b59c4422", "text": "### Без зависимостей `standard` { #without-standard-dependencies }\n\nЕсли вы не хотите включать опциональные зависимости `standard`, можно установить `pip install fastapi` вместо `pip install \"fastapi[standard]\"`.\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 32, "header": "Без зависимостей `standard`", "header_level": 3, "token_count": 64}
{"id": "529cdc0c42af0b32", "text": "### Без `fastapi-cloud-cli` { #without-fastapi-cloud-cli }\n\nЕсли вы хотите установить FastAPI со стандартными зависимостями, но без `fastapi-cloud-cli`, установите `pip install \"fastapi[standard-no-fastapi-cloud-cli]\"`.\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 33, "header": "Без `fastapi-cloud-cli`", "header_level": 3, "token_count": 68}
{"id": "23ca6f931122afb3", "text": "### Дополнительные опциональные зависимости { #additional-optional-dependencies }\n\nЕсть дополнительные зависимости, которые вы можете установить.\n\nДополнительные опциональные зависимости Pydantic:\n\n* <a href=\"https://docs.pydantic.dev/latest/usage/pydantic_settings/\" target=\"_blank\"><code>pydantic-settings</code></a> — для управления настройками.\n* <a href=\"https://docs.pydantic.dev/latest/usage/types/extra_types/extra_types/\" target=\"_blank\"><code>pydantic-extra-types</code></a> — дополнительные типы для использования с Pydantic.\n\nДополнительные опциональные зависимости FastAPI:\n\n* <a href=\"https://github.com/ijl/orjson\" target=\"_blank\"><code>orjson</code></a> — обязателен, если вы хотите использовать `ORJSONResponse`.\n* <a href=\"https://github.com/esnme/ultrajson\" target=\"_blank\"><code>ujson</code></a> — обязателен, если вы хотите использовать `UJSONResponse`.\n\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 34, "header": "Дополнительные опциональные зависимости", "header_level": 3, "token_count": 276}
{"id": "8e1b82ebdb05b37b", "text": "## Лицензия { #license }\n\nЭтот проект распространяется на условиях лицензии MIT.\n", "metadata": {"title": "FastAPI", "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "source_mtime": "2026-01-12T17:48:12.900316+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\index.md"}, "doc_id": "0b3e33619677", "source_path": "docs\\index.md", "title": "FastAPI", "chunk_index": 35, "header": "Лицензия", "header_level": 2, "token_count": 36}
{"id": "9456ced2a88006ea", "text": "# Шаблон Full Stack FastAPI { #full-stack-fastapi-template }\n\nШаблоны, хотя обычно поставляются с определённой конфигурацией, спроектированы так, чтобы быть гибкими и настраиваемыми. Это позволяет вам изменять их и адаптировать под требования вашего проекта, что делает их отличной отправной точкой. \n\nВы можете использовать этот шаблон для старта: в нём уже сделана значительная часть начальной настройки, безопасность, база данных и несколько эндпоинтов API.\n\nРепозиторий GitHub: <a href=\"https://github.com/tiangolo/full-stack-fastapi-template\" class=\"external-link\" target=\"_blank\">Full Stack FastAPI Template</a>\n\n", "metadata": {"title": "Шаблон Full Stack FastAPI", "doc_id": "c1aec07bad24", "source_path": "docs\\project-generation.md", "source_mtime": "2026-01-12T17:48:12.904602+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\project-generation.md"}, "doc_id": "c1aec07bad24", "source_path": "docs\\project-generation.md", "title": "Шаблон Full Stack FastAPI", "chunk_index": 0, "header": "Шаблон Full Stack FastAPI", "header_level": 1, "token_count": 222}
{"id": "9456ced2a88006ea", "text": "## Шаблон Full Stack FastAPI — Технологический стек и возможности { #full-stack-fastapi-template-technology-stack-and-features }", "metadata": {"title": "Шаблон Full Stack FastAPI", "doc_id": "c1aec07bad24", "source_path": "docs\\project-generation.md", "source_mtime": "2026-01-12T17:48:12.904602+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\project-generation.md", "section_header": "Шаблон Full Stack FastAPI — Технологический стек и возможности", "section_header_level": 2}, "doc_id": "c1aec07bad24", "source_path": "docs\\project-generation.md", "title": "Шаблон Full Stack FastAPI", "chunk_index": 1, "header": "Шаблон Full Stack FastAPI — Технологический стек и возможности", "header_level": 2, "token_count": 39}
{"id": "096aa10265ca94e9", "text": "## Шаблон Full Stack FastAPI — Технологический стек и возможности { #full-stack-fastapi-template-technology-stack-and-features }\n\n-  [**FastAPI**](https://fastapi.tiangolo.com/ru) для бэкенд‑API на Python.\n    -  [SQLModel](https://sqlmodel.tiangolo.com) для взаимодействия с SQL‑базой данных на Python (ORM).\n    -  [Pydantic](https://docs.pydantic.dev), используется FastAPI, для валидации данных и управления настройками.\n    -  [PostgreSQL](https://www.postgresql.org) в качестве SQL‑базы данных.\n-  [React](https://react.dev) для фронтенда.\n    -  Используются TypeScript, хуки, Vite и другие части современного фронтенд‑стека.\n    -  [Tailwind CSS](https://tailwindcss.com) и [shadcn/ui](https://ui.shadcn.com) для компонентов фронтенда.\n    -  Автоматически сгенерированный фронтенд‑клиент.\n    -  [Playwright](https://playwright.dev) для End‑to‑End тестирования.\n    -  Поддержка тёмной темы.\n-  [Docker Compose](https://www.docker.com) для разработки и продакшна.\n-  Безопасное хэширование паролей по умолчанию.\n-  Аутентификация по JWT‑токенам.\n-  Восстановление пароля по электронной почте.\n-  Тесты с [Pytest](https://pytest.org).\n-  [Traefik](https://traefik.io) в роли обратного прокси / балансировщика нагрузки.\n-  Инструкции по развёртыванию с использованием Docker Compose, включая настройку фронтенд‑прокси Traefik для автоматического получения сертификатов HTTPS.\n-  CI (continuous integration) и CD (continuous deployment) на основе GitHub Actions.", "metadata": {"title": "Шаблон Full Stack FastAPI", "doc_id": "c1aec07bad24", "source_path": "docs\\project-generation.md", "source_mtime": "2026-01-12T17:48:12.904602+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\project-generation.md", "section_header": "Шаблон Full Stack FastAPI — Технологический стек и возможности", "section_header_level": 2}, "doc_id": "c1aec07bad24", "source_path": "docs\\project-generation.md", "title": "Шаблон Full Stack FastAPI", "chunk_index": 2, "header": "Шаблон Full Stack FastAPI — Технологический стек и возможности", "header_level": 2, "token_count": 543}
{"id": "4818d974a5ee8f55", "text": "# Введение в типы Python { #python-types-intro }\n\nPython поддерживает необязательные «подсказки типов» (их также называют «аннотациями типов»).\n\nЭти **«подсказки типов»** или аннотации — это специальный синтаксис, позволяющий объявлять <abbr title=\"например: str, int, float, bool\">тип</abbr> переменной.\n\nОбъявляя типы для ваших переменных, редакторы кода и инструменты смогут лучше вас поддерживать.\n\nЭто всего лишь **краткое руководство / напоминание** о подсказках типов в Python. Оно охватывает только минимум, необходимый для их использования с **FastAPI**... что на самом деле очень мало.\n\n**FastAPI** целиком основан на этих подсказках типов — они дают ему множество преимуществ и выгод.\n\nНо даже если вы никогда не используете **FastAPI**, вам будет полезно немного узнать о них.\n\n/// note | Примечание\n\nЕсли вы являетесь экспертом в Python и уже знаете всё о подсказках типов, переходите к следующей главе.\n\n///\n\n", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md"}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 0, "header": "Введение в типы Python", "header_level": 1, "token_count": 369}
{"id": "54c20c9cbc5909df", "text": "## Мотивация { #motivation }\n\nДавайте начнем с простого примера:\n\n{* ../../docs_src/python_types/tutorial001_py39.py *}\n\nВызов этой программы выводит:\n\n```\nJohn Doe\n```\n\nФункция делает следующее:\n\n* Принимает `first_name` и `last_name`.\n* Преобразует первую букву каждого значения в верхний регистр с помощью `title()`.\n* <abbr title=\"Объединяет в одно целое. Содержимое одного — сразу после другого.\">Соединяет</abbr> их пробелом посередине.\n\n{* ../../docs_src/python_types/tutorial001_py39.py hl[2] *}\n\n", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md"}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 1, "header": "Мотивация", "header_level": 2, "token_count": 180}
{"id": "e589dc5450ea3774", "text": "### Отредактируем пример { #edit-it }\n\nЭто очень простая программа.\n\nА теперь представьте, что вы пишете её с нуля.\n\nВ какой-то момент вы бы начали определение функции, у вас были бы готовы параметры...\n\nНо затем нужно вызвать «тот метод, который делает первую букву заглавной».\n\nЭто был `upper`? Или `uppercase`? `first_uppercase`? `capitalize`?\n\nТогда вы пробуете старого друга программиста — автозавершение редактора кода.\n\nВы вводите первый параметр функции, `first_name`, затем точку (`.`) и нажимаете `Ctrl+Space`, чтобы вызвать автозавершение.\n\nНо, к сожалению, ничего полезного не находится:\n\n<img src=\"/img/python-types/image01.png\">\n\n", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md"}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 2, "header": "Отредактируем пример", "header_level": 3, "token_count": 241}
{"id": "9354eccc73fa0449", "text": "### Добавим типы { #add-types }\n\nДавайте изменим одну строку из предыдущей версии.\n\nМы поменяем ровно этот фрагмент — параметры функции — с:\n\n```Python\n    first_name, last_name\n```\n\nна:\n\n```Python\n    first_name: str, last_name: str\n```\n\nВот и всё.\n\nЭто и есть «подсказки типов»:\n\n{* ../../docs_src/python_types/tutorial002_py39.py hl[1] *}\n\nЭто не то же самое, что объявление значений по умолчанию, как, например:\n\n```Python\n    first_name=\"john\", last_name=\"doe\"\n```\n\nЭто другая вещь.\n\nЗдесь мы используем двоеточия (`:`), а не знак равенства (`=`).\n\nИ добавление подсказок типов обычно не меняет поведение программы по сравнению с вариантом без них.\n\nНо теперь представьте, что вы снова посередине написания этой функции, только уже с подсказками типов.\n\nВ тот же момент вы пробуете вызвать автозавершение с помощью `Ctrl+Space` — и видите:\n\n<img src=\"/img/python-types/image02.png\">\n\nС этим вы можете прокручивать варианты, пока не найдёте тот самый:\n\n<img src=\"/img/python-types/image03.png\">\n\n", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md"}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 3, "header": "Добавим типы", "header_level": 3, "token_count": 368}
{"id": "92515a3929ea39e3", "text": "## Больше мотивации { #more-motivation }\n\nПосмотрите на эту функцию — у неё уже есть подсказки типов:\n\n{* ../../docs_src/python_types/tutorial003_py39.py hl[1] *}\n\nТак как редактор кода знает типы переменных, вы получаете не только автозавершение, но и проверки ошибок:\n\n<img src=\"/img/python-types/image04.png\">\n\nТеперь вы знаете, что нужно исправить — преобразовать `age` в строку с помощью `str(age)`:\n\n{* ../../docs_src/python_types/tutorial004_py39.py hl[2] *}\n\n", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md"}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 4, "header": "Больше мотивации", "header_level": 2, "token_count": 155}
{"id": "829b82d974c3f46a", "text": "## Объявление типов { #declaring-types }\n\nВы только что увидели основное место, где объявляют подсказки типов — параметры функции.\n\nЭто также основное место, где вы будете использовать их с **FastAPI**.\n\n", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md"}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 5, "header": "Объявление типов", "header_level": 2, "token_count": 72}
{"id": "d252710e54ff05a7", "text": "### Простые типы { #simple-types }\n\nВы можете объявлять все стандартные типы Python, не только `str`.\n\nМожно использовать, например:\n\n* `int`\n* `float`\n* `bool`\n* `bytes`\n\n{* ../../docs_src/python_types/tutorial005_py39.py hl[1] *}\n\n", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md"}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 6, "header": "Простые типы", "header_level": 3, "token_count": 75}
{"id": "4818d974a5ee8f55", "text": "### Generic-типы с параметрами типов { #generic-types-with-type-parameters }\n\nЕсть структуры данных, которые могут содержать другие значения, например, `dict`, `list`, `set` и `tuple`. И внутренние значения тоже могут иметь свой тип.\n\nТакие типы, которые содержат внутренние типы, называют «**generic**»-типами. И их можно объявлять, в том числе с указанием внутренних типов.\n\nЧтобы объявлять эти типы и их внутренние типы, вы можете использовать стандартный модуль Python `typing`. Он существует специально для поддержки подсказок типов.\n\n#### Новые версии Python { #newer-versions-of-python }\n\nСинтаксис с использованием `typing` **совместим** со всеми версиями, от Python 3.6 до самых новых, включая Python 3.9, Python 3.10 и т.д.\n\nПо мере развития Python **новые версии** получают улучшенную поддержку этих аннотаций типов, и во многих случаях вам даже не нужно импортировать и использовать модуль `typing`, чтобы объявлять аннотации типов.\n\nЕсли вы можете выбрать более свежую версию Python для проекта, вы получите дополнительную простоту.\n\nВо всей документации есть примеры, совместимые с каждой версией Python (когда есть различия).", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md", "section_header": "Generic-типы с параметрами типов", "section_header_level": 3}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 7, "header": "Generic-типы с параметрами типов", "header_level": 3, "token_count": 443}
{"id": "54c20c9cbc5909df", "text": "более свежую версию Python для проекта, вы получите дополнительную простоту.\n\nВо всей документации есть примеры, совместимые с каждой версией Python (когда есть различия).\n\nНапример, «**Python 3.6+**» означает совместимость с Python 3.6 и выше (включая 3.7, 3.8, 3.9, 3.10 и т.д.). А «**Python 3.9+**» — совместимость с Python 3.9 и выше (включая 3.10 и т.п.).\n\nЕсли вы можете использовать **последние версии Python**, используйте примеры для самой новой версии — у них будет **самый лучший и простой синтаксис**, например, «**Python 3.10+**».\n\n#### List { #list }\n\nНапример, давайте определим переменную как `list` из `str`.\n\nОбъявите переменную с тем же синтаксисом двоеточия (`:`).\n\nВ качестве типа укажите `list`.\n\nТак как список — это тип, содержащий внутренние типы, укажите их в квадратных скобках:\n\n{* ../../docs_src/python_types/tutorial006_py39.py hl[1] *}\n\n/// info | Информация\n\nЭти внутренние типы в квадратных скобках называются «параметрами типов».\n\nВ данном случае `str` — это параметр типа, передаваемый в `list`.\n\n///\n\nЭто означает: «переменная `items` — это `list`, и каждый элемент этого списка — `str`».\n\nТаким образом, ваш редактор кода сможет помогать даже при обработке элементов списка:\n\n<img src=\"/img/python-types/image05.png\">", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md", "section_header": "Generic-типы с параметрами типов", "section_header_level": 3}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 8, "header": "Generic-типы с параметрами типов", "header_level": 3, "token_count": 504}
{"id": "e589dc5450ea3774", "text": "еменная `items` — это `list`, и каждый элемент этого списка — `str`».\n\nТаким образом, ваш редактор кода сможет помогать даже при обработке элементов списка:\n\n<img src=\"/img/python-types/image05.png\">\n\nБез типов добиться этого почти невозможно.\n\nОбратите внимание, что переменная `item` — один из элементов списка `items`.\n\nИ всё же редактор кода знает, что это `str`, и даёт соответствующую поддержку.\n\n#### Tuple и Set { #tuple-and-set }\n\nАналогично вы бы объявили `tuple` и `set`:\n\n{* ../../docs_src/python_types/tutorial007_py39.py hl[1] *}\n\nЭто означает:\n\n* Переменная `items_t` — это `tuple` из 3 элементов: `int`, ещё один `int` и `str`.\n* Переменная `items_s` — это `set`, и каждый элемент имеет тип `bytes`.\n\n#### Dict { #dict }\n\nЧтобы определить `dict`, вы передаёте 2 параметра типов, разделённые запятой.\n\nПервый параметр типа — для ключей `dict`.\n\nВторой параметр типа — для значений `dict`:\n\n{* ../../docs_src/python_types/tutorial008_py39.py hl[1] *}\n\nЭто означает:\n\n* Переменная `prices` — это `dict`:\n    * Ключи этого `dict` имеют тип `str` (скажем, название каждой позиции).\n    * Значения этого `dict` имеют тип `float` (скажем, цена каждой позиции).\n\n#### Union { #union }\n\nВы можете объявить, что переменная может быть **одним из нескольких типов**, например, `int` или `str`.", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md", "section_header": "Generic-типы с параметрами типов", "section_header_level": 3}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 9, "header": "Generic-типы с параметрами типов", "header_level": 3, "token_count": 465}
{"id": "9354eccc73fa0449", "text": "имеют тип `float` (скажем, цена каждой позиции).\n\n#### Union { #union }\n\nВы можете объявить, что переменная может быть **одним из нескольких типов**, например, `int` или `str`.\n\nВ Python 3.6 и выше (включая Python 3.10) вы можете использовать тип `Union` из `typing` и перечислить в квадратных скобках все допустимые типы.\n\nВ Python 3.10 также появился **новый синтаксис**, где допустимые типы можно указать через <abbr title='также называется «побитовый оператор OR», но это значение здесь нерелевантно'>вертикальную черту (`|`)</abbr>.\n\n//// tab | Python 3.10+\n\n```Python hl_lines=\"1\"\n{!> ../../docs_src/python_types/tutorial008b_py310.py!}\n```\n\n////\n\n//// tab | Python 3.9+\n\n```Python hl_lines=\"1  4\"\n{!> ../../docs_src/python_types/tutorial008b_py39.py!}\n```\n\n////\n\nВ обоих случаях это означает, что `item` может быть `int` или `str`.\n\n#### Возможно `None` { #possibly-none }\n\nВы можете объявить, что значение может иметь определённый тип, например `str`, но также может быть и `None`.\n\nВ Python 3.6 и выше (включая Python 3.10) это можно объявить, импортировав и используя `Optional` из модуля `typing`.\n\n```Python hl_lines=\"1  4\"\n{!../../docs_src/python_types/tutorial009_py39.py!}\n```\n\nИспользование `Optional[str]` вместо просто `str` позволит редактору кода помочь вам обнаружить ошибки, когда вы предполагаете, что значение всегда `str`, хотя на самом деле оно может быть и `None`.", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md", "section_header": "Generic-типы с параметрами типов", "section_header_level": 3}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 10, "header": "Generic-типы с параметрами типов", "header_level": 3, "token_count": 505}
{"id": "92515a3929ea39e3", "text": "просто `str` позволит редактору кода помочь вам обнаружить ошибки, когда вы предполагаете, что значение всегда `str`, хотя на самом деле оно может быть и `None`.\n\n`Optional[Something]` — это на самом деле сокращение для `Union[Something, None]`, они эквивалентны.\n\nЭто также означает, что в Python 3.10 вы можете использовать `Something | None`:\n\n//// tab | Python 3.10+\n\n```Python hl_lines=\"1\"\n{!> ../../docs_src/python_types/tutorial009_py310.py!}\n```\n\n////\n\n//// tab | Python 3.9+\n\n```Python hl_lines=\"1  4\"\n{!> ../../docs_src/python_types/tutorial009_py39.py!}\n```\n\n////\n\n//// tab | Python 3.9+ альтернативный вариант\n\n```Python hl_lines=\"1  4\"\n{!> ../../docs_src/python_types/tutorial009b_py39.py!}\n```\n\n////\n\n#### Использовать `Union` или `Optional` { #using-union-or-optional }\n\nЕсли вы используете версию Python ниже 3.10, вот совет с моей весьма **субъективной** точки зрения:\n\n*  Избегайте использования `Optional[SomeType]`\n* Вместо этого  **используйте `Union[SomeType, None]`** .\n\nОба варианта эквивалентны и внутри одинаковы, но я бы рекомендовал `Union` вместо `Optional`, потому что слово «**optional**» («необязательный») может навести на мысль, что значение необязательное, хотя на самом деле оно означает «может быть `None`», даже если параметр не является необязательным и всё ещё обязателен.", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md", "section_header": "Generic-типы с параметрами типов", "section_header_level": 3}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 11, "header": "Generic-типы с параметрами типов", "header_level": 3, "token_count": 492}
{"id": "829b82d974c3f46a", "text": "на мысль, что значение необязательное, хотя на самом деле оно означает «может быть `None`», даже если параметр не является необязательным и всё ещё обязателен.\n\nМне кажется, `Union[SomeType, None]` более явно выражает смысл.\n\nРечь только о словах и названиях. Но эти слова могут влиять на то, как вы и ваши коллеги думаете о коде.\n\nВ качестве примера возьмём эту функцию:\n\n{* ../../docs_src/python_types/tutorial009c_py39.py hl[1,4] *}\n\nПараметр `name` определён как `Optional[str]`, но он **не необязательный** — вы не можете вызвать функцию без этого параметра:\n\n```Python\nsay_hi()  # О нет, это вызывает ошибку! 😱\n```\n\nПараметр `name` всё ещё **обязателен** (не *optional*), потому что у него нет значения по умолчанию. При этом `name` принимает `None` как значение:\n\n```Python\nsay_hi(name=None)  # Это работает, None допустим 🎉\n```\n\nХорошая новость: как только вы перейдёте на Python 3.10, об этом можно не переживать — вы сможете просто использовать `|` для объединения типов:\n\n{* ../../docs_src/python_types/tutorial009c_py310.py hl[1,4] *}\n\nИ тогда вам не придётся задумываться о названиях вроде `Optional` и `Union`. \n\n#### Generic-типы { #generic-types }\n\nТипы, которые принимают параметры типов в квадратных скобках, называются **Generic-типами** или **Generics**, например:\n\n//// tab | Python 3.10+", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md", "section_header": "Generic-типы с параметрами типов", "section_header_level": 3}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 12, "header": "Generic-типы с параметрами типов", "header_level": 3, "token_count": 501}
{"id": "d252710e54ff05a7", "text": "пы { #generic-types }\n\nТипы, которые принимают параметры типов в квадратных скобках, называются **Generic-типами** или **Generics**, например:\n\n//// tab | Python 3.10+\n\nВы можете использовать те же встроенные типы как generics (с квадратными скобками и типами внутри):\n\n* `list`\n* `tuple`\n* `set`\n* `dict`\n\nИ, как и в предыдущих версиях Python, из модуля `typing`:\n\n* `Union`\n* `Optional`\n* ...и другие.\n\nВ Python 3.10, как альтернативу generics `Union` и `Optional`, можно использовать <abbr title='также называется «побитовый оператор OR», но это значение здесь нерелевантно'>вертикальную черту (`|`)</abbr> для объявления объединений типов — это гораздо лучше и проще.\n\n////\n\n//// tab | Python 3.9+\n\nВы можете использовать те же встроенные типы как generics (с квадратными скобками и типами внутри):\n\n* `list`\n* `tuple`\n* `set`\n* `dict`\n\nИ generics из модуля `typing`:\n\n* `Union`\n* `Optional`\n* ...и другие.\n\n////", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md", "section_header": "Generic-типы с параметрами типов", "section_header_level": 3}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 13, "header": "Generic-типы с параметрами типов", "header_level": 3, "token_count": 347}
{"id": "6c9c7313973e5bb6", "text": "### Классы как типы { #classes-as-types }\n\nВы также можете объявлять класс как тип переменной.\n\nДопустим, у вас есть класс `Person` с именем:\n\n{* ../../docs_src/python_types/tutorial010_py39.py hl[1:3] *}\n\nТогда вы можете объявить переменную типа `Person`:\n\n{* ../../docs_src/python_types/tutorial010_py39.py hl[6] *}\n\nИ снова вы получите полную поддержку редактора кода:\n\n<img src=\"/img/python-types/image06.png\">\n\nОбратите внимание, что это означает: «`one_person` — это **экземпляр** класса `Person`».\n\nЭто не означает: «`one_person` — это **класс** с именем `Person`».\n\n", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md"}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 14, "header": "Классы как типы", "header_level": 3, "token_count": 197}
{"id": "9648c46fbe3444e5", "text": "## Pydantic-модели { #pydantic-models }\n\n<a href=\"https://docs.pydantic.dev/\" class=\"external-link\" target=\"_blank\">Pydantic</a> — это библиотека Python для валидации данных.\n\nВы объявляете «форму» данных как классы с атрибутами.\n\nИ у каждого атрибута есть тип.\n\nЗатем вы создаёте экземпляр этого класса с некоторыми значениями — он провалидирует значения, преобразует их к соответствующему типу (если это применимо) и вернёт вам объект со всеми данными.\n\nИ вы получите полную поддержку редактора кода для этого результирующего объекта.\n\nПример из официальной документации Pydantic:\n\n{* ../../docs_src/python_types/tutorial011_py310.py *}\n\n/// info | Информация\n\nЧтобы узнать больше о <a href=\"https://docs.pydantic.dev/\" class=\"external-link\" target=\"_blank\">Pydantic, ознакомьтесь с его документацией</a>.\n\n///\n\n**FastAPI** целиком основан на Pydantic.\n\nВы увидите намного больше всего этого на практике в [Руководстве пользователя](tutorial/index.md){.internal-link target=_blank}.\n\n/// tip | Совет\n\nУ Pydantic есть особое поведение, когда вы используете `Optional` или `Union[Something, None]` без значения по умолчанию. Подробнее читайте в документации Pydantic: <a href=\"https://docs.pydantic.dev/2.3/usage/models/#required-fields\" class=\"external-link\" target=\"_blank\">Required Optional fields</a>.\n\n///\n\n", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md"}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 15, "header": "Pydantic-модели", "header_level": 2, "token_count": 453}
{"id": "4818d974a5ee8f55", "text": "## Подсказки типов с аннотациями метаданных { #type-hints-with-metadata-annotations }\n\nВ Python также есть возможность добавлять **дополнительные <abbr title=\"Данные о данных, в данном случае — информация о типе, например описание.\">метаданные</abbr>** к подсказкам типов с помощью `Annotated`.\n\nНачиная с Python 3.9, `Annotated` входит в стандартную библиотеку, поэтому вы можете импортировать его из `typing`.\n\n{* ../../docs_src/python_types/tutorial013_py39.py hl[1,4] *}\n\nСам Python ничего не делает с `Annotated`. А для редакторов кода и других инструментов тип по-прежнему `str`.\n\nНо вы можете использовать это место в `Annotated`, чтобы передать **FastAPI** дополнительные метаданные о том, как вы хотите, чтобы ваше приложение себя вело.\n\nВажно помнить, что **первый параметр типа**, который вы передаёте в `Annotated`, — это **фактический тип**. Всё остальное — просто метаданные для других инструментов.\n\nПока вам достаточно знать, что `Annotated` существует и это — стандартный Python. \n\nПозже вы увидите, насколько это **мощно**.\n\n/// tip | Совет\n\nТот факт, что это **стандартный Python**, означает, что вы по-прежнему получите **лучший возможный разработческий опыт** в вашем редакторе кода, с инструментами для анализа и рефакторинга кода и т.д.", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md", "section_header": "Подсказки типов с аннотациями метаданных", "section_header_level": 2}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 16, "header": "Подсказки типов с аннотациями метаданных", "header_level": 2, "token_count": 477}
{"id": "54c20c9cbc5909df", "text": "режнему получите **лучший возможный разработческий опыт** в вашем редакторе кода, с инструментами для анализа и рефакторинга кода и т.д. \n\nА ещё ваш код будет очень совместим со множеством других инструментов и библиотек Python. \n\n///", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md", "section_header": "Подсказки типов с аннотациями метаданных", "section_header_level": 2}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 17, "header": "Подсказки типов с аннотациями метаданных", "header_level": 2, "token_count": 102}
{"id": "4818d974a5ee8f55", "text": "## Аннотации типов в **FastAPI** { #type-hints-in-fastapi }\n\n**FastAPI** использует эти подсказки типов для выполнения нескольких задач.\n\nС **FastAPI** вы объявляете параметры с подсказками типов и получаете:\n\n* **Поддержку редактора кода**.\n* **Проверки типов**.\n\n...и **FastAPI** использует эти же объявления для:\n\n* **Определения требований**: из path-параметров пути запроса, query-параметров, HTTP-заголовков, тел запросов, зависимостей и т.д.\n* **Преобразования данных**: из HTTP-запроса к требуемому типу.\n* **Валидации данных**: приходящих с каждого HTTP-запроса:\n    * Генерации **автоматических ошибок**, возвращаемых клиенту, когда данные некорректны.\n* **Документирования** API с использованием OpenAPI:\n    * что затем используется пользовательскими интерфейсами автоматической интерактивной документации.\n\nВсё это может звучать абстрактно. Не волнуйтесь. Вы увидите всё это в действии в [Руководстве пользователя](tutorial/index.md){.internal-link target=_blank}.\n\nВажно то, что, используя стандартные типы Python в одном месте (вместо добавления дополнительных классов, декораторов и т.д.), **FastAPI** сделает за вас большую часть работы.\n\n/// info | Информация", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md", "section_header": "Аннотации типов в **FastAPI**", "section_header_level": 2}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 18, "header": "Аннотации типов в **FastAPI**", "header_level": 2, "token_count": 432}
{"id": "54c20c9cbc5909df", "text": "стандартные типы Python в одном месте (вместо добавления дополнительных классов, декораторов и т.д.), **FastAPI** сделает за вас большую часть работы.\n\n/// info | Информация\n\nЕсли вы уже прошли всё руководство и вернулись, чтобы узнать больше о типах, хорошим ресурсом будет <a href=\"https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html\" class=\"external-link\" target=\"_blank\">«шпаргалка» от `mypy`</a>.\n\n///", "metadata": {"title": "Введение в типы Python", "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "source_mtime": "2026-01-12T17:48:12.912163+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\python-types.md", "section_header": "Аннотации типов в **FastAPI**", "section_header_level": 2}, "doc_id": "d5dd7cd703f7", "source_path": "docs\\python-types.md", "title": "Введение в типы Python", "chunk_index": 19, "header": "Аннотации типов в **FastAPI**", "header_level": 2, "token_count": 157}
{"id": "362aab4eacad29ae", "text": "# Виртуальные окружения { #virtual-environments }\n\nПри работе с проектами на Python рекомендуется использовать **виртуальное окружение** (или похожий механизм), чтобы изолировать пакеты, которые вы устанавливаете для каждого проекта.\n\n/// info | Дополнительная информация\n\nЕсли вы уже знакомы с виртуальными окружениями, знаете, как их создавать и использовать, вы можете пропустить этот раздел. \n\n///\n\n/// tip | Подсказка\n\n**Виртуальное окружение** — это не то же самое, что **переменная окружения**.\n\n**Переменная окружения** — это переменная в системе, которую могут использовать программы.\n\n**Виртуальное окружение** — это директория с файлами внутри.\n\n///\n\n/// info | Дополнительная информация\n\nНа этой странице вы узнаете, как пользоваться **виртуальными окружениями** и как они работают.\n\nЕсли вы готовы начать использовать **инструмент, который управляет всем** за вас (включая установку Python), попробуйте <a href=\"https://github.com/astral-sh/uv\" class=\"external-link\" target=\"_blank\">uv</a>.\n\n///\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 0, "header": "Виртуальные окружения", "header_level": 1, "token_count": 364}
{"id": "e745ba043593ad84", "text": "## Создание проекта { #create-a-project }\n\nСначала создайте директорию для вашего проекта.\n\nОбычно я создаю папку с именем `code` в моем домашнем каталоге.\n\nА внутри неё создаю отдельную директорию для каждого проекта.\n\n<div class=\"termy\">\n\n```console\n// Перейдите в домашний каталог\n$ cd\n// Создайте директорию для всех ваших проектов с кодом\n$ mkdir code\n// Перейдите в эту директорию code\n$ cd code\n// Создайте директорию для этого проекта\n$ mkdir awesome-project\n// Перейдите в директорию проекта\n$ cd awesome-project\n```\n\n</div>\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 1, "header": "Создание проекта", "header_level": 2, "token_count": 217}
{"id": "362aab4eacad29ae", "text": "## Создание виртуального окружения { #create-a-virtual-environment }\n\nКогда вы начинаете работать над Python‑проектом **впервые**, создайте виртуальное окружение **<abbr title=\"есть и другие опции, но это простой ориентир\">внутри вашего проекта</abbr>**.\n\n/// tip | Подсказка\n\nДелать это нужно **один раз на проект**, не каждый раз, когда вы работаете.\n\n///\n\n//// tab | `venv`\n\nДля создания виртуального окружения вы можете использовать модуль `venv`, который поставляется вместе с Python.\n\n<div class=\"termy\">\n\n```console\n$ python -m venv .venv\n```\n\n</div>\n\n/// details | Что делает эта команда?\n\n* `python`: использовать программу под названием `python`\n* `-m`: вызвать модуль как скрипт, далее мы укажем, какой модуль вызвать\n* `venv`: использовать модуль `venv`, который обычно устанавливается вместе с Python\n* `.venv`: создать виртуальное окружение в новой директории `.venv`\n\n///\n\n////\n\n//// tab | `uv`\n\nЕсли у вас установлен <a href=\"https://github.com/astral-sh/uv\" class=\"external-link\" target=\"_blank\">`uv`</a>, вы можете использовать его для создания виртуального окружения.\n\n<div class=\"termy\">\n\n```console\n$ uv venv\n```\n\n</div>\n\n/// tip | Подсказка\n\nПо умолчанию `uv` создаст виртуальное окружение в директории с именем `.venv`.\n\nНо вы можете переопределить это, передав дополнительный аргумент с именем директории.\n\n///\n\n////", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md", "section_header": "Создание виртуального окружения", "section_header_level": 2}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 2, "header": "Создание виртуального окружения", "header_level": 2, "token_count": 488}
{"id": "e745ba043593ad84", "text": "анию `uv` создаст виртуальное окружение в директории с именем `.venv`.\n\nНо вы можете переопределить это, передав дополнительный аргумент с именем директории.\n\n///\n\n////\n\nЭта команда создаст новое виртуальное окружение в директории `.venv`.\n\n/// details | `.venv` или другое имя?\n\nВы можете создать виртуальное окружение в другой директории, но по соглашению его называют `.venv`.\n\n///", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md", "section_header": "Создание виртуального окружения", "section_header_level": 2}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 3, "header": "Создание виртуального окружения", "header_level": 2, "token_count": 147}
{"id": "39398eae8e8afbf6", "text": "## Активация виртуального окружения { #activate-the-virtual-environment }\n\nАктивируйте новое виртуальное окружение, чтобы все команды Python и устанавливаемые пакеты использовали именно его.\n\n/// tip | Подсказка\n\nДелайте это **каждый раз**, когда вы начинаете **новую сессию терминала** для работы над проектом.\n\n///\n\n//// tab | Linux, macOS\n\n<div class=\"termy\">\n\n```console\n$ source .venv/bin/activate\n```\n\n</div>\n\n////\n\n//// tab | Windows PowerShell\n\n<div class=\"termy\">\n\n```console\n$ .venv\\Scripts\\Activate.ps1\n```\n\n</div>\n\n////\n\n//// tab | Windows Bash\n\nИли если вы используете Bash для Windows (например, <a href=\"https://gitforwindows.org/\" class=\"external-link\" target=\"_blank\">Git Bash</a>):\n\n<div class=\"termy\">\n\n```console\n$ source .venv/Scripts/activate\n```\n\n</div>\n\n////\n\n/// tip | Подсказка\n\nКаждый раз, когда вы устанавливаете **новый пакет** в это окружение, **активируйте** окружение снова.\n\nЭто гарантирует, что если вы используете **программу терминала (<abbr title=\"command line interface – интерфейс командной строки\">CLI</abbr>)**, установленную этим пакетом, вы будете использовать именно ту, что из вашего виртуального окружения, а не какую‑то глобально установленную, возможно другой версии, чем вам нужна.\n\n///\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 4, "header": "Активация виртуального окружения", "header_level": 2, "token_count": 428}
{"id": "f36e27b5389d8fde", "text": "## Проверка, что виртуальное окружение активно { #check-the-virtual-environment-is-active }\n\nПроверьте, что виртуальное окружение активно (предыдущая команда сработала).\n\n/// tip | Подсказка\n\nЭто **необязательно**, но это хороший способ **проверить**, что всё работает как ожидается и вы используете запланированное виртуальное окружение.\n\n///\n\n//// tab | Linux, macOS, Windows Bash\n\n<div class=\"termy\">\n\n```console\n$ which python\n\n/home/user/code/awesome-project/.venv/bin/python\n```\n\n</div>\n\nЕсли отображается исполняемый файл `python` по пути `.venv/bin/python` внутри вашего проекта (в нашем случае `awesome-project`), значит всё сработало. \n\n////\n\n//// tab | Windows PowerShell\n\n<div class=\"termy\">\n\n```console\n$ Get-Command python\n\nC:\\Users\\user\\code\\awesome-project\\.venv\\Scripts\\python\n```\n\n</div>\n\nЕсли отображается исполняемый файл `python` по пути `.venv\\Scripts\\python` внутри вашего проекта (в нашем случае `awesome-project`), значит всё сработало. \n\n////\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 5, "header": "Проверка, что виртуальное окружение активно", "header_level": 2, "token_count": 329}
{"id": "78f99e7131e36dd1", "text": "## Обновление `pip` { #upgrade-pip }\n\n/// tip | Подсказка\n\nЕсли вы используете <a href=\"https://github.com/astral-sh/uv\" class=\"external-link\" target=\"_blank\">`uv`</a>, то для установки вы будете использовать его вместо `pip`, поэтому обновлять `pip` не нужно. \n\n///\n\nЕсли для установки пакетов вы используете `pip` (он идёт по умолчанию вместе с Python), вам стоит **обновить** его до последней версии.\n\nМногие экзотические ошибки при установке пакетов решаются простым предварительным обновлением `pip`.\n\n/// tip | Подсказка\n\nОбычно это делается **один раз**, сразу после создания виртуального окружения.\n\n///\n\nУбедитесь, что виртуальное окружение активно (см. команду выше) и запустите:\n\n<div class=\"termy\">\n\n```console\n$ python -m pip install --upgrade pip\n\n---> 100%\n```\n\n</div>\n\n/// tip | Подсказка\n\nИногда при попытке обновить pip вы можете получить ошибку **`No module named pip`**.\n\nЕсли это произошло, установите и обновите pip с помощью команды ниже:\n\n<div class=\"termy\">\n\n```console\n$ python -m ensurepip --upgrade\n\n---> 100%\n```\n\n</div>\n\nЭта команда установит pip, если он ещё не установлен, а также гарантирует, что установленная версия pip будет не старее, чем версия, доступная в `ensurepip`.\n\n///\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 6, "header": "Обновление `pip`", "header_level": 2, "token_count": 446}
{"id": "cd09048f486345db", "text": "## Добавление `.gitignore` { #add-gitignore }\n\nЕсли вы используете **Git** (а вам стоит его использовать), добавьте файл `.gitignore`, чтобы исключить из Git всё, что находится в вашей `.venv`.\n\n/// tip | Подсказка\n\nЕсли вы использовали <a href=\"https://github.com/astral-sh/uv\" class=\"external-link\" target=\"_blank\">`uv`</a> для создания виртуального окружения, он уже сделал это за вас — можно пропустить этот шаг. \n\n///\n\n/// tip | Подсказка\n\nСделайте это **один раз**, сразу после создания виртуального окружения.\n\n///\n\n<div class=\"termy\">\n\n```console\n$ echo \"*\" > .venv/.gitignore\n```\n\n</div>\n\n/// details | Что делает эта команда?\n\n* `echo \"*\"`: «напечатать» в терминале текст `*` (следующая часть немного меняет поведение)\n* `>`: всё, что команда слева от `>` выводит в терминал, вместо печати нужно записать в файл, указанный справа от `>`\n* `.gitignore`: имя файла, в который нужно записать текст\n\nА `*` в Git означает «всё». То есть будет игнорироваться всё в директории `.venv`.\n\nЭта команда создаст файл `.gitignore` со следующим содержимым:\n\n```gitignore\n*\n```\n\n///\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 7, "header": "Добавление `.gitignore`", "header_level": 2, "token_count": 390}
{"id": "53a68b7e2a27b41a", "text": "## Установка пакетов { #install-packages }\n\nПосле активации окружения вы можете устанавливать в него пакеты.\n\n/// tip | Подсказка\n\nСделайте это **один раз** при установке или обновлении пакетов, необходимых вашему проекту.\n\nЕсли вам нужно обновить версию или добавить новый пакет, вы **сделаете это снова**.\n\n///\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 8, "header": "Установка пакетов", "header_level": 2, "token_count": 119}
{"id": "fc0997499994fb6c", "text": "### Установка пакетов напрямую { #install-packages-directly }\n\nЕсли вы торопитесь и не хотите объявлять зависимости проекта в отдельном файле, вы можете установить их напрямую.\n\n/// tip | Подсказка\n\nОчень хорошая идея — указать используемые вашим проектом пакеты и их версии в файле (например, `requirements.txt` или `pyproject.toml`).\n\n///\n\n//// tab | `pip`\n\n<div class=\"termy\">\n\n```console\n$ pip install \"fastapi[standard]\"\n\n---> 100%\n```\n\n</div>\n\n////\n\n//// tab | `uv`\n\nЕсли у вас установлен <a href=\"https://github.com/astral-sh/uv\" class=\"external-link\" target=\"_blank\">`uv`</a>:\n\n<div class=\"termy\">\n\n```console\n$ uv pip install \"fastapi[standard]\"\n---> 100%\n```\n\n</div>\n\n////\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 9, "header": "Установка пакетов напрямую", "header_level": 3, "token_count": 243}
{"id": "703fef01429d0265", "text": "### Установка из `requirements.txt` { #install-from-requirements-txt }\n\nЕсли у вас есть `requirements.txt`, вы можете использовать его для установки пакетов.\n\n//// tab | `pip`\n\n<div class=\"termy\">\n\n```console\n$ pip install -r requirements.txt\n---> 100%\n```\n\n</div>\n\n////\n\n//// tab | `uv`\n\nЕсли у вас установлен <a href=\"https://github.com/astral-sh/uv\" class=\"external-link\" target=\"_blank\">`uv`</a>:\n\n<div class=\"termy\">\n\n```console\n$ uv pip install -r requirements.txt\n---> 100%\n```\n\n</div>\n\n////\n\n/// details | `requirements.txt`\n\n`requirements.txt` с некоторыми пакетами может выглядеть так:\n\n```requirements.txt\nfastapi[standard]==0.113.0\npydantic==2.8.0\n```\n\n///\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 10, "header": "Установка из `requirements.txt`", "header_level": 3, "token_count": 209}
{"id": "befc302f2b817354", "text": "## Запуск вашей программы { #run-your-program }\n\nПосле активации виртуального окружения вы можете запустить свою программу, и она будет использовать Python из вашего виртуального окружения вместе с установленными там пакетами.\n\n<div class=\"termy\">\n\n```console\n$ python main.py\n\nHello World\n```\n\n</div>\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 11, "header": "Запуск вашей программы", "header_level": 2, "token_count": 101}
{"id": "41639faa118d3359", "text": "## Настройка вашего редактора кода { #configure-your-editor }\n\nСкорее всего, вы будете использовать редактор кода. Убедитесь, что вы настроили его на использование того же виртуального окружения, которое вы создали (обычно он определяет его автоматически), чтобы получить автозавершение и подсветку ошибок.\n\nНапример:\n\n* <a href=\"https://code.visualstudio.com/docs/python/environments#_select-and-activate-an-environment\" class=\"external-link\" target=\"_blank\">VS Code</a>\n* <a href=\"https://www.jetbrains.com/help/pycharm/creating-virtual-environment.html\" class=\"external-link\" target=\"_blank\">PyCharm</a>\n\n/// tip | Подсказка\n\nОбычно это нужно сделать только **один раз**, при создании виртуального окружения.\n\n///\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 12, "header": "Настройка вашего редактора кода", "header_level": 2, "token_count": 227}
{"id": "d9c5248d89c7aaa6", "text": "## Деактивация виртуального окружения { #deactivate-the-virtual-environment }\n\nКогда закончите работу над проектом, вы можете **деактивировать** виртуальное окружение.\n\n<div class=\"termy\">\n\n```console\n$ deactivate\n```\n\n</div>\n\nТаким образом, при запуске `python` он не будет пытаться запускаться из этого виртуального окружения с установленными там пакетами.\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 13, "header": "Деактивация виртуального окружения", "header_level": 2, "token_count": 127}
{"id": "f9ee8c061a1dea0f", "text": "## Готово к работе { #ready-to-work }\n\nТеперь вы готовы начать работать над своим проектом.\n\n/// tip | Подсказка\n\nХотите понять, что это всё было выше?\n\nПродолжайте читать. \n\n///\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 14, "header": "Готово к работе", "header_level": 2, "token_count": 73}
{"id": "bb196cb146fce096", "text": "## Зачем нужны виртуальные окружения { #why-virtual-environments }\n\nЧтобы работать с FastAPI, вам нужно установить <a href=\"https://www.python.org/\" class=\"external-link\" target=\"_blank\">Python</a>.\n\nПосле этого вам нужно будет **установить** FastAPI и другие **пакеты**, которые вы хотите использовать.\n\nДля установки пакетов обычно используют команду `pip`, которая идет вместе с Python (или альтернативные инструменты).\n\nТем не менее, если просто использовать `pip` напрямую, пакеты будут установлены в **глобальное окружение Python** (глобально установленный Python).\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 15, "header": "Зачем нужны виртуальные окружения", "header_level": 2, "token_count": 203}
{"id": "362aab4eacad29ae", "text": "### Проблема { #the-problem }\n\nТак в чём проблема установки пакетов в глобальное окружение Python?\n\nСо временем вы, вероятно, будете писать много разных программ, зависящих от **разных пакетов**. И некоторые из ваших проектов будут зависеть от **разных версий** одного и того же пакета. \n\nНапример, вы можете создать проект `philosophers-stone`, который зависит от пакета **`harry` версии `1`**. Значит, нужно установить `harry`.\n\n```mermaid\nflowchart LR\n    stone(philosophers-stone) -->|requires| harry-1[harry v1]\n```\n\nЗатем вы создаёте другой проект `prisoner-of-azkaban`, который тоже зависит от `harry`, но ему нужен **`harry` версии `3`**.\n\n```mermaid\nflowchart LR\n    azkaban(prisoner-of-azkaban) --> |requires| harry-3[harry v3]\n```\n\nПроблема в том, что если устанавливать пакеты глобально (в глобальное окружение), а не в локальное **виртуальное окружение**, вам придётся выбирать, какую версию `harry` установить.\n\nЕсли вы хотите запустить `philosophers-stone`, сначала нужно установить `harry` версии `1`, например так:\n\n<div class=\"termy\">\n\n```console\n$ pip install \"harry==1\"\n```\n\n</div>\n\nТогда у вас в глобальном окружении Python будет установлен `harry` версии `1`:", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md", "section_header": "Проблема", "section_header_level": 3}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 16, "header": "Проблема", "header_level": 3, "token_count": 465}
{"id": "e745ba043593ad84", "text": "ии `1`, например так:\n\n<div class=\"termy\">\n\n```console\n$ pip install \"harry==1\"\n```\n\n</div>\n\nТогда у вас в глобальном окружении Python будет установлен `harry` версии `1`:\n\n```mermaid\nflowchart LR\n    subgraph global[global env]\n        harry-1[harry v1]\n    end\n    subgraph stone-project[philosophers-stone project]\n        stone(philosophers-stone) -->|requires| harry-1\n    end\n```\n\nНо если затем вы захотите запустить `prisoner-of-azkaban`, вам нужно будет удалить `harry` версии `1` и установить `harry` версии `3` (или просто установка версии `3` автоматически удалит версию `1`).\n\n<div class=\"termy\">\n\n```console\n$ pip install \"harry==3\"\n```\n\n</div>\n\nВ итоге у вас будет установлен `harry` версии `3` в глобальном окружении Python.\n\nА если вы снова попробуете запустить `philosophers-stone`, есть шанс, что он **не будет работать**, так как ему нужен `harry` версии `1`.\n\n```mermaid\nflowchart LR\n    subgraph global[global env]\n        harry-1[<strike>harry v1</strike>]\n        style harry-1 fill:#ccc,stroke-dasharray: 5 5\n        harry-3[harry v3]\n    end\n    subgraph stone-project[philosophers-stone project]\n        stone(philosophers-stone) -.-x|⛔️| harry-1\n    end\n    subgraph azkaban-project[prisoner-of-azkaban project]\n        azkaban(prisoner-of-azkaban) --> |requires| harry-3\n    end\n```\n\n/// tip | Подсказка", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md", "section_header": "Проблема", "section_header_level": 3}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 17, "header": "Проблема", "header_level": 3, "token_count": 478}
{"id": "898ec3268a9e0efa", "text": "��️| harry-1\n    end\n    subgraph azkaban-project[prisoner-of-azkaban project]\n        azkaban(prisoner-of-azkaban) --> |requires| harry-3\n    end\n```\n\n/// tip | Подсказка\n\nВ Python-пакетах часто стараются изо всех сил **избегать ломающих изменений** в **новых версиях**, но лучше действовать осторожно: устанавливать новые версии осознанно и тогда, когда вы можете прогнать тесты и убедиться, что всё работает корректно.\n\n///\n\nТеперь представьте то же самое с **многими** другими **пакетами**, от которых зависят все ваши **проекты**. Этим очень сложно управлять. И вы, скорее всего, в какой‑то момент будете запускать проекты с **несовместимыми версиями** пакетов и не понимать, почему что‑то не работает.\n\nКроме того, в зависимости от ОС (например, Linux, Windows, macOS), она может поставляться с уже установленным Python. И тогда, вероятно, в системе уже есть предустановленные пакеты определённых версий, **нужные вашей системе**. Если вы устанавливаете пакеты в глобальное окружение Python, вы можете в итоге **сломать** некоторые системные программы.", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md", "section_header": "Проблема", "section_header_level": 3}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 18, "header": "Проблема", "header_level": 3, "token_count": 431}
{"id": "bab08a8892ee31c4", "text": "## Куда устанавливаются пакеты { #where-are-packages-installed }\n\nКогда вы устанавливаете Python, на вашем компьютере создаются некоторые директории с файлами.\n\nЧасть этих директорий отвечает за хранение всех устанавливаемых вами пакетов.\n\nКогда вы запускаете:\n\n<div class=\"termy\">\n\n```console\n// Не запускайте это сейчас, это просто пример 🤓\n$ pip install \"fastapi[standard]\"\n---> 100%\n```\n\n</div>\n\nБудет загружен сжатый файл с кодом FastAPI, обычно с <a href=\"https://pypi.org/project/fastapi/\" class=\"external-link\" target=\"_blank\">PyPI</a>.\n\nТакже будут **загружены** файлы для других пакетов, от которых зависит FastAPI.\n\nЗатем все эти файлы будут **распакованы** и помещены в директорию на вашем компьютере.\n\nПо умолчанию они попадут в директорию из вашей установки Python — это **глобальное окружение**.\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 19, "header": "Куда устанавливаются пакеты", "header_level": 2, "token_count": 317}
{"id": "f93a93374537399b", "text": "## Что такое виртуальные окружения { #what-are-virtual-environments }\n\nРешение проблемы с пакетами в глобальном окружении — использовать **виртуальное окружение для каждого проекта**, над которым вы работаете.\n\nВиртуальное окружение — это **директория**, очень похожая на глобальную, куда вы можете устанавливать пакеты для конкретного проекта.\n\nТаким образом, у каждого проекта будет своё виртуальное окружение (директория `.venv`) со своими пакетами.\n\n```mermaid\nflowchart TB\n    subgraph stone-project[philosophers-stone project]\n        stone(philosophers-stone) --->|requires| harry-1\n        subgraph venv1[.venv]\n            harry-1[harry v1]\n        end\n    end\n    subgraph azkaban-project[prisoner-of-azkaban project]\n        azkaban(prisoner-of-azkaban) --->|requires| harry-3\n        subgraph venv2[.venv]\n            harry-3[harry v3]\n        end\n    end\n    stone-project ~~~ azkaban-project\n```\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 20, "header": "Что такое виртуальные окружения", "header_level": 2, "token_count": 323}
{"id": "362aab4eacad29ae", "text": "## Что означает активация виртуального окружения { #what-does-activating-a-virtual-environment-mean }\n\nКогда вы активируете виртуальное окружение, например так:\n\n//// tab | Linux, macOS\n\n<div class=\"termy\">\n\n```console\n$ source .venv/bin/activate\n```\n\n</div>\n\n////\n\n//// tab | Windows PowerShell\n\n<div class=\"termy\">\n\n```console\n$ .venv\\Scripts\\Activate.ps1\n```\n\n</div>\n\n////\n\n//// tab | Windows Bash\n\nИли если вы используете Bash для Windows (например, <a href=\"https://gitforwindows.org/\" class=\"external-link\" target=\"_blank\">Git Bash</a>):\n\n<div class=\"termy\">\n\n```console\n$ source .venv/Scripts/activate\n```\n\n</div>\n\n////\n\nЭта команда создаст или изменит некоторые [переменные окружения](environment-variables.md){.internal-link target=_blank}, которые будут доступны для следующих команд.\n\nОдна из таких переменных — `PATH`.\n\n/// tip | Подсказка\n\nВы можете узнать больше о переменной окружения `PATH` в разделе [Переменные окружения](environment-variables.md#path-environment-variable){.internal-link target=_blank}.\n\n///\n\nАктивация виртуального окружения добавляет его путь `.venv/bin` (на Linux и macOS) или `.venv\\Scripts` (на Windows) в переменную окружения `PATH`.\n\nПредположим, что до активации окружения переменная `PATH` выглядела так:\n\n//// tab | Linux, macOS\n\n```plaintext\n/usr/bin:/bin:/usr/sbin:/sbin\n```\n\nЭто означает, что система будет искать программы в:\n\n* `/usr/bin`\n* `/bin`\n* `/usr/sbin`\n* `/sbin`\n\n////\n\n//// tab | Windows\n\n```plaintext\nC:\\Windows\\System32\n```\n\nЭто означает, что система будет искать программы в:\n\n* `C:\\Windows\\System32`\n\n////", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md", "section_header": "Что означает активация виртуального окружения", "section_header_level": 2}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 21, "header": "Что означает активация виртуального окружения", "header_level": 2, "token_count": 504}
{"id": "e745ba043593ad84", "text": "* `/usr/bin`\n* `/bin`\n* `/usr/sbin`\n* `/sbin`\n\n////\n\n//// tab | Windows\n\n```plaintext\nC:\\Windows\\System32\n```\n\nЭто означает, что система будет искать программы в:\n\n* `C:\\Windows\\System32`\n\n////\n\nПосле активации виртуального окружения переменная `PATH` будет выглядеть примерно так:\n\n//// tab | Linux, macOS\n\n```plaintext\n/home/user/code/awesome-project/.venv/bin:/usr/bin:/bin:/usr/sbin:/sbin\n```\n\nЭто означает, что теперь система в первую очередь будет искать программы в:\n\n```plaintext\n/home/user/code/awesome-project/.venv/bin\n```\n\nпрежде чем искать в других директориях.\n\nПоэтому, когда вы введёте в терминале `python`, система найдёт программу Python по пути\n\n```plaintext\n/home/user/code/awesome-project/.venv/bin/python\n```\n\nи использует именно её.\n\n////\n\n//// tab | Windows\n\n```plaintext\nC:\\Users\\user\\code\\awesome-project\\.venv\\Scripts;C:\\Windows\\System32\n```\n\nЭто означает, что теперь система в первую очередь будет искать программы в:\n\n```plaintext\nC:\\Users\\user\\code\\awesome-project\\.venv\\Scripts\n```\n\nпрежде чем искать в других директориях.\n\nПоэтому, когда вы введёте в терминале `python`, система найдёт программу Python по пути\n\n```plaintext\nC:\\Users\\user\\code\\awesome-project\\.venv\\Scripts\\python\n```\n\nи использует именно её.\n\n////", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md", "section_header": "Что означает активация виртуального окружения", "section_header_level": 2}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 22, "header": "Что означает активация виртуального окружения", "header_level": 2, "token_count": 430}
{"id": "898ec3268a9e0efa", "text": "огда вы введёте в терминале `python`, система найдёт программу Python по пути\n\n```plaintext\nC:\\Users\\user\\code\\awesome-project\\.venv\\Scripts\\python\n```\n\nи использует именно её.\n\n////\n\nВажная деталь: путь к виртуальному окружению будет добавлен в самое **начало** переменной `PATH`. Система найдёт его **раньше**, чем любой другой установленный Python. Таким образом, при запуске `python` будет использоваться Python **из виртуального окружения**, а не какой‑то другой `python` (например, из глобального окружения).\n\nАктивация виртуального окружения также меняет ещё несколько вещей, но это — одна из важнейших.", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md", "section_header": "Что означает активация виртуального окружения", "section_header_level": 2}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 23, "header": "Что означает активация виртуального окружения", "header_level": 2, "token_count": 226}
{"id": "d420f8e36295cb53", "text": "## Проверка виртуального окружения { #checking-a-virtual-environment }\n\nКогда вы проверяете, активно ли виртуальное окружение, например, так:\n\n//// tab | Linux, macOS, Windows Bash\n\n<div class=\"termy\">\n\n```console\n$ which python\n\n/home/user/code/awesome-project/.venv/bin/python\n```\n\n</div>\n\n////\n\n//// tab | Windows PowerShell\n\n<div class=\"termy\">\n\n```console\n$ Get-Command python\n\nC:\\Users\\user\\code\\awesome-project\\.venv\\Scripts\\python\n```\n\n</div>\n\n////\n\nЭто означает, что будет использоваться программа `python` **из виртуального окружения**.\n\nНа Linux и macOS используется `which`, а в Windows PowerShell — `Get-Command`.\n\nКак работает эта команда: она проходит по переменной окружения `PATH`, идя **по каждому пути по порядку**, и ищет программу с именем `python`. Как только находит — **показывает путь** к этой программе.\n\nСамое важное — при вызове `python` именно этот «`python`» и будет выполняться.\n\nТак вы можете подтвердить, что находитесь в правильном виртуальном окружении.\n\n/// tip | Подсказка\n\nЛегко активировать одно виртуальное окружение, получить один Python, а затем **перейти к другому проекту**.\n\nИ второй проект **не будет работать**, потому что вы используете **не тот Python**, из виртуального окружения другого проекта.\n\nПолезно уметь проверить, какой именно `python` используется. \n\n///\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 24, "header": "Проверка виртуального окружения", "header_level": 2, "token_count": 442}
{"id": "362aab4eacad29ae", "text": "## Зачем деактивировать виртуальное окружение { #why-deactivate-a-virtual-environment }\n\nНапример, вы работаете над проектом `philosophers-stone`, **активируете виртуальное окружение**, устанавливаете пакеты и работаете с ним.\n\nЗатем вы хотите поработать над **другим проектом** `prisoner-of-azkaban`.\n\nВы переходите в этот проект:\n\n<div class=\"termy\">\n\n```console\n$ cd ~/code/prisoner-of-azkaban\n```\n\n</div>\n\nЕсли вы не деактивируете виртуальное окружение `philosophers-stone`, при запуске `python` в терминале он попытается использовать Python из `philosophers-stone`.\n\n<div class=\"termy\">\n\n```console\n$ cd ~/code/prisoner-of-azkaban\n\n$ python main.py\n\n// Error importing sirius, it's not installed 😱\nTraceback (most recent call last):\n    File \"main.py\", line 1, in <module>\n        import sirius\n```\n\n</div>\n\nНо если вы деактивируете виртуальное окружение и активируете новое для `prisoner-of-askaban`, тогда при запуске `python` он будет использовать Python из виртуального окружения `prisoner-of-azkaban`.\n\n<div class=\"termy\">\n\n```console\n$ cd ~/code/prisoner-of-azkaban\n\n// Вам не нужно находиться в старой директории, чтобы деактивировать окружение, вы можете сделать это где угодно, даже после перехода в другой проект 😎\n$ deactivate\n\n// Активируйте виртуальное окружение в prisoner-of-azkaban/.venv 🚀\n$ source .venv/bin/activate", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md", "section_header": "Зачем деактивировать виртуальное окружение", "section_header_level": 2}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 25, "header": "Зачем деактивировать виртуальное окружение", "header_level": 2, "token_count": 483}
{"id": "e745ba043593ad84", "text": "годно, даже после перехода в другой проект 😎\n$ deactivate\n\n// Активируйте виртуальное окружение в prisoner-of-azkaban/.venv 🚀\n$ source .venv/bin/activate\n\n// Теперь при запуске python он найдёт пакет sirius, установленный в этом виртуальном окружении ✨\n$ python main.py\n\nI solemnly swear 🐺\n```\n\n</div>", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md", "section_header": "Зачем деактивировать виртуальное окружение", "section_header_level": 2}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 26, "header": "Зачем деактивировать виртуальное окружение", "header_level": 2, "token_count": 121}
{"id": "faecfa0950c13c43", "text": "## Альтернативы { #alternatives }\n\nЭто простое руководство, чтобы вы начали и поняли, как всё работает **под капотом**.\n\nСуществует много **альтернатив** для управления виртуальными окружениями, зависимостями (requirements), проектами.\n\nКогда вы будете готовы и захотите использовать инструмент для **управления всем проектом** — зависимостями пакетов, виртуальными окружениями и т. п., я бы предложил попробовать <a href=\"https://github.com/astral-sh/uv\" class=\"external-link\" target=\"_blank\">uv</a>.\n\n`uv` может многое:\n\n* **Устанавливать Python**, включая разные версии\n* Управлять **виртуальным окружением** ваших проектов\n* Устанавливать **пакеты**\n* Управлять **зависимостями и версиями** пакетов вашего проекта\n* Обеспечивать наличие **точного** набора пакетов и версий к установке, включая их зависимости, чтобы вы были уверены, что сможете запускать проект в продакшн точно так же, как и на компьютере при разработке — это называется **locking**\n* И многое другое\n\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 27, "header": "Альтернативы", "header_level": 2, "token_count": 383}
{"id": "afa05ef14e34f5fd", "text": "## Заключение { #conclusion }\n\nЕсли вы прочитали и поняли всё это, теперь **вы знаете гораздо больше** о виртуальных окружениях, чем многие разработчики. \n\nЗнание этих деталей, скорее всего, пригодится вам в будущем, когда вы будете отлаживать что‑то сложное: вы будете понимать, **как всё работает под капотом**.\n", "metadata": {"title": "Виртуальные окружения", "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "source_mtime": "2026-01-12T17:48:12.918193+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\virtual-environments.md"}, "doc_id": "43c7be2b3715", "source_path": "docs\\virtual-environments.md", "title": "Виртуальные окружения", "chunk_index": 28, "header": "Заключение", "header_level": 2, "token_count": 138}
{"id": "f87e0b805ade1488", "text": "# Тестовый файл LLM { #llm-test-file }\n\nЭтот документ проверяет, понимает ли <abbr title=\"Large Language Model – Большая языковая модель\">LLM</abbr>, переводящая документацию, `general_prompt` в `scripts/translate.py` и языковой специфичный промпт в `docs/{language code}/llm-prompt.md`. Языковой специфичный промпт добавляется к `general_prompt`.\n\nТесты, добавленные здесь, увидят все создатели языковых промптов.\n\nИспользование:", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md", "section_header": "Тестовый файл LLM", "section_header_level": 1}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 0, "header": "Тестовый файл LLM", "header_level": 1, "token_count": 164}
{"id": "2488a2c73eda152d", "text": "m-prompt.md`. Языковой специфичный промпт добавляется к `general_prompt`.\n\nТесты, добавленные здесь, увидят все создатели языковых промптов.\n\nИспользование:\n\n* Подготовьте языковой специфичный промпт — `docs/{language code}/llm-prompt.md`.\n* Выполните новый перевод этого документа на нужный целевой язык (см., например, команду `translate-page` в `translate.py`). Это создаст перевод в `docs/{language code}/docs/_llm-test.md`.\n* Проверьте, всё ли в порядке в переводе.\n* При необходимости улучшите ваш языковой специфичный промпт, общий промпт или английский документ.\n* Затем вручную исправьте оставшиеся проблемы в переводе, чтобы он был хорошим.\n* Переведите заново, имея хороший перевод на месте. Идеальным результатом будет ситуация, когда LLM больше не вносит изменений в перевод. Это означает, что общий промпт и ваш языковой специфичный промпт максимально хороши (иногда он будет делать несколько, казалось бы, случайных изменений, причина в том, что <a href=\"https://doublespeak.chat/#/handbook#deterministic-output\" class=\"external-link\" target=\"_blank\">LLM — недетерминированные алгоритмы</a>).\n\nТесты:", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md", "section_header": "Тестовый файл LLM", "section_header_level": 1}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 1, "header": "Тестовый файл LLM", "header_level": 1, "token_count": 456}
{"id": "f6f77bac84ddfb25", "text": "## Фрагменты кода { #code-snippets }\n\n//// tab | Тест\n\nЭто фрагмент кода: `foo`. А это ещё один фрагмент кода: `bar`. И ещё один: `baz quux`.\n\n////\n\n//// tab | Информация\n\nСодержимое фрагментов кода должно оставаться как есть.\n\nСм. раздел `### Content of code snippets` в общем промпте в `scripts/translate.py`.\n\n////\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 2, "header": "Фрагменты кода", "header_level": 2, "token_count": 119}
{"id": "7c8728517bb0a845", "text": "## Кавычки { #quotes }\n\n//// tab | Тест\n\nВчера мой друг написал: \"Если вы написали incorrectly правильно, значит вы написали это неправильно\". На что я ответил: \"Верно, но 'incorrectly' — это неправильно, а не '\"incorrectly\"'\".\n\n/// note | Примечание\n\nLLM, вероятно, переведёт это неправильно. Интересно лишь то, сохранит ли она фиксированный перевод при повторном переводе.\n\n///\n\n////\n\n//// tab | Информация\n\nАвтор промпта может выбрать, хочет ли он преобразовывать нейтральные кавычки в типографские. Допускается оставить их как есть.\n\nСм., например, раздел `### Quotes` в `docs/de/llm-prompt.md`.\n\n////\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 3, "header": "Кавычки", "header_level": 2, "token_count": 238}
{"id": "f530ac4247114fc2", "text": "## Кавычки во фрагментах кода { #quotes-in-code-snippets }\n\n//// tab | Тест\n\n`pip install \"foo[bar]\"`\n\nПримеры строковых литералов во фрагментах кода: `\"this\"`, `'that'`.\n\nСложный пример строковых литералов во фрагментах кода: `f\"I like {'oranges' if orange else \"apples\"}\"`\n\nХардкор: `Yesterday, my friend wrote: \"If you spell incorrectly correctly, you have spelled it incorrectly\". To which I answered: \"Correct, but 'incorrectly' is incorrectly not '\"incorrectly\"'\"`\n\n////\n\n//// tab | Информация\n\n... Однако кавычки внутри фрагментов кода должны оставаться как есть.\n\n////\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 4, "header": "Кавычки во фрагментах кода", "header_level": 2, "token_count": 200}
{"id": "5f594cc34f0e8190", "text": "## Блоки кода { #code-blocks }\n\n//// tab | Тест\n\nПример кода Bash...\n\n```bash\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 5, "header": "Блоки кода", "header_level": 2, "token_count": 28}
{"id": "c5d60ff03e860110", "text": "# Вывести приветствие вселенной\necho \"Hello universe\"\n```\n\n...и пример вывода в консоли...\n\n```console\n$ <font color=\"#4E9A06\">fastapi</font> run <u style=\"text-decoration-style:solid\">main.py</u>\n<span style=\"background-color:#009485\"><font color=\"#D3D7CF\"> FastAPI </font></span>  Starting server\n        Searching for package file structure\n```\n\n...и ещё один пример вывода в консоли...\n\n```console\n// Создать директорию \"Code\"\n$ mkdir code\n// Перейти в эту директорию\n$ cd code\n```\n\n...и пример кода на Python...\n\n```Python\nwont_work()  # Это не сработает 😱\nworks(foo=\"bar\")  # Это работает 🎉\n```\n\n...и на этом всё.\n\n////\n\n//// tab | Информация\n\nКод в блоках кода не должен изменяться, за исключением комментариев.\n\nСм. раздел `### Content of code blocks` в общем промпте в `scripts/translate.py`.\n\n////\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 6, "header": "Вывести приветствие вселенной", "header_level": 1, "token_count": 281}
{"id": "55a0910275236dac", "text": "## Вкладки и цветные блоки { #tabs-and-colored-boxes }\n\n//// tab | Тест\n\n/// info | Информация\nНекоторый текст\n///\n\n/// note | Примечание\nНекоторый текст\n///\n\n/// note | Технические подробности\nНекоторый текст\n///\n\n/// check | Проверка\nНекоторый текст\n///\n\n/// tip | Совет\nНекоторый текст\n///\n\n/// warning | Предупреждение\nНекоторый текст\n///\n\n/// danger | Опасность\nНекоторый текст\n///\n\n////\n\n//// tab | Информация\n\nДля вкладок и блоков `Info`/`Note`/`Warning`/и т.п. нужно добавить перевод их заголовка после вертикальной черты (`|`).\n\nСм. разделы `### Special blocks` и `### Tab blocks` в общем промпте в `scripts/translate.py`.\n\n////\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 7, "header": "Вкладки и цветные блоки", "header_level": 2, "token_count": 235}
{"id": "63b53676a97ad53c", "text": "## Веб- и внутренние ссылки { #web-and-internal-links }\n\n//// tab | Тест\n\nТекст ссылок должен переводиться, адрес ссылки не должен изменяться:\n\n* [Ссылка на заголовок выше](#code-snippets)\n* [Внутренняя ссылка](index.md#installation){.internal-link target=_blank}\n* <a href=\"https://sqlmodel.tiangolo.com/\" class=\"external-link\" target=\"_blank\">Внешняя ссылка</a>\n* <a href=\"https://fastapi.tiangolo.com/css/styles.css\" class=\"external-link\" target=\"_blank\">Ссылка на стиль</a>\n* <a href=\"https://fastapi.tiangolo.com/js/logic.js\" class=\"external-link\" target=\"_blank\">Ссылка на скрипт</a>\n* <a href=\"https://fastapi.tiangolo.com/img/foo.jpg\" class=\"external-link\" target=\"_blank\">Ссылка на изображение</a>\n\nТекст ссылок должен переводиться, адрес ссылки должен указывать на перевод:\n\n* <a href=\"https://fastapi.tiangolo.com/ru/\" class=\"external-link\" target=\"_blank\">Ссылка на FastAPI</a>\n\n////\n\n//// tab | Информация\n\nСсылки должны переводиться, но их адреса не должны изменяться. Исключение — абсолютные ссылки на страницы документации FastAPI. В этом случае ссылка должна вести на перевод.\n\nСм. раздел `### Links` в общем промпте в `scripts/translate.py`.\n\n////\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 8, "header": "Веб- и внутренние ссылки", "header_level": 2, "token_count": 393}
{"id": "38f835f79afb0d02", "text": "## HTML-элементы \"abbr\" { #html-abbr-elements }\n\n//// tab | Тест\n\nВот некоторые элементы, обёрнутые в HTML-элементы \"abbr\" (часть выдумана):\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 9, "header": "HTML-элементы \"abbr\"", "header_level": 2, "token_count": 56}
{"id": "adf4b85783348593", "text": "### abbr даёт полную расшифровку { #the-abbr-gives-a-full-phrase }\n\n* <abbr title=\"Getting Things Done – Как привести дела в порядок\">GTD</abbr>\n* <abbr title=\"less than – меньше чем\"><code>lt</code></abbr>\n* <abbr title=\"XML Web Token – XML веб‑токен\">XWT</abbr>\n* <abbr title=\"Parallel Server Gateway Interface – Параллельный серверный интерфейс шлюза\">PSGI</abbr>\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 10, "header": "abbr даёт полную расшифровку", "header_level": 3, "token_count": 127}
{"id": "d017cdcc1fdc340c", "text": "### abbr даёт объяснение { #the-abbr-gives-an-explanation }\n\n* <abbr title=\"Группа машин, которые настроены на соединение и совместную работу определённым образом.\">кластер</abbr>\n* <abbr title=\"Метод машинного обучения, который использует искусственные нейронные сети с многочисленными скрытыми слоями между входным и выходным слоями, тем самым формируя сложную внутреннюю структуру\">Глубокое обучение</abbr>\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 11, "header": "abbr даёт объяснение", "header_level": 3, "token_count": 172}
{"id": "88a11dbd0facc260", "text": "### abbr даёт полную расшифровку и объяснение { #the-abbr-gives-a-full-phrase-and-an-explanation }\n\n* <abbr title=\"Mozilla Developer Network – Сеть разработчиков Mozilla: документация для разработчиков, созданная командой Firefox\">MDN</abbr>\n* <abbr title=\"Input/Output – Ввод/Вывод: чтение или запись на диск, сетевое взаимодействие.\">I/O</abbr>.\n\n////\n\n//// tab | Информация\n\nАтрибуты \"title\" элементов \"abbr\" переводятся по определённым правилам.\n\nПереводы могут добавлять свои собственные элементы \"abbr\", которые LLM не должна удалять. Например, чтобы объяснить английские слова.\n\nСм. раздел `### HTML abbr elements` в общем промпте в `scripts/translate.py`.\n\n////\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 12, "header": "abbr даёт полную расшифровку и объяснение", "header_level": 3, "token_count": 245}
{"id": "db3c09e0f6ede2b5", "text": "## Заголовки { #headings }\n\n//// tab | Тест\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 13, "header": "Заголовки", "header_level": 2, "token_count": 16}
{"id": "cabcbd4babf9ff4d", "text": "### Разработка веб‑приложения — руководство { #develop-a-webapp-a-tutorial }\n\nПривет.\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 14, "header": "Разработка веб‑приложения — руководство", "header_level": 3, "token_count": 33}
{"id": "2d4958a47c61c571", "text": "### Аннотации типов и -аннотации { #type-hints-and-annotations }\n\nСнова привет.\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 15, "header": "Аннотации типов и -аннотации", "header_level": 3, "token_count": 30}
{"id": "1f05215064a17b17", "text": "### Супер- и подклассы { #super-and-subclasses }\n\nСнова привет.\n\n////\n\n//// tab | Информация\n\nЕдинственное жёсткое правило для заголовков — LLM должна оставить часть хеша в фигурных скобках без изменений, чтобы ссылки не ломались.\n\nСм. раздел `### Headings` в общем промпте в `scripts/translate.py`.\n\nДля некоторых языковых инструкций см., например, раздел `### Headings` в `docs/de/llm-prompt.md`.\n\n////\n\n", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md"}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 16, "header": "Супер- и подклассы", "header_level": 3, "token_count": 156}
{"id": "f87e0b805ade1488", "text": "## Термины, используемые в документации { #terms-used-in-the-docs }\n\n//// tab | Тест\n\n* вы\n* ваш\n\n* например\n* и т.д.\n\n* `foo` как `int`\n* `bar` как `str`\n* `baz` как `list`\n\n* Учебник — Руководство пользователя\n* Расширенное руководство пользователя\n* Документация по SQLModel\n* Документация API\n* Автоматическая документация\n\n* Наука о данных\n* Глубокое обучение\n* Машинное обучение\n* Внедрение зависимостей\n* Аутентификация HTTP Basic\n* HTTP Digest\n* формат ISO\n* стандарт JSON Schema\n* JSON-схема\n* определение схемы\n* password flow\n* Мобильный\n\n* устаревший\n* спроектированный\n* некорректный\n* на лету\n* стандарт\n* по умолчанию\n* чувствительный к регистру\n* нечувствительный к регистру\n\n* обслуживать приложение\n* отдавать страницу\n\n* приложение\n* приложение\n\n* HTTP-запрос\n* HTTP-ответ\n* ответ с ошибкой\n\n* операция пути\n* декоратор операции пути\n* функция-обработчик пути\n\n* тело\n* тело запроса\n* тело ответа\n* JSON-тело\n* тело формы\n* тело файла\n* тело функции\n\n* параметр\n* body-параметр\n* path-параметр\n* query-параметр\n* cookie-параметр\n* параметр заголовка\n* параметр формы\n* параметр функции\n\n* событие\n* событие запуска\n* запуск сервера\n* событие остановки\n* событие lifespan", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md", "section_header": "Термины, используемые в документации", "section_header_level": 2}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 17, "header": "Термины, используемые в документации", "header_level": 2, "token_count": 494}
{"id": "2488a2c73eda152d", "text": "параметр\n* cookie-параметр\n* параметр заголовка\n* параметр формы\n* параметр функции\n\n* событие\n* событие запуска\n* запуск сервера\n* событие остановки\n* событие lifespan\n\n* обработчик\n* обработчик события\n* обработчик исключений\n* обрабатывать\n\n* модель\n* Pydantic-модель\n* модель данных\n* модель базы данных\n* модель формы\n* объект модели\n\n* класс\n* базовый класс\n* родительский класс\n* подкласс\n* дочерний класс\n* родственный класс\n* метод класса\n\n* заголовок\n* HTTP-заголовки\n* заголовок авторизации\n* заголовок `Authorization`\n* заголовок `Forwarded`\n\n* система внедрения зависимостей\n* зависимость\n* зависимый объект\n* зависимый\n\n* ограниченный вводом/выводом\n* ограниченный процессором\n* конкурентность\n* параллелизм\n* многопроцессность\n\n* переменная окружения\n* переменная окружения\n* `PATH`\n* переменная `PATH`\n\n* аутентификация\n* провайдер аутентификации\n* авторизация\n* форма авторизации\n* провайдер авторизации\n* пользователь аутентифицируется\n* система аутентифицирует пользователя\n\n* CLI\n* интерфейс командной строки\n\n* сервер\n* клиент\n\n* облачный провайдер\n* облачный сервис\n\n* разработка\n* этапы разработки\n\n* dict\n* словарь\n* перечисление\n* enum\n* член перечисления\n\n* кодировщик\n* декодировщик\n* кодировать\n* декодировать\n\n* исключение\n* вызвать", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md", "section_header": "Термины, используемые в документации", "section_header_level": 2}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 18, "header": "Термины, используемые в документации", "header_level": 2, "token_count": 509}
{"id": "f6f77bac84ddfb25", "text": "ки\n\n* dict\n* словарь\n* перечисление\n* enum\n* член перечисления\n\n* кодировщик\n* декодировщик\n* кодировать\n* декодировать\n\n* исключение\n* вызвать\n\n* выражение\n* оператор\n\n* фронтенд\n* бэкенд\n\n* обсуждение на GitHub\n* Issue на GitHub (тикет/обращение)\n\n* производительность\n* оптимизация производительности\n\n* тип возвращаемого значения\n* возвращаемое значение\n\n* безопасность\n* схема безопасности\n\n* задача\n* фоновая задача\n* функция задачи\n\n* шаблон\n* шаблонизатор\n\n* аннотация типов\n* аннотация типов\n\n* воркер сервера\n* воркер Uvicorn\n* воркер Gunicorn\n* воркер-процесс\n* класс воркера\n* рабочая нагрузка\n\n* деплой\n* развернуть\n\n* SDK\n* набор средств разработки ПО", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md", "section_header": "Термины, используемые в документации", "section_header_level": 2}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 19, "header": "Термины, используемые в документации", "header_level": 2, "token_count": 294}
{"id": "7c8728517bb0a845", "text": "воркер Gunicorn\n* воркер-процесс\n* класс воркера\n* рабочая нагрузка\n\n* деплой\n* развернуть\n\n* SDK\n* набор средств разработки ПО\n\n* `APIRouter`\n* `requirements.txt`\n* токен Bearer\n* несовместимое изменение\n* баг\n* кнопка\n* вызываемый объект\n* код\n* коммит\n* менеджер контекста\n* корутина\n* сессия базы данных\n* диск\n* домен\n* движок\n* фиктивный X\n* метод HTTP GET\n* элемент\n* библиотека\n* lifespan\n* блокировка\n* middleware (Промежуточный слой)\n* мобильное приложение\n* модуль\n* монтирование\n* сеть\n* origin (источник)\n* переопределение\n* полезная нагрузка\n* процессор\n* свойство\n* прокси\n* пулл-реквест (запрос на изменение)\n* запрос\n* ОЗУ\n* удалённая машина\n* статус-код\n* строка\n* тег\n* веб‑фреймворк\n* подстановочный знак\n* вернуть\n* валидировать\n\n////\n\n//// tab | Информация", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md", "section_header": "Термины, используемые в документации", "section_header_level": 2}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 20, "header": "Термины, используемые в документации", "header_level": 2, "token_count": 359}
{"id": "f530ac4247114fc2", "text": "машина\n* статус-код\n* строка\n* тег\n* веб‑фреймворк\n* подстановочный знак\n* вернуть\n* валидировать\n\n////\n\n//// tab | Информация\n\nЭто неполный и ненормативный список (в основном) технических терминов, встречающихся в документации. Он может помочь автору промпта понять, по каким терминам LLM нужна подсказка. Например, когда она продолжает возвращать действительно хороший перевод к неоптимальному. Или когда у неё возникают проблемы со склонением/спряжением термина на вашем языке.\n\nСм., например, раздел `### List of English terms and their preferred German translations` в `docs/de/llm-prompt.md`.\n\n////", "metadata": {"title": "Тестовый файл LLM", "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "source_mtime": "2026-01-12T17:48:12.833052+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\_llm-test.md", "section_header": "Термины, используемые в документации", "section_header_level": 2}, "doc_id": "c831aecc5ab4", "source_path": "docs\\_llm-test.md", "title": "Тестовый файл LLM", "chunk_index": 21, "header": "Термины, используемые в документации", "header_level": 2, "token_count": 251}
{"id": "f28d747afcf5982b", "text": "# О проекте { #about }\n\nО FastAPI, его дизайне, источниках вдохновения и многом другом.\n", "metadata": {"title": "О проекте", "doc_id": "0593dd4ec825", "source_path": "docs\\about\\index.md", "source_mtime": "2026-01-12T17:48:12.929148+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\about\\index.md"}, "doc_id": "0593dd4ec825", "source_path": "docs\\about\\index.md", "title": "О проекте", "chunk_index": 0, "header": "О проекте", "header_level": 1, "token_count": 38}
{"id": "7b2f8d1e9898bece", "text": "# Дополнительные ответы в OpenAPI { #additional-responses-in-openapi }\n\n/// warning | Предупреждение\n\nЭто довольно продвинутая тема.\n\nЕсли вы только начинаете работать с **FastAPI**, возможно, вам это пока не нужно.\n\n///\n\nВы можете объявлять дополнительные ответы с дополнительными статус-кодами, типами содержимого, описаниями и т.д.\n\nЭти дополнительные ответы будут включены в схему OpenAPI, и поэтому появятся в документации API.\n\nНо для таких дополнительных ответов убедитесь, что вы возвращаете `Response`, например `JSONResponse`, напрямую, со своим статус-кодом и содержимым.\n\n", "metadata": {"title": "Дополнительные ответы в OpenAPI", "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "source_mtime": "2026-01-12T17:48:12.950342+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\additional-responses.md"}, "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "title": "Дополнительные ответы в OpenAPI", "chunk_index": 0, "header": "Дополнительные ответы в OpenAPI", "header_level": 1, "token_count": 214}
{"id": "7b2f8d1e9898bece", "text": "## Дополнительный ответ с `model` { #additional-response-with-model }\n\nВы можете передать вашим декораторам операции пути параметр `responses`.\n\nОн принимает `dict`: ключи — это статус-коды для каждого ответа (например, `200`), а значения — другие `dict` с информацией для каждого из них.\n\nКаждый из этих `dict` для ответа может иметь ключ `model`, содержащий Pydantic-модель, аналогично `response_model`.\n\n**FastAPI** возьмёт эту модель, сгенерирует для неё JSON‑схему и включит её в нужное место в OpenAPI.\n\nНапример, чтобы объявить ещё один ответ со статус-кодом `404` и Pydantic-моделью `Message`, можно написать:\n\n{* ../../docs_src/additional_responses/tutorial001_py39.py hl[18,22] *}\n\n/// note | Примечание\n\nИмейте в виду, что необходимо возвращать `JSONResponse` напрямую.\n\n///\n\n/// info | Информация\n\nКлюч `model` не является частью OpenAPI.\n\n**FastAPI** возьмёт Pydantic-модель оттуда, сгенерирует JSON‑схему и поместит её в нужное место.\n\nНужное место:", "metadata": {"title": "Дополнительные ответы в OpenAPI", "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "source_mtime": "2026-01-12T17:48:12.950342+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\additional-responses.md", "section_header": "Дополнительный ответ с `model`", "section_header_level": 2}, "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "title": "Дополнительные ответы в OpenAPI", "chunk_index": 1, "header": "Дополнительный ответ с `model`", "header_level": 2, "token_count": 359}
{"id": "76a38ddd477fcee3", "text": "вляется частью OpenAPI.\n\n**FastAPI** возьмёт Pydantic-модель оттуда, сгенерирует JSON‑схему и поместит её в нужное место.\n\nНужное место:\n\n* В ключе `content`, значением которого является другой JSON‑объект (`dict`), содержащий:\n    * Ключ с типом содержимого, например `application/json`, значением которого является другой JSON‑объект, содержащий:\n        * Ключ `schema`, значением которого является JSON‑схема из модели — вот нужное место.\n            * **FastAPI** добавляет здесь ссылку на глобальные JSON‑схемы в другом месте вашего OpenAPI вместо того, чтобы включать схему напрямую. Так другие приложения и клиенты смогут использовать эти JSON‑схемы напрямую, предоставлять лучшие инструменты генерации кода и т.д.\n\n///\n\nСгенерированные в OpenAPI ответы для этой операции пути будут такими:\n\n```JSON hl_lines=\"3-12\"\n{\n    \"responses\": {\n        \"404\": {\n            \"description\": \"Additional Response\",\n            \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                        \"$ref\": \"#/components/schemas/Message\"\n                    }\n                }\n            }\n        },\n        \"200\": {\n            \"description\": \"Successful Response\",\n            \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                        \"$ref\": \"#/components/schemas/Item\"\n                    }\n                }\n            }\n        },\n        \"422\": {\n            \"description\": \"Validation Error\",\n            \"content\": {\n                \"application/json\": {\n                    \"schema\": {\n                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nСхемы даны как ссылки на другое место внутри схемы OpenAPI:", "metadata": {"title": "Дополнительные ответы в OpenAPI", "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "source_mtime": "2026-01-12T17:48:12.950342+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\additional-responses.md", "section_header": "Дополнительный ответ с `model`", "section_header_level": 2}, "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "title": "Дополнительные ответы в OpenAPI", "chunk_index": 2, "header": "Дополнительный ответ с `model`", "header_level": 2, "token_count": 504}
{"id": "11e8ddb65ef6618f", "text": "{\n                \"application/json\": {\n                    \"schema\": {\n                        \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nСхемы даны как ссылки на другое место внутри схемы OpenAPI:\n\n```JSON hl_lines=\"4-16\"\n{\n    \"components\": {\n        \"schemas\": {\n            \"Message\": {\n                \"title\": \"Message\",\n                \"required\": [\n                    \"message\"\n                ],\n                \"type\": \"object\",\n                \"properties\": {\n                    \"message\": {\n                        \"title\": \"Message\",\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"Item\": {\n                \"title\": \"Item\",\n                \"required\": [\n                    \"id\",\n                    \"value\"\n                ],\n                \"type\": \"object\",\n                \"properties\": {\n                    \"id\": {\n                        \"title\": \"Id\",\n                        \"type\": \"string\"\n                    },\n                    \"value\": {\n                        \"title\": \"Value\",\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"ValidationError\": {\n                \"title\": \"ValidationError\",\n                \"required\": [\n                    \"loc\",\n                    \"msg\",\n                    \"type\"\n                ],\n                \"type\": \"object\",\n                \"properties\": {\n                    \"loc\": {\n                        \"title\": \"Location\",\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"msg\": {\n                        \"title\": \"Message\",\n                        \"type\": \"string\"\n                    },\n                    \"type\": {\n                        \"title\": \"Error Type\",\n                        \"type\": \"string\"\n                    }\n                }\n            },\n            \"HTTPValidationError\": {\n                \"title\": \"HTTPValidationError\",\n                \"type\": \"object\",\n                \"properties\": {\n                    \"detail\": {\n                        \"title\": \"Detail\",\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"$ref\": \"#/components/schemas/ValidationError\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```", "metadata": {"title": "Дополнительные ответы в OpenAPI", "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "source_mtime": "2026-01-12T17:48:12.950342+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\additional-responses.md", "section_header": "Дополнительный ответ с `model`", "section_header_level": 2}, "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "title": "Дополнительные ответы в OpenAPI", "chunk_index": 3, "header": "Дополнительный ответ с `model`", "header_level": 2, "token_count": 430}
{"id": "662bbcd177861cdf", "text": "## Дополнительные типы содержимого для основного ответа { #additional-media-types-for-the-main-response }\n\nВы можете использовать этот же параметр `responses`, чтобы добавить разные типы содержимого для того же основного ответа.\n\nНапример, вы можете добавить дополнительный тип содержимого `image/png`, объявив, что ваша операция пути может возвращать JSON‑объект (с типом содержимого `application/json`) или PNG‑изображение:\n\n{* ../../docs_src/additional_responses/tutorial002_py310.py hl[17:22,26] *}\n\n/// note | Примечание\n\nУчтите, что изображение нужно возвращать напрямую, используя `FileResponse`.\n\n///\n\n/// info | Информация\n\nЕсли вы явно не укажете другой тип содержимого в параметре `responses`, FastAPI будет считать, что ответ имеет тот же тип содержимого, что и основной класс ответа (по умолчанию `application/json`).\n\nНо если вы указали пользовательский класс ответа с `None` в качестве его типа содержимого, FastAPI использует `application/json` для любого дополнительного ответа, у которого есть связанная модель.\n\n///\n\n", "metadata": {"title": "Дополнительные ответы в OpenAPI", "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "source_mtime": "2026-01-12T17:48:12.950342+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\additional-responses.md"}, "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "title": "Дополнительные ответы в OpenAPI", "chunk_index": 4, "header": "Дополнительные типы содержимого для основного ответа", "header_level": 2, "token_count": 318}
{"id": "e6f96a682b18fb84", "text": "## Комбинирование информации { #combining-information }\n\nВы также можете комбинировать информацию об ответах из нескольких мест, включая параметры `response_model`, `status_code` и `responses`.\n\nВы можете объявить `response_model`, используя статус-код по умолчанию `200` (или свой, если нужно), а затем объявить дополнительную информацию для этого же ответа в `responses`, напрямую в схеме OpenAPI.\n\n**FastAPI** сохранит дополнительную информацию из `responses` и объединит её с JSON‑схемой из вашей модели.\n\nНапример, вы можете объявить ответ со статус-кодом `404`, который использует Pydantic-модель и имеет пользовательское `description`.\n\nА также ответ со статус-кодом `200`, который использует ваш `response_model`, но включает пользовательский `example`:\n\n{* ../../docs_src/additional_responses/tutorial003_py39.py hl[20:31] *}\n\nВсё это будет объединено и включено в ваш OpenAPI и отображено в документации API:\n\n<img src=\"/img/tutorial/additional-responses/image01.png\">\n\n", "metadata": {"title": "Дополнительные ответы в OpenAPI", "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "source_mtime": "2026-01-12T17:48:12.950342+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\additional-responses.md"}, "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "title": "Дополнительные ответы в OpenAPI", "chunk_index": 5, "header": "Комбинирование информации", "header_level": 2, "token_count": 315}
{"id": "d2f3a2191052fd49", "text": "## Комбинирование предопределённых и пользовательских ответов { #combine-predefined-responses-and-custom-ones }\n\nВозможно, вы хотите иметь некоторые предопределённые ответы, применимые ко многим операциям пути, но при этом комбинировать их с пользовательскими ответами, необходимыми для каждой конкретной операции пути.\n\nВ таких случаях вы можете использовать приём Python «распаковки» `dict` с помощью `**dict_to_unpack`:\n\n```Python\nold_dict = {\n    \"old key\": \"old value\",\n    \"second old key\": \"second old value\",\n}\nnew_dict = {**old_dict, \"new key\": \"new value\"}\n```\n\nЗдесь `new_dict` будет содержать все пары ключ-значение из `old_dict` плюс новую пару ключ-значение:\n\n```Python\n{\n    \"old key\": \"old value\",\n    \"second old key\": \"second old value\",\n    \"new key\": \"new value\",\n}\n```\n\nВы можете использовать этот приём, чтобы переиспользовать некоторые предопределённые ответы в ваших операциях пути и комбинировать их с дополнительными пользовательскими.\n\nНапример:\n\n{* ../../docs_src/additional_responses/tutorial004_py310.py hl[11:15,24] *}\n\n", "metadata": {"title": "Дополнительные ответы в OpenAPI", "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "source_mtime": "2026-01-12T17:48:12.950342+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\additional-responses.md"}, "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "title": "Дополнительные ответы в OpenAPI", "chunk_index": 6, "header": "Комбинирование предопределённых и пользовательских ответов", "header_level": 2, "token_count": 356}
{"id": "279abf1e02e368b4", "text": "## Дополнительная информация об ответах OpenAPI { #more-information-about-openapi-responses }\n\nЧтобы увидеть, что именно можно включать в ответы, посмотрите эти разделы спецификации OpenAPI:\n\n* <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#responses-object\" class=\"external-link\" target=\"_blank\">Объект Responses OpenAPI</a>, он включает `Response Object`.\n* <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#response-object\" class=\"external-link\" target=\"_blank\">Объект Response OpenAPI</a>, вы можете включить всё из этого объекта напрямую в каждый ответ внутри вашего параметра `responses`. Включая `description`, `headers`, `content` (внутри него вы объявляете разные типы содержимого и JSON‑схемы) и `links`.\n", "metadata": {"title": "Дополнительные ответы в OpenAPI", "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "source_mtime": "2026-01-12T17:48:12.950342+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\additional-responses.md"}, "doc_id": "10831841b57e", "source_path": "docs\\advanced\\additional-responses.md", "title": "Дополнительные ответы в OpenAPI", "chunk_index": 7, "header": "Дополнительная информация об ответах OpenAPI", "header_level": 2, "token_count": 247}
{"id": "1acc09a53f6dba7c", "text": "# Дополнительные статус-коды { #additional-status-codes }\n\nПо умолчанию **FastAPI** будет возвращать ответы, используя `JSONResponse`, помещая содержимое, которое вы возвращаете из вашей *операции пути*, внутрь этого `JSONResponse`.\n\nОн будет использовать статус-код по умолчанию или тот, который вы укажете в вашей *операции пути*.\n\n", "metadata": {"title": "Дополнительные статус-коды", "doc_id": "86235ea5052a", "source_path": "docs\\advanced\\additional-status-codes.md", "source_mtime": "2026-01-12T17:48:12.956958+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\additional-status-codes.md"}, "doc_id": "86235ea5052a", "source_path": "docs\\advanced\\additional-status-codes.md", "title": "Дополнительные статус-коды", "chunk_index": 0, "header": "Дополнительные статус-коды", "header_level": 1, "token_count": 120}
{"id": "1acc09a53f6dba7c", "text": "## Дополнительные статус-коды { #additional-status-codes_1 }\n\nЕсли вы хотите возвращать дополнительные статус-коды помимо основного, вы можете сделать это, возвращая `Response` напрямую, например `JSONResponse`, и устанавливая дополнительный статус-код напрямую.\n\nНапример, предположим, что вы хотите иметь *операцию пути*, которая позволяет обновлять элементы и возвращает HTTP статус-код 200 «OK» при успешном выполнении.\n\nНо вы также хотите, чтобы она принимала новые элементы. И если элементы ранее не существовали, она создаёт их и возвращает HTTP статус-код 201 «Created».\n\nЧтобы добиться этого, импортируйте `JSONResponse` и верните туда свой контент напрямую, установив нужный вам `status_code`:\n\n{* ../../docs_src/additional_status_codes/tutorial001_an_py310.py hl[4,25] *}\n\n/// warning | Внимание\n\nКогда вы возвращаете `Response` напрямую, как в примере выше, он будет возвращён как есть.\n\nОн не будет сериализован с помощью модели и т.п.\n\nУбедитесь, что в нём именно те данные, которые вы хотите, и что значения являются валидным JSON (если вы используете `JSONResponse`).\n\n///\n\n/// note | Технические детали\n\nВы также можете использовать `from starlette.responses import JSONResponse`.\n\n**FastAPI** предоставляет тот же `starlette.responses` через `fastapi.responses` просто для вашего удобства как разработчика. Но большинство доступных Response-классов приходят напрямую из Starlette. То же самое со `status`.", "metadata": {"title": "Дополнительные статус-коды", "doc_id": "86235ea5052a", "source_path": "docs\\advanced\\additional-status-codes.md", "source_mtime": "2026-01-12T17:48:12.956958+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\additional-status-codes.md", "section_header": "Дополнительные статус-коды", "section_header_level": 2}, "doc_id": "86235ea5052a", "source_path": "docs\\advanced\\additional-status-codes.md", "title": "Дополнительные статус-коды", "chunk_index": 1, "header": "Дополнительные статус-коды", "header_level": 2, "token_count": 512}
{"id": "81b66722345cb9d6", "text": "starlette.responses` через `fastapi.responses` просто для вашего удобства как разработчика. Но большинство доступных Response-классов приходят напрямую из Starlette. То же самое со `status`.\n\n///", "metadata": {"title": "Дополнительные статус-коды", "doc_id": "86235ea5052a", "source_path": "docs\\advanced\\additional-status-codes.md", "source_mtime": "2026-01-12T17:48:12.956958+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\additional-status-codes.md", "section_header": "Дополнительные статус-коды", "section_header_level": 2}, "doc_id": "86235ea5052a", "source_path": "docs\\advanced\\additional-status-codes.md", "title": "Дополнительные статус-коды", "chunk_index": 2, "header": "Дополнительные статус-коды", "header_level": 2, "token_count": 65}
{"id": "fbe2c1f3520b1841", "text": "## OpenAPI и документация API { #openapi-and-api-docs }\n\nЕсли вы возвращаете дополнительные статус-коды и ответы напрямую, они не будут включены в схему OpenAPI (документацию API), потому что у FastAPI нет способа заранее знать, что вы собираетесь вернуть.\n\nНо вы можете задокументировать это в своём коде, используя: [Дополнительные ответы](additional-responses.md){.internal-link target=_blank}.\n", "metadata": {"title": "Дополнительные статус-коды", "doc_id": "86235ea5052a", "source_path": "docs\\advanced\\additional-status-codes.md", "source_mtime": "2026-01-12T17:48:12.956958+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\additional-status-codes.md"}, "doc_id": "86235ea5052a", "source_path": "docs\\advanced\\additional-status-codes.md", "title": "Дополнительные статус-коды", "chunk_index": 3, "header": "OpenAPI и документация API", "header_level": 2, "token_count": 140}
{"id": "dc3c32a156ba0d4f", "text": "# Продвинутые зависимости { #advanced-dependencies }\n\n", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md"}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 0, "header": "Продвинутые зависимости", "header_level": 1, "token_count": 17}
{"id": "4b0150c154d1e0f7", "text": "## Параметризованные зависимости { #parameterized-dependencies }\n\nВсе зависимости, которые мы видели, — это конкретная функция или класс.\n\nНо бывают случаи, когда нужно задавать параметры зависимости, не объявляя много разных функций или классов.\n\nПредставим, что нам нужна зависимость, которая проверяет, содержит ли query-параметр `q` некоторое фиксированное содержимое.\n\nНо при этом мы хотим иметь возможность параметризовать это фиксированное содержимое.\n\n", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md"}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 1, "header": "Параметризованные зависимости", "header_level": 2, "token_count": 163}
{"id": "cf3f871259e1dd4c", "text": "## «Вызываемый» экземпляр { #a-callable-instance }\n\nВ Python есть способ сделать экземпляр класса «вызываемым» объектом.\n\nНе сам класс (он уже является вызываемым), а экземпляр этого класса.\n\nДля этого объявляем метод `__call__`:\n\n{* ../../docs_src/dependencies/tutorial011_an_py39.py hl[12] *}\n\nВ этом случае именно `__call__` **FastAPI** использует для проверки дополнительных параметров и подзависимостей, и именно он будет вызван, чтобы позже передать значение параметру в вашей *функции-обработчике пути*.\n\n", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md"}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 2, "header": "«Вызываемый» экземпляр", "header_level": 2, "token_count": 183}
{"id": "108e04533fdfcf02", "text": "## Параметризуем экземпляр { #parameterize-the-instance }\n\nТеперь мы можем использовать `__init__`, чтобы объявить параметры экземпляра, с помощью которых будем «параметризовать» зависимость:\n\n{* ../../docs_src/dependencies/tutorial011_an_py39.py hl[9] *}\n\nВ этом случае **FastAPI** вовсе не трогает `__init__` и не зависит от него — мы используем его напрямую в нашем коде.\n\n", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md"}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 3, "header": "Параметризуем экземпляр", "header_level": 2, "token_count": 135}
{"id": "9d0275757195b5dd", "text": "## Создаём экземпляр { #create-an-instance }\n\nМы можем создать экземпляр этого класса так:\n\n{* ../../docs_src/dependencies/tutorial011_an_py39.py hl[18] *}\n\nТак мы «параметризуем» нашу зависимость: теперь внутри неё хранится \"bar\" в атрибуте `checker.fixed_content`.\n\n", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md"}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 4, "header": "Создаём экземпляр", "header_level": 2, "token_count": 99}
{"id": "179eff2303b89559", "text": "## Используем экземпляр как зависимость { #use-the-instance-as-a-dependency }\n\nЗатем мы можем использовать этот `checker` в `Depends(checker)` вместо `Depends(FixedContentQueryChecker)`, потому что зависимостью является экземпляр `checker`, а не сам класс.\n\nИ при разрешении зависимости **FastAPI** вызовет `checker` примерно так:\n\n```Python\nchecker(q=\"somequery\")\n```\n\n…и передаст возвращённое значение как значение зависимости в нашу *функцию-обработчике пути* в параметр `fixed_content_included`:\n\n{* ../../docs_src/dependencies/tutorial011_an_py39.py hl[22] *}\n\n/// tip | Совет\n\nВсе это может показаться притянутым за уши. И пока может быть не совсем понятно, чем это полезно.\n\nЭти примеры намеренно простые, но они показывают, как всё устроено.\n\nВ главах про безопасность есть вспомогательные функции, реализованные тем же способом.\n\nЕсли вы поняли всё выше, вы уже знаете, как «под капотом» работают эти утилиты для безопасности.\n\n///\n\n", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md"}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 5, "header": "Используем экземпляр как зависимость", "header_level": 2, "token_count": 344}
{"id": "e2940d10301efeb8", "text": "## Зависимости с `yield`, `HTTPException`, `except` и фоновыми задачами { #dependencies-with-yield-httpexception-except-and-background-tasks }\n\n/// warning | Предупреждение\n\nСкорее всего, вам не понадобятся эти технические детали.\n\nОни полезны главным образом, если у вас было приложение FastAPI версии ниже 0.121.0 и вы столкнулись с проблемами зависимостей с `yield`.\n\n///\n\nЗависимости с `yield` со временем изменялись, чтобы учитывать разные случаи применения и исправлять проблемы. Ниже — краткое резюме изменений.\n\n", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md"}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 6, "header": "Зависимости с `yield`, `HTTPException`, `except` и фоновыми задачами", "header_level": 2, "token_count": 201}
{"id": "15eb710115361ba2", "text": "### Зависимости с `yield` и `scope` { #dependencies-with-yield-and-scope }\n\nВ версии 0.121.0 FastAPI добавил поддержку `Depends(scope=\"function\")` для зависимостей с `yield`.\n\nПри использовании `Depends(scope=\"function\")` код после `yield` выполняется сразу после завершения *функции-обработчика пути*, до отправки ответа клиенту.\n\nА при использовании `Depends(scope=\"request\")` (значение по умолчанию) код после `yield` выполняется после отправки ответа.\n\nПодробнее читайте в документации: [Зависимости с `yield` — раннее завершение и `scope`](../tutorial/dependencies/dependencies-with-yield.md#early-exit-and-scope).\n\n", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md"}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 7, "header": "Зависимости с `yield` и `scope`", "header_level": 3, "token_count": 211}
{"id": "dc3c32a156ba0d4f", "text": "### Зависимости с `yield` и `StreamingResponse`, технические детали { #dependencies-with-yield-and-streamingresponse-technical-details }\n\nДо FastAPI 0.118.0, если вы использовали зависимость с `yield`, код после `yield` выполнялся после возврата из *функции-обработчика пути*, но прямо перед отправкой ответа.\n\nИдея состояла в том, чтобы не удерживать ресурсы дольше необходимого, пока ответ «путешествует» по сети.\n\nЭто изменение также означало, что если вы возвращали `StreamingResponse`, код после `yield` в зависимости уже успевал выполниться.\n\nНапример, если у вас была сессия базы данных в зависимости с `yield`, `StreamingResponse` не смог бы использовать эту сессию во время стриминга данных, потому что сессия уже была закрыта в коде после `yield`.\n\nВ версии 0.118.0 это поведение было возвращено к тому, что код после `yield` выполняется после отправки ответа.\n\n/// info | Информация\n\nКак вы увидите ниже, это очень похоже на поведение до версии 0.106.0, но с несколькими улучшениями и исправлениями краевых случаев.\n\n///\n\n#### Сценарии с ранним выполнением кода после `yield` { #use-cases-with-early-exit-code }\n\nЕсть некоторые сценарии со специфическими условиями, которым могло бы помочь старое поведение — выполнение кода после `yield` перед отправкой ответа.", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md", "section_header": "Зависимости с `yield` и `StreamingResponse`, технические детали", "section_header_level": 3}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 8, "header": "Зависимости с `yield` и `StreamingResponse`, технические детали", "header_level": 3, "token_count": 465}
{"id": "4b0150c154d1e0f7", "text": "-early-exit-code }\n\nЕсть некоторые сценарии со специфическими условиями, которым могло бы помочь старое поведение — выполнение кода после `yield` перед отправкой ответа.\n\nНапример, представьте, что вы используете сессию базы данных в зависимости с `yield` только для проверки пользователя, а в самой *функции-обработчике пути* эта сессия больше не используется, и при этом ответ отправляется долго, например, это `StreamingResponse`, который медленно отправляет данные и по какой-то причине не использует базу данных.\n\nВ таком случае сессия базы данных будет удерживаться до завершения отправки ответа, хотя если вы её не используете, удерживать её не требуется.\n\nЭто могло бы выглядеть так:\n\n{* ../../docs_src/dependencies/tutorial013_an_py310.py *}\n\nКод после `yield`, автоматическое закрытие `Session` в:\n\n{* ../../docs_src/dependencies/tutorial013_an_py310.py ln[19:21] *}\n\n…будет выполнен после того, как ответ закончит отправку медленных данных:\n\n{* ../../docs_src/dependencies/tutorial013_an_py310.py ln[30:38] hl[31:33] *}\n\nНо поскольку `generate_stream()` не использует сессию базы данных, нет реальной необходимости держать сессию открытой во время отправки ответа.\n\nЕсли у вас именно такой сценарий с SQLModel (или SQLAlchemy), вы можете явно закрыть сессию, когда она больше не нужна:\n\n{* ../../docs_src/dependencies/tutorial014_an_py310.py ln[24:28] hl[28] *}\n\nТак сессия освободит подключение к базе данных, и другие запросы смогут его использовать.", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md", "section_header": "Зависимости с `yield` и `StreamingResponse`, технические детали", "section_header_level": 3}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 9, "header": "Зависимости с `yield` и `StreamingResponse`, технические детали", "header_level": 3, "token_count": 498}
{"id": "cf3f871259e1dd4c", "text": "огда она больше не нужна:\n\n{* ../../docs_src/dependencies/tutorial014_an_py310.py ln[24:28] hl[28] *}\n\nТак сессия освободит подключение к базе данных, и другие запросы смогут его использовать.\n\nЕсли у вас есть другой сценарий, где нужно раннее завершение зависимости с `yield`, пожалуйста, создайте <a href=\"https://github.com/fastapi/fastapi/discussions/new?category=questions\" class=\"external-link\" target=\"_blank\">вопрос в GitHub Discussions</a> с описанием конкретного кейса и почему вам было бы полезно иметь раннее закрытие для зависимостей с `yield`.\n\nЕсли появятся веские причины для раннего закрытия в зависимостях с `yield`, я рассмотрю добавление нового способа опционально включать раннее закрытие.", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md", "section_header": "Зависимости с `yield` и `StreamingResponse`, технические детали", "section_header_level": 3}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 10, "header": "Зависимости с `yield` и `StreamingResponse`, технические детали", "header_level": 3, "token_count": 259}
{"id": "e30538909c51dc27", "text": "### Зависимости с `yield` и `except`, технические детали { #dependencies-with-yield-and-except-technical-details }\n\nДо FastAPI 0.110.0, если вы использовали зависимость с `yield`, затем перехватывали исключение с `except` в этой зависимости и не пробрасывали исключение снова, исключение автоматически пробрасывалось дальше к обработчикам исключений или к обработчику внутренней ошибки сервера.\n\nВ версии 0.110.0 это было изменено, чтобы исправить неконтролируемое потребление памяти из‑за проброшенных исключений без обработчика (внутренние ошибки сервера) и привести поведение в соответствие с обычным поведением Python-кода.\n\n", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md"}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 11, "header": "Зависимости с `yield` и `except`, технические детали", "header_level": 3, "token_count": 246}
{"id": "dc3c32a156ba0d4f", "text": "### Фоновые задачи и зависимости с `yield`, технические детали { #background-tasks-and-dependencies-with-yield-technical-details }\n\nДо FastAPI 0.106.0 вызывать исключения после `yield` было невозможно: код после `yield` в зависимостях выполнялся уже после отправки ответа, поэтому [Обработчики исключений](../tutorial/handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank} к тому моменту уже отработали.\n\nТак было сделано в основном для того, чтобы можно было использовать те же объекты, «отданные» зависимостями через `yield`, внутри фоновых задач, потому что код после `yield` выполнялся после завершения фоновых задач.\n\nВ FastAPI 0.106.0 это изменили, чтобы не удерживать ресурсы, пока ответ передаётся по сети.\n\n/// tip | Совет\n\nКроме того, фоновая задача обычно — это самостоятельный фрагмент логики, который следует обрабатывать отдельно, со своими ресурсами (например, со своим подключением к базе данных).\n\nТак код, скорее всего, будет чище.\n\n///\n\nЕсли вы полагались на прежнее поведение, теперь ресурсы для фоновых задач следует создавать внутри самой фоновой задачи и использовать внутри неё только данные, которые не зависят от ресурсов зависимостей с `yield`.", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md", "section_header": "Фоновые задачи и зависимости с `yield`, технические детали", "section_header_level": 3}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 12, "header": "Фоновые задачи и зависимости с `yield`, технические детали", "header_level": 3, "token_count": 454}
{"id": "4b0150c154d1e0f7", "text": "еперь ресурсы для фоновых задач следует создавать внутри самой фоновой задачи и использовать внутри неё только данные, которые не зависят от ресурсов зависимостей с `yield`.\n\nНапример, вместо использования той же сессии базы данных, создайте новую сессию в фоновой задаче и получите объекты из базы данных с помощью этой новой сессии. И затем, вместо передачи объекта из базы данных параметром в функцию фоновой задачи, передавайте идентификатор этого объекта и заново получайте объект внутри функции фоновой задачи.", "metadata": {"title": "Продвинутые зависимости", "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "source_mtime": "2026-01-12T17:48:12.960972+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\advanced-dependencies.md", "section_header": "Фоновые задачи и зависимости с `yield`, технические детали", "section_header_level": 3}, "doc_id": "8790e9d141eb", "source_path": "docs\\advanced\\advanced-dependencies.md", "title": "Продвинутые зависимости", "chunk_index": 13, "header": "Фоновые задачи и зависимости с `yield`, технические детали", "header_level": 3, "token_count": 193}
{"id": "b559698da0b05549", "text": "# Асинхронное тестирование { #async-tests }\n\nВы уже видели как тестировать **FastAPI** приложение, используя имеющийся класс `TestClient`. К этому моменту вы видели только как писать тесты в синхронном стиле без использования `async` функций.\n\nВозможность использования асинхронных функций в ваших тестах может быть полезнa, когда, например, вы асинхронно обращаетесь к вашей базе данных. Представьте, что вы хотите отправить запросы в ваше FastAPI приложение, а затем при помощи асинхронной библиотеки для работы с базой данных удостовериться, что ваш бекэнд корректно записал данные в базу данных.\n\nДавайте рассмотрим, как мы можем это реализовать.\n\n", "metadata": {"title": "Асинхронное тестирование", "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "source_mtime": "2026-01-12T17:48:12.966256+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\async-tests.md"}, "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "title": "Асинхронное тестирование", "chunk_index": 0, "header": "Асинхронное тестирование", "header_level": 1, "token_count": 241}
{"id": "2a969363a58624cf", "text": "## pytest.mark.anyio { #pytest-mark-anyio }\n\nЕсли мы хотим вызывать асинхронные функции в наших тестах, то наши тестовые функции должны быть асинхронными. AnyIO предоставляет для этого отличный плагин, который позволяет нам указывать, какие тестовые функции должны вызываться асинхронно.\n\n", "metadata": {"title": "Асинхронное тестирование", "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "source_mtime": "2026-01-12T17:48:12.966256+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\async-tests.md"}, "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "title": "Асинхронное тестирование", "chunk_index": 1, "header": "pytest.mark.anyio", "header_level": 2, "token_count": 110}
{"id": "eff287ff56d433d5", "text": "## HTTPX { #httpx }\n\nДаже если **FastAPI** приложение использует обычные функции `def` вместо `async def`, это все равно `async` приложение 'под капотом'.\n\nЧтобы работать с асинхронным FastAPI приложением в ваших обычных тестовых функциях `def`, используя стандартный pytest, `TestClient` внутри себя делает некоторую магию. Но эта магия перестает работать, когда мы используем его внутри асинхронных функций. Запуская наши тесты асинхронно, мы больше не можем использовать `TestClient` внутри наших тестовых функций.\n\n`TestClient` основан на <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">HTTPX</a>, и, к счастью, мы можем использовать его (`HTTPX`) напрямую для тестирования API.\n\n", "metadata": {"title": "Асинхронное тестирование", "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "source_mtime": "2026-01-12T17:48:12.966256+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\async-tests.md"}, "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "title": "Асинхронное тестирование", "chunk_index": 2, "header": "HTTPX", "header_level": 2, "token_count": 271}
{"id": "33a00f02e4b5fb1b", "text": "## Пример { #example }\n\nВ качестве простого примера, давайте рассмотрим файловую структуру, схожую с описанной в [Большие приложения](../tutorial/bigger-applications.md){.internal-link target=_blank} и [Тестирование](../tutorial/testing.md){.internal-link target=_blank}:\n\n```\n.\n├── app\n│   ├── __init__.py\n│   ├── main.py\n│   └── test_main.py\n```\n\nФайл `main.py`:\n\n{* ../../docs_src/async_tests/app_a_py39/main.py *}\n\nФайл `test_main.py` содержит тесты для `main.py`, теперь он может выглядеть так:\n\n{* ../../docs_src/async_tests/app_a_py39/test_main.py *}\n\n", "metadata": {"title": "Асинхронное тестирование", "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "source_mtime": "2026-01-12T17:48:12.966256+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\async-tests.md"}, "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "title": "Асинхронное тестирование", "chunk_index": 3, "header": "Пример", "header_level": 2, "token_count": 191}
{"id": "dd396b5850704a9b", "text": "## Запуск тестов { #run-it }\n\nВы можете запустить свои тесты как обычно:\n\n<div class=\"termy\">\n\n```console\n$ pytest\n\n---> 100%\n```\n\n</div>\n\n", "metadata": {"title": "Асинхронное тестирование", "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "source_mtime": "2026-01-12T17:48:12.966256+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\async-tests.md"}, "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "title": "Асинхронное тестирование", "chunk_index": 4, "header": "Запуск тестов", "header_level": 2, "token_count": 53}
{"id": "7d823ae2fa4713b0", "text": "## Подробнее { #in-detail }\n\nМаркер `@pytest.mark.anyio` говорит pytest, что тестовая функция должна быть вызвана асинхронно:\n\n{* ../../docs_src/async_tests/app_a_py39/test_main.py hl[7] *}\n\n/// tip | Подсказка\n\nОбратите внимание, что тестовая функция теперь `async def` вместо простого `def`, как это было при использовании `TestClient`.\n\n///\n\nЗатем мы можем создать `AsyncClient` со ссылкой на приложение и посылать асинхронные запросы, используя `await`.\n\n{* ../../docs_src/async_tests/app_a_py39/test_main.py hl[9:12] *}\n\nЭто эквивалентно следующему:\n\n```Python\nresponse = client.get('/')\n```\n\n...которое мы использовали для отправки наших запросов с `TestClient`.\n\n/// tip | Подсказка\n\nОбратите внимание, что мы используем async/await с `AsyncClient` - запрос асинхронный.\n\n///\n\n/// warning | Внимание\n\nЕсли ваше приложение полагается на lifespan события, то `AsyncClient` не запустит эти события. Чтобы обеспечить их срабатывание используйте `LifespanManager` из <a href=\"https://github.com/florimondmanca/asgi-lifespan#usage\" class=\"external-link\" target=\"_blank\">florimondmanca/asgi-lifespan</a>.\n\n///\n\n", "metadata": {"title": "Асинхронное тестирование", "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "source_mtime": "2026-01-12T17:48:12.966256+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\async-tests.md"}, "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "title": "Асинхронное тестирование", "chunk_index": 5, "header": "Подробнее", "header_level": 2, "token_count": 382}
{"id": "728bcbbab3b89c3f", "text": "## Вызов других асинхронных функций { #other-asynchronous-function-calls }\n\nТеперь тестовая функция стала асинхронной, поэтому внутри нее вы можете вызывать также и другие `async` функции, не связанные с отправлением запросов в ваше FastAPI приложение. Как если бы вы вызывали их в любом другом месте вашего кода.\n\n/// tip | Подсказка\n\nЕсли вы столкнулись с `RuntimeError: Task attached to a different loop` при вызове асинхронных функций в ваших тестах (например, при использовании <a href=\"https://stackoverflow.com/questions/41584243/runtimeerror-task-attached-to-a-different-loop\" class=\"external-link\" target=\"_blank\">MongoDB's MotorClient</a>), то не забывайте инициализировать объекты, которым нужен цикл событий (event loop), только внутри асинхронных функций, например, в `'@app.on_event(\"startup\")` callback.\n\n///\n", "metadata": {"title": "Асинхронное тестирование", "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "source_mtime": "2026-01-12T17:48:12.966256+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\async-tests.md"}, "doc_id": "906bfc547173", "source_path": "docs\\advanced\\async-tests.md", "title": "Асинхронное тестирование", "chunk_index": 6, "header": "Вызов других асинхронных функций", "header_level": 2, "token_count": 285}
{"id": "6f5a6cc9991a3487", "text": "# За прокси‑сервером { #behind-a-proxy }\n\nВо многих случаях перед приложением FastAPI используется прокси‑сервер, например Traefik или Nginx.\n\nТакие прокси могут обрабатывать HTTPS‑сертификаты и многое другое.\n\n", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md"}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 0, "header": "За прокси‑сервером", "header_level": 1, "token_count": 90}
{"id": "bcd254236572ea51", "text": "## Пересылаемые заголовки прокси { #proxy-forwarded-headers }\n\nПрокси перед вашим приложением обычно на лету добавляет некоторые HTTP‑заголовки перед отправкой запроса на ваш сервер, чтобы сообщить ему, что запрос был переслан прокси, а также передать исходный (публичный) URL (включая домен), информацию об использовании HTTPS и т.д.\n\nПрограмма сервера (например, Uvicorn, запущенный через FastAPI CLI) умеет интерпретировать эти заголовки и передавать соответствующую информацию вашему приложению.\n\nНо из соображений безопасности, пока сервер не уверен, что находится за доверенным прокси, он не будет интерпретировать эти заголовки.\n\n/// note | Технические детали\n\nЗаголовки прокси:\n\n* <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-For\" class=\"external-link\" target=\"_blank\">X-Forwarded-For</a>\n* <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-Proto\" class=\"external-link\" target=\"_blank\">X-Forwarded-Proto</a>\n* <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-Host\" class=\"external-link\" target=\"_blank\">X-Forwarded-Host</a>\n\n///\n\n", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md"}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 1, "header": "Пересылаемые заголовки прокси", "header_level": 2, "token_count": 392}
{"id": "eff27aac06ea8d76", "text": "### Включить пересылаемые заголовки прокси { #enable-proxy-forwarded-headers }\n\nВы можете запустить FastAPI CLI с опцией командной строки `--forwarded-allow-ips` и передать IP‑адреса, которым следует доверять при чтении этих пересылаемых заголовков.\n\nЕсли указать `--forwarded-allow-ips=\"*\"`, приложение будет доверять всем входящим IP.\n\nЕсли ваш сервер находится за доверенным прокси и только прокси обращается к нему, этого достаточно, чтобы он принимал IP этого прокси.\n\n<div class=\"termy\">\n\n```console\n$ fastapi run --forwarded-allow-ips=\"*\"\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n</div>\n\n", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md"}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 2, "header": "Включить пересылаемые заголовки прокси", "header_level": 3, "token_count": 236}
{"id": "279a87c7a0a36a65", "text": "### Редиректы с HTTPS { #redirects-with-https }\n\nНапример, вы объявили операцию пути `/items/`:\n\n{* ../../docs_src/behind_a_proxy/tutorial001_01_py39.py hl[6] *}\n\nЕсли клиент обратится к `/items`, по умолчанию произойдёт редирект на `/items/`.\n\nНо до установки опции `--forwarded-allow-ips` редирект может вести на `http://localhost:8000/items/`.\n\nОднако приложение может быть доступно по `https://mysuperapp.com`, и редирект должен вести на `https://mysuperapp.com/items/`.\n\nУказав `--proxy-headers`, FastAPI сможет редиректить на корректный адрес. \n\n```\nhttps://mysuperapp.com/items/\n```\n\n/// tip | Совет\n\nЕсли хотите узнать больше об HTTPS, смотрите руководство [О HTTPS](../deployment/https.md){.internal-link target=_blank}.\n\n///\n\n", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md"}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 3, "header": "Редиректы с HTTPS", "header_level": 3, "token_count": 255}
{"id": "7746e7ac402adf66", "text": "### Как работают пересылаемые заголовки прокси { #how-proxy-forwarded-headers-work }\n\nНиже показано, как прокси добавляет пересылаемые заголовки между клиентом и сервером приложения:\n\n```mermaid\nsequenceDiagram\n    participant Client as Клиент\n    participant Proxy as Прокси/Балансировщик нагрузки\n    participant Server as FastAPI-сервер\n\n    Client->>Proxy: HTTPS-запрос<br/>Host: mysuperapp.com<br/>Path: /items\n\n    Note over Proxy: Прокси-сервер добавляет пересылаемые заголовки\n\n    Proxy->>Server: HTTP-запрос<br/>X-Forwarded-For: [client IP]<br/>X-Forwarded-Proto: https<br/>X-Forwarded-Host: mysuperapp.com<br/>Path: /items\n\n    Note over Server: Server интерпретирует HTTP-заголовки<br/>(если --forwarded-allow-ips установлен)\n\n    Server->>Proxy: HTTP-ответ<br/>с верными HTTPS URLs\n\n    Proxy->>Client: HTTPS-ответ\n```\n\nПрокси перехватывает исходный клиентский запрос и добавляет специальные пересылаемые заголовки (`X-Forwarded-*`) перед передачей запроса на сервер приложения.\n\nЭти заголовки сохраняют информацию об исходном запросе, которая иначе была бы потеряна:\n\n* X-Forwarded-For: исходный IP‑адрес клиента\n* X-Forwarded-Proto: исходный протокол (`https`)\n* X-Forwarded-Host: исходный хост (`mysuperapp.com`)\n\nКогда FastAPI CLI сконфигурирован с `--forwarded-allow-ips`, он доверяет этим заголовкам и использует их, например, чтобы формировать корректные URL в редиректах.\n\n", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md"}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 4, "header": "Как работают пересылаемые заголовки прокси", "header_level": 3, "token_count": 499}
{"id": "6f5a6cc9991a3487", "text": "## Прокси с функцией удаления префикса пути { #proxy-with-a-stripped-path-prefix }\n\nПрокси может добавлять к вашему приложению префикс пути (размещать приложение по пути с дополнительным префиксом).\n\nВ таких случаях вы можете использовать `root_path` для настройки приложения.\n\nМеханизм `root_path` определён спецификацией ASGI (на которой построен FastAPI, через Starlette).\n\n`root_path` используется для обработки таких специфических случаев.\n\nОн также используется внутри при монтировании вложенных приложений.\n\nПрокси с функцией удаления префикса пути в этом случае означает, что вы объявляете путь `/app` в коде, а затем добавляете сверху слой (прокси), который размещает ваше приложение FastAPI под путём вида `/api/v1`.\n\nТогда исходный путь `/app` фактически будет обслуживаться по адресу `/api/v1/app`.\n\nХотя весь ваш код написан с расчётом, что путь один — `/app`.\n\n{* ../../docs_src/behind_a_proxy/tutorial001_py39.py hl[6] *}\n\nПрокси будет «обрезать» префикс пути на лету перед передачей запроса на сервер приложения (скорее всего Uvicorn, запущенный через FastAPI CLI), поддерживая у вашего приложения иллюзию, что его обслуживают по `/app`, чтобы вам не пришлось менять весь код и добавлять префикс `/api/v1`.\n\nДо этого момента всё будет работать как обычно.", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md", "section_header": "Прокси с функцией удаления префикса пути", "section_header_level": 2}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 5, "header": "Прокси с функцией удаления префикса пути", "header_level": 2, "token_count": 489}
{"id": "bcd254236572ea51", "text": "иллюзию, что его обслуживают по `/app`, чтобы вам не пришлось менять весь код и добавлять префикс `/api/v1`.\n\nДо этого момента всё будет работать как обычно.\n\nНо когда вы откроете встроенный интерфейс документации (фронтенд), он будет ожидать получить схему OpenAPI по адресу `/openapi.json`, а не `/api/v1/openapi.json`.\n\nПоэтому фронтенд (который работает в браузере) попытается обратиться к `/openapi.json` и не сможет получить схему OpenAPI.\n\nТак как для нашего приложения используется прокси с префиксом пути `/api/v1`, фронтенду нужно забирать схему OpenAPI по `/api/v1/openapi.json`.\n\n```mermaid\ngraph LR\n\nbrowser(\"Browser\")\nproxy[\"Proxy on http://0.0.0.0:9999/api/v1/app\"]\nserver[\"Server on http://127.0.0.1:8000/app\"]\n\nbrowser --> proxy\nproxy --> server\n```\n\n/// tip | Совет\n\nIP `0.0.0.0` обычно означает, что программа слушает на всех IP‑адресах, доступных на этой машине/сервере.\n\n///\n\nИнтерфейсу документации также нужна схема OpenAPI, в которой будет указано, что этот API `server` находится по пути `/api/v1` (за прокси). Например:\n\n```JSON hl_lines=\"4-8\"\n{\n    \"openapi\": \"3.1.0\",\n    // Здесь ещё что-то\n    \"servers\": [\n        {\n            \"url\": \"/api/v1\"\n        }\n    ],\n    \"paths\": {\n            // Здесь ещё что-то\n    }\n}\n```", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md", "section_header": "Прокси с функцией удаления префикса пути", "section_header_level": 2}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 6, "header": "Прокси с функцией удаления префикса пути", "header_level": 2, "token_count": 493}
{"id": "eff27aac06ea8d76", "text": "openapi\": \"3.1.0\",\n    // Здесь ещё что-то\n    \"servers\": [\n        {\n            \"url\": \"/api/v1\"\n        }\n    ],\n    \"paths\": {\n            // Здесь ещё что-то\n    }\n}\n```\n\nВ этом примере «Proxy» может быть, например, Traefik. А сервером будет что‑то вроде FastAPI CLI с Uvicorn, на котором запущено ваше приложение FastAPI.", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md", "section_header": "Прокси с функцией удаления префикса пути", "section_header_level": 2}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 7, "header": "Прокси с функцией удаления префикса пути", "header_level": 2, "token_count": 117}
{"id": "864d8768c02cf4a7", "text": "### Указание `root_path` { #providing-the-root-path }\n\nДля этого используйте опцию командной строки `--root-path`, например так:\n\n<div class=\"termy\">\n\n```console\n$ fastapi run main.py --forwarded-allow-ips=\"*\" --root-path /api/v1\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n</div>\n\nЕсли вы используете Hypercorn, у него тоже есть опция `--root-path`.\n\n/// note | Технические детали\n\nСпецификация ASGI определяет `root_path` для такого случая.\n\nА опция командной строки `--root-path` передаёт этот `root_path`.\n\n///\n\n", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md"}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 8, "header": "Указание `root_path`", "header_level": 3, "token_count": 197}
{"id": "7ca785f2267d080e", "text": "### Проверка текущего `root_path` { #checking-the-current-root-path }\n\nВы можете получить текущий `root_path`, используемый вашим приложением для каждого запроса, — он входит в словарь `scope` (часть спецификации ASGI).\n\nЗдесь мы добавляем его в сообщение лишь для демонстрации.\n\n{* ../../docs_src/behind_a_proxy/tutorial001_py39.py hl[8] *}\n\nЗатем, если вы запустите Uvicorn так:\n\n<div class=\"termy\">\n\n```console\n$ fastapi run main.py --forwarded-allow-ips=\"*\" --root-path /api/v1\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n</div>\n\nОтвет будет примерно таким:\n\n```JSON\n{\n    \"message\": \"Hello World\",\n    \"root_path\": \"/api/v1\"\n}\n```\n\n", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md"}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 9, "header": "Проверка текущего `root_path`", "header_level": 3, "token_count": 231}
{"id": "a3fc0b866ff2cf1f", "text": "### Установка `root_path` в приложении FastAPI { #setting-the-root-path-in-the-fastapi-app }\n\nЕсли нет возможности передать опцию командной строки `--root-path` (или аналог), вы можете указать параметр `root_path` при создании приложения FastAPI:\n\n{* ../../docs_src/behind_a_proxy/tutorial002_py39.py hl[3] *}\n\nПередача `root_path` в `FastAPI` эквивалентна опции командной строки `--root-path` для Uvicorn или Hypercorn.\n\n", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md"}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 10, "header": "Установка `root_path` в приложении FastAPI", "header_level": 3, "token_count": 132}
{"id": "304c615208112d2a", "text": "### О `root_path` { #about-root-path }\n\nУчтите, что сервер (Uvicorn) не использует `root_path` ни для чего, кроме как передать его в приложение.\n\nЕсли вы откроете в браузере <a href=\"http://127.0.0.1:8000/app\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/app</a>, вы увидите обычный ответ:\n\n```JSON\n{\n    \"message\": \"Hello World\",\n    \"root_path\": \"/api/v1\"\n}\n```\n\nТо есть он не ожидает, что к нему обратятся по адресу `http://127.0.0.1:8000/api/v1/app`.\n\nUvicorn ожидает, что прокси обратится к нему по `http://127.0.0.1:8000/app`, а уже задача прокси — добавить сверху префикс `/api/v1`.\n\n", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md"}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 11, "header": "О `root_path`", "header_level": 3, "token_count": 247}
{"id": "30a600e6c507b512", "text": "## О прокси с урезанным префиксом пути { #about-proxies-with-a-stripped-path-prefix }\n\nПомните, что прокси с урезанным префиксом пути — лишь один из вариантов настройки.\n\nВо многих случаях по умолчанию прокси будет без урезанного префикса пути.\n\nВ таком случае (без урезанного префикса) прокси слушает, например, по адресу `https://myawesomeapp.com`, и если браузер идёт на `https://myawesomeapp.com/api/v1/app`, а ваш сервер (например, Uvicorn) слушает на `http://127.0.0.1:8000`, то прокси (без урезанного префикса) обратится к Uvicorn по тому же пути: `http://127.0.0.1:8000/api/v1/app`.\n\n", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md"}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 12, "header": "О прокси с урезанным префиксом пути", "header_level": 2, "token_count": 267}
{"id": "6f5a6cc9991a3487", "text": "## Локальное тестирование с Traefik { #testing-locally-with-traefik }\n\nВы можете легко поэкспериментировать локально с урезанным префиксом пути, используя <a href=\"https://docs.traefik.io/\" class=\"external-link\" target=\"_blank\">Traefik</a>.\n\n<a href=\"https://github.com/containous/traefik/releases\" class=\"external-link\" target=\"_blank\">Скачайте Traefik</a> — это один бинарный файл; распакуйте архив и запустите его прямо из терминала.\n\nЗатем создайте файл `traefik.toml` со следующим содержимым:\n\n```TOML hl_lines=\"3\"\n[entryPoints]\n  [entryPoints.http]\n    address = \":9999\"\n\n[providers]\n  [providers.file]\n    filename = \"routes.toml\"\n```\n\nЭто говорит Traefik слушать порт 9999 и использовать другой файл `routes.toml`.\n\n/// tip | Совет\n\nМы используем порт 9999 вместо стандартного HTTP‑порта 80, чтобы не нужно было запускать с правами администратора (`sudo`).\n\n///\n\nТеперь создайте второй файл `routes.toml`:\n\n```TOML hl_lines=\"5  12  20\"\n[http]\n  [http.middlewares]\n\n    [http.middlewares.api-stripprefix.stripPrefix]\n      prefixes = [\"/api/v1\"]\n\n  [http.routers]\n\n    [http.routers.app-http]\n      entryPoints = [\"http\"]\n      service = \"app\"\n      rule = \"PathPrefix(`/api/v1`)\"\n      middlewares = [\"api-stripprefix\"]\n\n  [http.services]\n\n    [http.services.app]\n      [http.services.app.loadBalancer]\n        [[http.services.app.loadBalancer.servers]]\n          url = \"http://127.0.0.1:8000\"\n```\n\nЭтот файл настраивает Traefik на использование префикса пути `/api/v1`.", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md", "section_header": "Локальное тестирование с Traefik", "section_header_level": 2}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 13, "header": "Локальное тестирование с Traefik", "header_level": 2, "token_count": 504}
{"id": "bcd254236572ea51", "text": "[http.services.app.loadBalancer]\n        [[http.services.app.loadBalancer.servers]]\n          url = \"http://127.0.0.1:8000\"\n```\n\nЭтот файл настраивает Traefik на использование префикса пути `/api/v1`.\n\nДалее Traefik будет проксировать запросы на ваш Uvicorn, работающий на `http://127.0.0.1:8000`.\n\nТеперь запустите Traefik:\n\n<div class=\"termy\">\n\n```console\n$ ./traefik --configFile=traefik.toml\n\nINFO[0000] Configuration loaded from file: /home/user/awesomeapi/traefik.toml\n```\n\n</div>\n\nИ запустите приложение с опцией `--root-path`:\n\n<div class=\"termy\">\n\n```console\n$ fastapi run main.py --forwarded-allow-ips=\"*\" --root-path /api/v1\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n</div>", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md", "section_header": "Локальное тестирование с Traefik", "section_header_level": 2}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 14, "header": "Локальное тестирование с Traefik", "header_level": 2, "token_count": 256}
{"id": "6f5a6cc9991a3487", "text": "### Проверьте ответы { #check-the-responses }\n\nТеперь, если вы перейдёте на URL с портом Uvicorn: <a href=\"http://127.0.0.1:8000/app\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/app</a>, вы увидите обычный ответ:\n\n```JSON\n{\n    \"message\": \"Hello World\",\n    \"root_path\": \"/api/v1\"\n}\n```\n\n/// tip | Совет\n\nОбратите внимание, что хотя вы обращаетесь по `http://127.0.0.1:8000/app`, в ответе указан `root_path` равный `/api/v1`, взятый из опции `--root-path`.\n\n///\n\nА теперь откройте URL с портом Traefik и префиксом пути: <a href=\"http://127.0.0.1:9999/api/v1/app\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:9999/api/v1/app</a>.\n\nМы получим тот же ответ:\n\n```JSON\n{\n    \"message\": \"Hello World\",\n    \"root_path\": \"/api/v1\"\n}\n```\n\nно уже по URL с префиксом, который добавляет прокси: `/api/v1`.\n\nРазумеется, задумывается, что все будут обращаться к приложению через прокси, поэтому вариант с префиксом пути `/api/v1` является «правильным».\n\nА вариант без префикса (`http://127.0.0.1:8000/app`), выдаваемый напрямую Uvicorn, предназначен исключительно для того, чтобы прокси (Traefik) мог к нему обращаться.", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md", "section_header": "Проверьте ответы", "section_header_level": 3}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 15, "header": "Проверьте ответы", "header_level": 3, "token_count": 464}
{"id": "bcd254236572ea51", "text": "(`http://127.0.0.1:8000/app`), выдаваемый напрямую Uvicorn, предназначен исключительно для того, чтобы прокси (Traefik) мог к нему обращаться.\n\nЭто демонстрирует, как прокси (Traefik) использует префикс пути и как сервер (Uvicorn) использует `root_path`, переданный через опцию `--root-path`.", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md", "section_header": "Проверьте ответы", "section_header_level": 3}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 16, "header": "Проверьте ответы", "header_level": 3, "token_count": 121}
{"id": "22bb35061987b30c", "text": "### Проверьте интерфейс документации { #check-the-docs-ui }\n\nА вот самое интересное. \n\n«Официальный» способ доступа к приложению — через прокси с заданным префиксом пути. Поэтому, как и ожидается, если открыть интерфейс документации, отдаваемый напрямую Uvicorn, без префикса пути в URL, он не будет работать, так как предполагается доступ через прокси.\n\nПроверьте по адресу <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a>:\n\n<img src=\"/img/tutorial/behind-a-proxy/image01.png\">\n\nА вот если открыть интерфейс документации по «официальному» URL через прокси на порту `9999`, по `/api/v1/docs`, всё работает корректно! \n\nПроверьте по адресу <a href=\"http://127.0.0.1:9999/api/v1/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:9999/api/v1/docs</a>:\n\n<img src=\"/img/tutorial/behind-a-proxy/image02.png\">\n\nИменно как и хотелось. \n\nЭто потому, что FastAPI использует `root_path`, чтобы создать в OpenAPI сервер по умолчанию с URL из `root_path`.\n\n", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md"}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 17, "header": "Проверьте интерфейс документации", "header_level": 3, "token_count": 378}
{"id": "6f5a6cc9991a3487", "text": "## Дополнительные серверы { #additional-servers }\n\n/// warning | Предупреждение\n\nЭто более продвинутый сценарий. Можно пропустить.\n\n///\n\nПо умолчанию FastAPI создаёт в схеме OpenAPI `server` с URL из `root_path`.\n\nНо вы также можете указать дополнительные `servers`, например, если хотите, чтобы один и тот же интерфейс документации работал и со <abbr title=\"«промежуточное» или «предпродакшн» окружение\">стейджингом</abbr>, и с продакшн.\n\nЕсли вы передадите свой список `servers` и при этом задан `root_path` (потому что ваш API работает за прокси), FastAPI вставит «server» с этим `root_path` в начало списка.\n\nНапример:\n\n{* ../../docs_src/behind_a_proxy/tutorial003_py39.py hl[4:7] *}\n\nБудет сгенерирована схема OpenAPI примерно такая:\n\n```JSON hl_lines=\"5-7\"\n{\n    \"openapi\": \"3.1.0\",\n    // Здесь ещё что-то\n    \"servers\": [\n        {\n            \"url\": \"/api/v1\"\n        },\n        {\n            \"url\": \"https://stag.example.com\",\n            \"description\": \"Staging environment\"\n        },\n        {\n            \"url\": \"https://prod.example.com\",\n            \"description\": \"Production environment\"\n        }\n    ],\n    \"paths\": {\n            // Здесь ещё что-то\n    }\n}\n```\n\n/// tip | Совет\n\nОбратите внимание на автоматически добавленный сервер с `url` равным `/api/v1`, взятым из `root_path`.\n\n///", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md", "section_header": "Дополнительные серверы", "section_header_level": 2}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 18, "header": "Дополнительные серверы", "header_level": 2, "token_count": 449}
{"id": "bcd254236572ea51", "text": "// Здесь ещё что-то\n    }\n}\n```\n\n/// tip | Совет\n\nОбратите внимание на автоматически добавленный сервер с `url` равным `/api/v1`, взятым из `root_path`.\n\n///\n\nВ интерфейсе документации по адресу <a href=\"http://127.0.0.1:9999/api/v1/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:9999/api/v1/docs</a> это будет выглядеть так:\n\n<img src=\"/img/tutorial/behind-a-proxy/image03.png\">\n\n/// tip | Совет\n\nИнтерфейс документации будет взаимодействовать с сервером, который вы выберете.\n\n///\n\n/// note | Технические детали\n\nСвойство `servers` в спецификации OpenAPI является необязательным.\n\nЕсли вы не укажете параметр `servers`, а `root_path` равен `/`, то свойство `servers` в сгенерированной схеме OpenAPI по умолчанию будет опущено. Это эквивалентно серверу со значением `url` равным `/`.\n\n///", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md", "section_header": "Дополнительные серверы", "section_header_level": 2}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 19, "header": "Дополнительные серверы", "header_level": 2, "token_count": 309}
{"id": "f80dcd5c48b77525", "text": "### Отключить автоматическое добавление сервера из `root_path` { #disable-automatic-server-from-root-path }\n\nЕсли вы не хотите, чтобы FastAPI добавлял автоматический сервер, используя `root_path`, укажите параметр `root_path_in_servers=False`:\n\n{* ../../docs_src/behind_a_proxy/tutorial004_py39.py hl[9] *}\n\nи тогда этот сервер не будет добавлен в схему OpenAPI.\n\n", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md"}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 20, "header": "Отключить автоматическое добавление сервера из `root_path`", "header_level": 3, "token_count": 110}
{"id": "55b4e1ecfeba2095", "text": "## Монтирование вложенного приложения { #mounting-a-sub-application }\n\nЕсли вам нужно смонтировать вложенное приложение (как описано в [Вложенные приложения — монтирование](sub-applications.md){.internal-link target=_blank}), и при этом вы используете прокси с `root_path`, делайте это обычным образом — всё будет работать, как ожидается.\n\nFastAPI умно использует `root_path` внутри, так что всё просто работает.\n", "metadata": {"title": "За прокси‑сервером", "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "source_mtime": "2026-01-12T17:48:12.972741+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\behind-a-proxy.md"}, "doc_id": "58020370f2a0", "source_path": "docs\\advanced\\behind-a-proxy.md", "title": "За прокси‑сервером", "chunk_index": 21, "header": "Монтирование вложенного приложения", "header_level": 2, "token_count": 140}
{"id": "6183ebcfce3190d7", "text": "# Кастомные ответы — HTML, поток, файл и другие { #custom-response-html-stream-file-others }\n\nПо умолчанию **FastAPI** возвращает ответы с помощью `JSONResponse`.\n\nВы можете переопределить это, вернув `Response` напрямую, как показано в разделе [Вернуть Response напрямую](response-directly.md){.internal-link target=_blank}.\n\nНо если вы возвращаете `Response` напрямую (или любой его подкласс, например `JSONResponse`), данные не будут автоматически преобразованы (даже если вы объявили `response_model`), и документация не будет автоматически сгенерирована (например, со специфичным «типом содержимого» в HTTP-заголовке `Content-Type` как частью сгенерированного OpenAPI).\n\nНо вы можете также объявить `Response`, который хотите использовать (например, любой подкласс `Response`), в декораторе операции пути, используя параметр `response_class`.\n\nСодержимое, которое вы возвращаете из своей функции-обработчика пути, будет помещено внутрь этого `Response`.\n\nИ если у этого `Response` тип содержимого JSON (`application/json`), как в случае с `JSONResponse` и `UJSONResponse`, данные, которые вы возвращаете, будут автоматически преобразованы (и отфильтрованы) любым объявленным вами в декораторе операции пути Pydantic `response_model`.\n\n/// note | Примечание\n\nЕсли вы используете класс ответа без типа содержимого, FastAPI будет ожидать, что у вашего ответа нет содержимого, поэтому он не будет документировать формат ответа в сгенерированной документации OpenAPI.\n\n///\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 0, "header": "Кастомные ответы — HTML, поток, файл и другие", "header_level": 1, "token_count": 508}
{"id": "5e604cb771801750", "text": "## Используйте `ORJSONResponse` { #use-orjsonresponse }\n\nНапример, если вы выжимаете максимум производительности, вы можете установить и использовать <a href=\"https://github.com/ijl/orjson\" class=\"external-link\" target=\"_blank\">`orjson`</a> и задать ответ как `ORJSONResponse`.\n\nИмпортируйте класс (подкласс) `Response`, который вы хотите использовать, и объявите его в декораторе операции пути.\n\nДля больших ответов возвращать `Response` напрямую значительно быстрее, чем возвращать словарь.\n\nЭто потому, что по умолчанию FastAPI проверяет каждый элемент внутри и убеждается, что он сериализуем в JSON, используя тот же [JSON Compatible Encoder](../tutorial/encoder.md){.internal-link target=_blank}, объяснённый в руководстве. Это позволяет возвращать **произвольные объекты**, например модели из базы данных.\n\nНо если вы уверены, что содержимое, которое вы возвращаете, **сериализуемо в JSON**, вы можете передать его напрямую в класс ответа и избежать дополнительных накладных расходов, которые FastAPI понёс бы, пропуская возвращаемое содержимое через `jsonable_encoder` перед передачей в класс ответа.\n\n{* ../../docs_src/custom_response/tutorial001b_py39.py hl[2,7] *}\n\n/// info | Информация\n\nПараметр `response_class` также используется для указания «типа содержимого» ответа.\n\nВ этом случае HTTP-заголовок `Content-Type` будет установлен в `application/json`.\n\nИ это будет задокументировано как таковое в OpenAPI.\n\n///\n\n/// tip | Совет\n\n`ORJSONResponse` доступен только в FastAPI, а не в Starlette.\n\n///\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 1, "header": "Используйте `ORJSONResponse`", "header_level": 2, "token_count": 502}
{"id": "b61576003a66e4f9", "text": "## HTML-ответ { #html-response }\n\nЧтобы вернуть ответ с HTML напрямую из **FastAPI**, используйте `HTMLResponse`.\n\n- Импортируйте `HTMLResponse`.\n- Передайте `HTMLResponse` в параметр `response_class` вашего декоратора операции пути.\n\n{* ../../docs_src/custom_response/tutorial002_py39.py hl[2,7] *}\n\n/// info | Информация\n\nПараметр `response_class` также используется для указания «типа содержимого» ответа.\n\nВ этом случае HTTP-заголовок `Content-Type` будет установлен в `text/html`.\n\nИ это будет задокументировано как таковое в OpenAPI.\n\n///\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 2, "header": "HTML-ответ", "header_level": 2, "token_count": 173}
{"id": "9f9c277c8d68407b", "text": "### Вернуть `Response` { #return-a-response }\n\nКак показано в разделе [Вернуть Response напрямую](response-directly.md){.internal-link target=_blank}, вы также можете переопределить ответ прямо в своей операции пути, просто вернув его.\n\nТот же пример сверху, возвращающий `HTMLResponse`, может выглядеть так:\n\n{* ../../docs_src/custom_response/tutorial003_py39.py hl[2,7,19] *}\n\n/// warning | Предупреждение\n\n`Response`, возвращённый напрямую вашей функцией-обработчиком пути, не будет задокументирован в OpenAPI (например, `Content-Type` нне будет задокументирова) и не будет виден в автоматически сгенерированной интерактивной документации.\n\n///\n\n/// info | Информация\n\nРазумеется, фактические заголовок `Content-Type`, статус-код и т.д. возьмутся из объекта `Response`, который вы вернули.\n\n///\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 3, "header": "Вернуть `Response`", "header_level": 3, "token_count": 281}
{"id": "1e40032ba74ef1a2", "text": "### Задокументировать в OpenAPI и переопределить `Response` { #document-in-openapi-and-override-response }\n\nЕсли вы хотите переопределить ответ внутри функции, но при этом задокументировать «тип содержимого» в OpenAPI, вы можете использовать параметр `response_class` И вернуть объект `Response`.\n\nТогда `response_class` будет использоваться только для документирования *операции пути* в OpenAPI, а ваш `Response` будет использован как есть.\n\n#### Вернуть `HTMLResponse` напрямую { #return-an-htmlresponse-directly }\n\nНапример, это может быть что-то вроде:\n\n{* ../../docs_src/custom_response/tutorial004_py39.py hl[7,21,23] *}\n\nВ этом примере функция `generate_html_response()` уже генерирует и возвращает `Response` вместо возврата HTML в `str`.\n\nВозвращая результат вызова `generate_html_response()`, вы уже возвращаете `Response`, который переопределит поведение **FastAPI** по умолчанию.\n\nНо поскольку вы также передали `HTMLResponse` в `response_class`, **FastAPI** будет знать, как задокументировать это в OpenAPI и интерактивной документации как HTML с `text/html`:\n\n<img src=\"/img/tutorial/custom-response/image01.png\">\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 4, "header": "Задокументировать в OpenAPI и переопределить `Response`", "header_level": 3, "token_count": 330}
{"id": "979e06de402badab", "text": "## Доступные ответы { #available-responses }\n\nНиже перечислены некоторые доступные классы ответов.\n\nУчтите, что вы можете использовать `Response`, чтобы вернуть что угодно ещё, или даже создать собственный подкласс.\n\n/// note | Технические детали\n\nВы также могли бы использовать `from starlette.responses import HTMLResponse`.\n\n**FastAPI** предоставляет те же `starlette.responses` как `fastapi.responses` для вашего удобства как разработчика. Но большинство доступных классов ответов приходят непосредственно из Starlette.\n\n///\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 5, "header": "Доступные ответы", "header_level": 2, "token_count": 172}
{"id": "c4a00de55f73e244", "text": "### `Response` { #response }\n\nБазовый класс `Response`, от него наследуются все остальные ответы.\n\nЕго можно возвращать напрямую.\n\nОн принимает следующие параметры:\n\n- `content` — `str` или `bytes`.\n- `status_code` — целое число, HTTP статус-код.\n- `headers` — словарь строк.\n- `media_type` — строка, задающая тип содержимого. Например, `\"text/html\"`.\n\nFastAPI (фактически Starlette) автоматически добавит заголовок Content-Length. Также будет добавлен заголовок Content-Type, основанный на `media_type` и с добавлением charset для текстовых типов.\n\n{* ../../docs_src/response_directly/tutorial002_py39.py hl[1,18] *}\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 6, "header": "`Response`", "header_level": 3, "token_count": 205}
{"id": "c50e715f1e475394", "text": "### `HTMLResponse` { #htmlresponse }\n\nПринимает текст или байты и возвращает HTML-ответ, как описано выше.\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 7, "header": "`HTMLResponse`", "header_level": 3, "token_count": 35}
{"id": "32167d15ef04343a", "text": "### `PlainTextResponse` { #plaintextresponse }\n\nПринимает текст или байты и возвращает ответ в виде простого текста.\n\n{* ../../docs_src/custom_response/tutorial005_py39.py hl[2,7,9] *}\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 8, "header": "`PlainTextResponse`", "header_level": 3, "token_count": 52}
{"id": "e7057329957a22ef", "text": "### `JSONResponse` { #jsonresponse }\n\nПринимает данные и возвращает ответ, кодированный как `application/json`.\n\nЭто ответ по умолчанию, используемый в **FastAPI**, как было сказано выше.\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 9, "header": "`JSONResponse`", "header_level": 3, "token_count": 58}
{"id": "afcbec169aa18c4e", "text": "### `ORJSONResponse` { #orjsonresponse }\n\nБыстрая альтернативная реализация JSON-ответа с использованием <a href=\"https://github.com/ijl/orjson\" class=\"external-link\" target=\"_blank\">`orjson`</a>, как было сказано выше.\n\n/// info | Информация\n\nТребуется установка `orjson`, например командой `pip install orjson`.\n\n///\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 10, "header": "`ORJSONResponse`", "header_level": 3, "token_count": 110}
{"id": "0c3b45e0130ad7df", "text": "### `UJSONResponse` { #ujsonresponse }\n\nАльтернативная реализация JSON-ответа с использованием <a href=\"https://github.com/ultrajson/ultrajson\" class=\"external-link\" target=\"_blank\">`ujson`</a>.\n\n/// info | Информация\n\nТребуется установка `ujson`, например командой `pip install ujson`.\n\n///\n\n/// warning | Предупреждение\n\n`ujson` менее аккуратен, чем встроенная реализация Python, в обработке некоторых крайних случаев.\n\n///\n\n{* ../../docs_src/custom_response/tutorial001_py39.py hl[2,7] *}\n\n/// tip | Совет\n\nВозможно, `ORJSONResponse` окажется более быстрым вариантом.\n\n///\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 11, "header": "`UJSONResponse`", "header_level": 3, "token_count": 205}
{"id": "b1555e9d95adebb6", "text": "### `RedirectResponse` { #redirectresponse }\n\nВозвращает HTTP-редирект. По умолчанию использует статус-код 307 (Temporary Redirect — временное перенаправление).\n\nВы можете вернуть `RedirectResponse` напрямую:\n\n{* ../../docs_src/custom_response/tutorial006_py39.py hl[2,9] *}\n\n---\n\nИли можно использовать его в параметре `response_class`:\n\n{* ../../docs_src/custom_response/tutorial006b_py39.py hl[2,7,9] *}\n\nЕсли вы сделаете так, то сможете возвращать URL напрямую из своей функции-обработчика пути.\n\nВ этом случае будет использован статус-код по умолчанию для `RedirectResponse`, то есть `307`.\n\n---\n\nТакже вы можете использовать параметр `status_code` в сочетании с параметром `response_class`:\n\n{* ../../docs_src/custom_response/tutorial006c_py39.py hl[2,7,9] *}\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 12, "header": "`RedirectResponse`", "header_level": 3, "token_count": 238}
{"id": "6183ebcfce3190d7", "text": "### `StreamingResponse` { #streamingresponse }\n\nПринимает асинхронный генератор или обычный генератор/итератор и отправляет тело ответа потоково.\n\n{* ../../docs_src/custom_response/tutorial007_py39.py hl[2,14] *}\n\n#### Использование `StreamingResponse` с файлоподобными объектами { #using-streamingresponse-with-file-like-objects }\n\nЕсли у вас есть <a href=\"https://docs.python.org/3/glossary.html#term-file-like-object\" class=\"external-link\" target=\"_blank\">файлоподобный</a> объект (например, объект, возвращаемый `open()`), вы можете создать функцию-генератор для итерации по этому файлоподобному объекту.\n\nТаким образом, вам не нужно сначала читать всё в память, вы можете передать эту функцию-генератор в `StreamingResponse` и вернуть его.\n\nЭто включает многие библиотеки для работы с облачным хранилищем, обработки видео и т.д.\n\n{* ../../docs_src/custom_response/tutorial008_py39.py hl[2,10:12,14] *}\n\n1. Это функция-генератор. Она является «функцией-генератором», потому что содержит оператор(ы) `yield` внутри.\n2. Используя блок `with`, мы гарантируем, что файлоподобный объект будет закрыт после завершения работы функции-генератора. То есть после того, как она закончит отправку ответа.\n3. Этот `yield from` говорит функции итерироваться по объекту с именем `file_like`. И затем, для каждой итерации, отдавать эту часть как исходящую из этой функции-генератора (`iterfile`).", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md", "section_header": "`StreamingResponse`", "section_header_level": 3}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 13, "header": "`StreamingResponse`", "header_level": 3, "token_count": 492}
{"id": "5e604cb771801750", "text": "оворит функции итерироваться по объекту с именем `file_like`. И затем, для каждой итерации, отдавать эту часть как исходящую из этой функции-генератора (`iterfile`).\n\n   Таким образом, это функция-генератор, которая внутренне передаёт работу по «генерации» чему-то другому.\n\n   Делая это таким образом, мы можем поместить её в блок `with` и тем самым гарантировать, что файлоподобный объект будет закрыт после завершения.\n\n/// tip | Совет\n\nЗаметьте, что здесь мы используем стандартный `open()`, который не поддерживает `async` и `await`, поэтому объявляем операцию пути обычной `def`.\n\n///", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md", "section_header": "`StreamingResponse`", "section_header_level": 3}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 14, "header": "`StreamingResponse`", "header_level": 3, "token_count": 230}
{"id": "f0ef8fc6a39ca2d7", "text": "### `FileResponse` { #fileresponse }\n\nАсинхронно отправляет файл как ответ.\n\nДля создания экземпляра принимает иной набор аргументов, чем другие типы ответов:\n\n- `path` — путь к файлу, который будет отправлен.\n- `headers` — любые дополнительные заголовки для включения, в виде словаря.\n- `media_type` — строка, задающая тип содержимого. Если не задан, для определения типа содержимого будет использовано имя файла или путь.\n- `filename` — если задан, будет включён в заголовок ответа `Content-Disposition`.\n\nФайловые ответы будут содержать соответствующие заголовки `Content-Length`, `Last-Modified` и `ETag`.\n\n{* ../../docs_src/custom_response/tutorial009_py39.py hl[2,10] *}\n\nВы также можете использовать параметр `response_class`:\n\n{* ../../docs_src/custom_response/tutorial009b_py39.py hl[2,8,10] *}\n\nВ этом случае вы можете возвращать путь к файлу напрямую из своей функции-обработчика пути.\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 15, "header": "`FileResponse`", "header_level": 3, "token_count": 292}
{"id": "3422371d3bf47a52", "text": "## Пользовательский класс ответа { #custom-response-class }\n\nВы можете создать собственный класс ответа, унаследовавшись от `Response`, и использовать его.\n\nНапример, предположим, что вы хотите использовать <a href=\"https://github.com/ijl/orjson\" class=\"external-link\" target=\"_blank\">`orjson`</a>, но с некоторыми пользовательскими настройками, которые не используются во встроенном классе `ORJSONResponse`.\n\nСкажем, вы хотите, чтобы возвращался отформатированный JSON с отступами, то есть хотите использовать опцию orjson `orjson.OPT_INDENT_2`.\n\nВы могли бы создать `CustomORJSONResponse`. Главное, что вам нужно сделать — реализовать метод `Response.render(content)`, который возвращает содержимое как `bytes`:\n\n{* ../../docs_src/custom_response/tutorial009c_py39.py hl[9:14,17] *}\n\nТеперь вместо того, чтобы возвращать:\n\n```json\n{\"message\": \"Hello World\"}\n```\n\n...этот ответ вернёт:\n\n```json\n{\n  \"message\": \"Hello World\"\n}\n```\n\nРазумеется, вы наверняка найдёте гораздо более полезные способы воспользоваться этим, чем просто форматирование JSON. \n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 16, "header": "Пользовательский класс ответа", "header_level": 2, "token_count": 356}
{"id": "6a0a6d36de5f3ba2", "text": "## Класс ответа по умолчанию { #default-response-class }\n\nПри создании экземпляра класса **FastAPI** или `APIRouter` вы можете указать, какой класс ответа использовать по умолчанию.\n\nПараметр, который это определяет, — `default_response_class`.\n\nВ примере ниже **FastAPI** будет использовать `ORJSONResponse` по умолчанию во всех операциях пути вместо `JSONResponse`.\n\n{* ../../docs_src/custom_response/tutorial010_py39.py hl[2,4] *}\n\n/// tip | Совет\n\nВы по-прежнему можете переопределять `response_class` в операциях пути, как и раньше.\n\n///\n\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 17, "header": "Класс ответа по умолчанию", "header_level": 2, "token_count": 181}
{"id": "f9a58bfced21c02f", "text": "## Дополнительная документация { #additional-documentation }\n\nВы также можете объявить тип содержимого и многие другие детали в OpenAPI с помощью `responses`: [Дополнительные ответы в OpenAPI](additional-responses.md){.internal-link target=_blank}.\n", "metadata": {"title": "Кастомные ответы — HTML, поток, файл и другие", "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "source_mtime": "2026-01-12T17:48:12.976114+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\custom-response.md"}, "doc_id": "a571920790f0", "source_path": "docs\\advanced\\custom-response.md", "title": "Кастомные ответы — HTML, поток, файл и другие", "chunk_index": 18, "header": "Дополнительная документация", "header_level": 2, "token_count": 72}
{"id": "bdfb8357d8f70c9e", "text": "# Использование dataclasses { #using-dataclasses }\n\nFastAPI построен поверх **Pydantic**, и я показывал вам, как использовать Pydantic-модели для объявления HTTP-запросов и HTTP-ответов.\n\nНо FastAPI также поддерживает использование <a href=\"https://docs.python.org/3/library/dataclasses.html\" class=\"external-link\" target=\"_blank\">`dataclasses`</a> тем же способом:\n\n{* ../../docs_src/dataclasses_/tutorial001_py310.py hl[1,6:11,18:19] *}\n\nЭто по-прежнему поддерживается благодаря **Pydantic**, так как в нём есть <a href=\"https://docs.pydantic.dev/latest/concepts/dataclasses/#use-of-stdlib-dataclasses-with-basemodel\" class=\"external-link\" target=\"_blank\">встроенная поддержка `dataclasses`</a>.\n\nТак что даже если в коде выше Pydantic не используется явно, FastAPI использует Pydantic, чтобы конвертировать стандартные dataclasses в собственный вариант dataclasses от Pydantic.\n\nИ, конечно, поддерживаются те же возможности:\n\n- валидация данных\n- сериализация данных\n- документирование данных и т.д.\n\nЭто работает так же, как с Pydantic-моделями. И на самом деле под капотом это достигается тем же образом, с использованием Pydantic.\n\n/// info | Информация\n\nПомните, что dataclasses не умеют всего того, что умеют Pydantic-модели.\n\nПоэтому вам всё ещё может потребоваться использовать Pydantic-модели.\n\nНо если у вас уже есть набор dataclasses, это полезный приём — задействовать их для веб-API на FastAPI. \n\n///\n\n", "metadata": {"title": "Использование dataclasses", "doc_id": "66b1fcf49a2c", "source_path": "docs\\advanced\\dataclasses.md", "source_mtime": "2026-01-12T17:48:12.980692+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\dataclasses.md"}, "doc_id": "66b1fcf49a2c", "source_path": "docs\\advanced\\dataclasses.md", "title": "Использование dataclasses", "chunk_index": 0, "header": "Использование dataclasses", "header_level": 1, "token_count": 489}
{"id": "615f7b753dff5e6a", "text": "## Dataclasses в `response_model` { #dataclasses-in-response-model }\n\nВы также можете использовать `dataclasses` в параметре `response_model`:\n\n{* ../../docs_src/dataclasses_/tutorial002_py310.py hl[1,6:12,18] *}\n\nЭтот dataclass будет автоматически преобразован в Pydantic dataclass.\n\nТаким образом, его схема появится в интерфейсе документации API:\n\n<img src=\"/img/tutorial/dataclasses/image01.png\">\n\n", "metadata": {"title": "Использование dataclasses", "doc_id": "66b1fcf49a2c", "source_path": "docs\\advanced\\dataclasses.md", "source_mtime": "2026-01-12T17:48:12.980692+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\dataclasses.md"}, "doc_id": "66b1fcf49a2c", "source_path": "docs\\advanced\\dataclasses.md", "title": "Использование dataclasses", "chunk_index": 1, "header": "Dataclasses в `response_model`", "header_level": 2, "token_count": 121}
{"id": "bdfb8357d8f70c9e", "text": "## Dataclasses во вложенных структурах данных { #dataclasses-in-nested-data-structures }\n\nВы также можете комбинировать `dataclasses` с другими аннотациями типов, чтобы создавать вложенные структуры данных.\n\nВ некоторых случаях вам всё же может понадобиться использовать версию `dataclasses` из Pydantic. Например, если у вас возникают ошибки с автоматически генерируемой документацией API.\n\nВ таком случае вы можете просто заменить стандартные `dataclasses` на `pydantic.dataclasses`, которая является полностью совместимой заменой (drop-in replacement):\n\n{* ../../docs_src/dataclasses_/tutorial003_py310.py hl[1,4,7:10,13:16,22:24,27] *}\n\n1. Мы по-прежнему импортируем `field` из стандартных `dataclasses`.\n\n2. `pydantic.dataclasses` — полностью совместимая замена (drop-in replacement) для `dataclasses`.\n\n3. Dataclass `Author` содержит список dataclass `Item`.\n\n4. Dataclass `Author` используется в параметре `response_model`.\n\n5. Вы можете использовать и другие стандартные аннотации типов вместе с dataclasses в качестве тела запроса.\n\n    В этом случае это список dataclass `Item`.\n\n6. Здесь мы возвращаем словарь, содержащий `items`, который является списком dataclass.\n\n    FastAPI по-прежнему способен <abbr title=\"преобразование данных в формат, который можно передавать\">сериализовать</abbr> данные в JSON.\n\n7. Здесь `response_model` использует аннотацию типа — список dataclass `Author`.\n\n    Снова, вы можете комбинировать `dataclasses` со стандартными аннотациями типов.", "metadata": {"title": "Использование dataclasses", "doc_id": "66b1fcf49a2c", "source_path": "docs\\advanced\\dataclasses.md", "source_mtime": "2026-01-12T17:48:12.980692+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\dataclasses.md", "section_header": "Dataclasses во вложенных структурах данных", "section_header_level": 2}, "doc_id": "66b1fcf49a2c", "source_path": "docs\\advanced\\dataclasses.md", "title": "Использование dataclasses", "chunk_index": 2, "header": "Dataclasses во вложенных структурах данных", "header_level": 2, "token_count": 512}
{"id": "615f7b753dff5e6a", "text": "abbr> данные в JSON.\n\n7. Здесь `response_model` использует аннотацию типа — список dataclass `Author`.\n\n    Снова, вы можете комбинировать `dataclasses` со стандартными аннотациями типов.\n\n8. Обратите внимание, что эта *функция-обработчик пути* использует обычный `def` вместо `async def`.\n\n    Как и всегда в FastAPI, вы можете сочетать `def` и `async def` по необходимости.\n\n    Если хотите освежить в памяти, когда что использовать, посмотрите раздел _\"Нет времени?\"_ в документации про [`async` и `await`](../async.md#in-a-hurry){.internal-link target=_blank}.\n\n9. Эта *функция-обработчик пути* возвращает не dataclasses (хотя могла бы), а список словарей с внутренними данными.\n\n    FastAPI использует параметр `response_model` (в котором заданы dataclasses), чтобы преобразовать HTTP-ответ.\n\nВы можете комбинировать `dataclasses` с другими аннотациями типов множеством способов, чтобы формировать сложные структуры данных.\n\nСмотрите подсказки в коде выше, чтобы увидеть более конкретные детали.", "metadata": {"title": "Использование dataclasses", "doc_id": "66b1fcf49a2c", "source_path": "docs\\advanced\\dataclasses.md", "source_mtime": "2026-01-12T17:48:12.980692+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\dataclasses.md", "section_header": "Dataclasses во вложенных структурах данных", "section_header_level": 2}, "doc_id": "66b1fcf49a2c", "source_path": "docs\\advanced\\dataclasses.md", "title": "Использование dataclasses", "chunk_index": 3, "header": "Dataclasses во вложенных структурах данных", "header_level": 2, "token_count": 361}
{"id": "cd655a7080d0f82f", "text": "## Узнать больше { #learn-more }\n\nВы также можете комбинировать `dataclasses` с другими Pydantic-моделями, наследоваться от них, включать их в свои модели и т.д.\n\nЧтобы узнать больше, посмотрите <a href=\"https://docs.pydantic.dev/latest/concepts/dataclasses/\" class=\"external-link\" target=\"_blank\">документацию Pydantic о dataclasses</a>.\n\n", "metadata": {"title": "Использование dataclasses", "doc_id": "66b1fcf49a2c", "source_path": "docs\\advanced\\dataclasses.md", "source_mtime": "2026-01-12T17:48:12.980692+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\dataclasses.md"}, "doc_id": "66b1fcf49a2c", "source_path": "docs\\advanced\\dataclasses.md", "title": "Использование dataclasses", "chunk_index": 4, "header": "Узнать больше", "header_level": 2, "token_count": 117}
{"id": "94dd485302750225", "text": "## Версия { #version }\n\nДоступно начиная с версии FastAPI `0.67.0`.\n", "metadata": {"title": "Использование dataclasses", "doc_id": "66b1fcf49a2c", "source_path": "docs\\advanced\\dataclasses.md", "source_mtime": "2026-01-12T17:48:12.980692+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\dataclasses.md"}, "doc_id": "66b1fcf49a2c", "source_path": "docs\\advanced\\dataclasses.md", "title": "Использование dataclasses", "chunk_index": 5, "header": "Версия", "header_level": 2, "token_count": 29}
{"id": "b40bdad02e616524", "text": "# События lifespan { #lifespan-events }\n\nВы можете определить логику (код), которую нужно выполнить перед тем, как приложение начнет запускаться. Это означает, что этот код будет выполнен один раз, перед тем как приложение начнет получать HTTP-запросы.\n\nАналогично, вы можете определить логику (код), которую нужно выполнить, когда приложение завершает работу. В этом случае код будет выполнен один раз, после обработки, возможно, многих запросов.\n\nПоскольку этот код выполняется до того, как приложение начинает принимать запросы, и сразу после того, как оно заканчивает их обрабатывать, он охватывает весь lifespan (жизненный цикл) приложения (слово «lifespan» станет важным через секунду ).\n\nЭто может быть очень полезно для настройки ресурсов, которые нужны для всего приложения, которые разделяются между запросами и/или которые нужно затем очистить. Например, пул подключений к базе данных или загрузка общей модели Машинного обучения.\n\n", "metadata": {"title": "События lifespan", "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "source_mtime": "2026-01-12T17:48:12.986346+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\events.md"}, "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "title": "События lifespan", "chunk_index": 0, "header": "События lifespan", "header_level": 1, "token_count": 349}
{"id": "8505859c660b90b3", "text": "## Вариант использования { #use-case }\n\nНачнем с примера варианта использования, а затем посмотрим, как это решить.\n\nПредставим, что у вас есть несколько моделей Машинного обучения, которые вы хотите использовать для обработки запросов. \n\nЭти же модели разделяются между запросами, то есть это не одна модель на запрос, не одна на пользователя и т.п.\n\nПредставим, что загрузка модели может занимать довольно много времени, потому что ей нужно прочитать много данных с диска. Поэтому вы не хотите делать это для каждого запроса.\n\nВы могли бы загрузить её на верхнем уровне модуля/файла, но это означало бы, что модель загружается даже если вы просто запускаете простой автоматический тест; тогда этот тест будет медленным, так как ему придется ждать загрузки модели перед запуском независимой части кода.\n\nИменно это мы и решим: давайте загружать модель перед тем, как начнётся обработка запросов, но только непосредственно перед тем, как приложение начнет принимать запросы, а не во время загрузки кода.\n\n", "metadata": {"title": "События lifespan", "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "source_mtime": "2026-01-12T17:48:12.986346+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\events.md"}, "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "title": "События lifespan", "chunk_index": 1, "header": "Вариант использования", "header_level": 2, "token_count": 376}
{"id": "e1857bb87c143dba", "text": "## Lifespan { #lifespan }\n\nВы можете определить логику для startup и shutdown, используя параметр `lifespan` приложения `FastAPI` и «менеджер контекста» (через секунду покажу что это).\n\nНачнем с примера, а затем разберём его подробнее.\n\nМы создаём асинхронную функцию `lifespan()` с `yield` примерно так:\n\n{* ../../docs_src/events/tutorial003_py39.py hl[16,19] *}\n\nЗдесь мы симулируем дорогую операцию startup по загрузке модели, помещая (фиктивную) функцию модели в словарь с моделями Машинного обучения до `yield`. Этот код будет выполнен до того, как приложение начнет принимать запросы, во время startup.\n\nА затем сразу после `yield` мы выгружаем модель. Этот код будет выполнен после того, как приложение закончит обрабатывать запросы, непосредственно перед shutdown. Это может, например, освободить ресурсы, такие как память или GPU.\n\n/// tip | Совет\n\n`shutdown` произойдёт, когда вы останавливаете приложение.\n\nВозможно, вам нужно запустить новую версию, или вы просто устали от него. \n\n///\n\n", "metadata": {"title": "События lifespan", "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "source_mtime": "2026-01-12T17:48:12.986346+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\events.md"}, "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "title": "События lifespan", "chunk_index": 2, "header": "Lifespan", "header_level": 2, "token_count": 378}
{"id": "fb4cec1c24f1303c", "text": "### Функция lifespan { #lifespan-function }\n\nПервое, на что стоит обратить внимание, — мы определяем асинхронную функцию с `yield`. Это очень похоже на Зависимости с `yield`.\n\n{* ../../docs_src/events/tutorial003_py39.py hl[14:19] *}\n\nПервая часть функции, до `yield`, будет выполнена до запуска приложения.\n\nА часть после `yield` будет выполнена после завершения работы приложения.\n\n", "metadata": {"title": "События lifespan", "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "source_mtime": "2026-01-12T17:48:12.986346+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\events.md"}, "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "title": "События lifespan", "chunk_index": 3, "header": "Функция lifespan", "header_level": 3, "token_count": 130}
{"id": "fab9f08ac15537be", "text": "### Асинхронный менеджер контекста { #async-context-manager }\n\nЕсли присмотреться, функция декорирована `@asynccontextmanager`.\n\nЭто превращает функцию в «асинхронный менеджер контекста».\n\n{* ../../docs_src/events/tutorial003_py39.py hl[1,13] *}\n\nМенеджер контекста в Python — это то, что можно использовать в операторе `with`. Например, `open()` можно использовать как менеджер контекста:\n\n```Python\nwith open(\"file.txt\") as file:\n    file.read()\n```\n\nВ последних версиях Python есть также асинхронный менеджер контекста. Его используют с `async with`:\n\n```Python\nasync with lifespan(app):\n    await do_stuff()\n```\n\nКогда вы создаёте менеджер контекста или асинхронный менеджер контекста, как выше, он перед входом в блок `with` выполнит код до `yield`, а после выхода из блока `with` выполнит код после `yield`.\n\nВ нашем примере выше мы не используем его напрямую, а передаём его в FastAPI, чтобы он использовал его сам.\n\nПараметр `lifespan` приложения `FastAPI` принимает асинхронный менеджер контекста, поэтому мы можем передать ему наш новый асинхронный менеджер контекста `lifespan`.\n\n{* ../../docs_src/events/tutorial003_py39.py hl[22] *}\n\n", "metadata": {"title": "События lifespan", "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "source_mtime": "2026-01-12T17:48:12.986346+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\events.md"}, "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "title": "События lifespan", "chunk_index": 4, "header": "Асинхронный менеджер контекста", "header_level": 3, "token_count": 406}
{"id": "b9843389045b6668", "text": "## Альтернативные события (устаревшие) { #alternative-events-deprecated }\n\n/// warning | Предупреждение\n\nРекомендуемый способ обрабатывать startup и shutdown — использовать параметр `lifespan` приложения `FastAPI`, как описано выше. Если вы укажете параметр `lifespan`, обработчики событий `startup` и `shutdown` больше вызываться не будут. Либо всё через `lifespan`, либо всё через события — не одновременно.\n\nЭту часть, скорее всего, можно пропустить.\n\n///\n\nЕсть альтернативный способ определить логику, которую нужно выполнить во время startup и во время shutdown.\n\nВы можете определить обработчики событий (функции), которые нужно выполнить до старта приложения или при его завершении.\n\nЭти функции можно объявить с `async def` или обычным `def`.\n\n", "metadata": {"title": "События lifespan", "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "source_mtime": "2026-01-12T17:48:12.986346+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\events.md"}, "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "title": "События lifespan", "chunk_index": 5, "header": "Альтернативные события (устаревшие)", "header_level": 2, "token_count": 269}
{"id": "b5a0fed85a6f463b", "text": "### Событие `startup` { #startup-event }\n\nЧтобы добавить функцию, которую нужно запустить до старта приложения, объявите её как обработчик события `\"startup\"`:\n\n{* ../../docs_src/events/tutorial001_py39.py hl[8] *}\n\nВ этом случае функция-обработчик события `startup` инициализирует «базу данных» items (это просто `dict`) некоторыми значениями.\n\nВы можете добавить более одного обработчика события.\n\nИ ваше приложение не начнет принимать запросы, пока все обработчики события `startup` не завершатся.\n\n", "metadata": {"title": "События lifespan", "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "source_mtime": "2026-01-12T17:48:12.986346+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\events.md"}, "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "title": "События lifespan", "chunk_index": 6, "header": "Событие `startup`", "header_level": 3, "token_count": 174}
{"id": "dcdaf87b3a514160", "text": "### Событие `shutdown` { #shutdown-event }\n\nЧтобы добавить функцию, которую нужно запустить при завершении работы приложения, объявите её как обработчик события `\"shutdown\"`:\n\n{* ../../docs_src/events/tutorial002_py39.py hl[6] *}\n\nЗдесь функция-обработчик события `shutdown` запишет строку текста `\"Application shutdown\"` в файл `log.txt`.\n\n/// info | Информация\n\nВ функции `open()` параметр `mode=\"a\"` означает «добавление» (append), то есть строка будет добавлена в конец файла, без перезаписи предыдущего содержимого.\n\n///\n\n/// tip | Совет\n\nОбратите внимание, что в этом случае мы используем стандартную Python-функцию `open()`, которая взаимодействует с файлом.\n\nТо есть это I/O (ввод/вывод), требующий «ожидания» записи на диск.\n\nНо `open()` не использует `async` и `await`.\n\nПоэтому мы объявляем обработчик события обычным `def` вместо `async def`.\n\n///\n\n", "metadata": {"title": "События lifespan", "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "source_mtime": "2026-01-12T17:48:12.986346+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\events.md"}, "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "title": "События lifespan", "chunk_index": 7, "header": "Событие `shutdown`", "header_level": 3, "token_count": 297}
{"id": "5c7a6c921665e9ca", "text": "### `startup` и `shutdown` вместе { #startup-and-shutdown-together }\n\nС высокой вероятностью логика для вашего startup и shutdown связана: вы можете хотеть что-то запустить, а затем завершить, получить ресурс, а затем освободить его и т.д.\n\nДелать это в отдельных функциях, которые не разделяют общую логику или переменные, сложнее, так как придётся хранить значения в глобальных переменных или использовать похожие приёмы.\n\nПоэтому теперь рекомендуется использовать `lifespan`, как описано выше.\n\n", "metadata": {"title": "События lifespan", "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "source_mtime": "2026-01-12T17:48:12.986346+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\events.md"}, "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "title": "События lifespan", "chunk_index": 8, "header": "`startup` и `shutdown` вместе", "header_level": 3, "token_count": 187}
{"id": "0bc043ac02217ea0", "text": "## Технические детали { #technical-details }\n\nНемного технических подробностей для любопытных умников. \n\nПод капотом, в ASGI-технической спецификации, это часть <a href=\"https://asgi.readthedocs.io/en/latest/specs/lifespan.html\" class=\"external-link\" target=\"_blank\">Протокола Lifespan</a>, и он определяет события `startup` и `shutdown`.\n\n/// info | Информация\n\nВы можете прочитать больше про обработчики `lifespan` в Starlette в <a href=\"https://www.starlette.dev/lifespan/\" class=\"external-link\" target=\"_blank\">документации Starlette по Lifespan</a>.\n\nВключая то, как работать с состоянием lifespan, которое можно использовать в других частях вашего кода.\n\n///\n\n", "metadata": {"title": "События lifespan", "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "source_mtime": "2026-01-12T17:48:12.986346+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\events.md"}, "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "title": "События lifespan", "chunk_index": 9, "header": "Технические детали", "header_level": 2, "token_count": 231}
{"id": "c5a3ec4703c4871f", "text": "## Подприложения { #sub-applications }\n\n Имейте в виду, что эти события lifespan (startup и shutdown) будут выполнены только для основного приложения, а не для [Подприложения — Mounts](sub-applications.md){.internal-link target=_blank}.\n", "metadata": {"title": "События lifespan", "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "source_mtime": "2026-01-12T17:48:12.986346+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\events.md"}, "doc_id": "c1d8af000e0f", "source_path": "docs\\advanced\\events.md", "title": "События lifespan", "chunk_index": 10, "header": "Подприложения", "header_level": 2, "token_count": 72}
{"id": "a2da6fabdd4da832", "text": "# Генерация SDK { #generating-sdks }\n\nПоскольку **FastAPI** основан на спецификации **OpenAPI**, его API можно описать в стандартном формате, понятном множеству инструментов.\n\nЭто упрощает генерацию актуальной **документации**, клиентских библиотек (<abbr title=\"Software Development Kits – Наборы средств разработки\">**SDKs**</abbr>) на разных языках, а также **тестирования** или **воркфлоу автоматизации**, которые остаются синхронизированными с вашим кодом.\n\nВ этом руководстве вы узнаете, как сгенерировать **TypeScript SDK** для вашего бэкенда на FastAPI.\n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 0, "header": "Генерация SDK", "header_level": 1, "token_count": 218}
{"id": "65188b2756c5ad91", "text": "## Генераторы SDK с открытым исходным кодом { #open-source-sdk-generators }\n\nГибкий вариант — <a href=\"https://openapi-generator.tech/\" class=\"external-link\" target=\"_blank\">OpenAPI Generator</a>, который поддерживает **многие языки программирования** и умеет генерировать SDK из вашей спецификации OpenAPI.\n\nДля **TypeScript‑клиентов** <a href=\"https://heyapi.dev/\" class=\"external-link\" target=\"_blank\">Hey API</a> — специализированное решение, обеспечивающее оптимальный опыт для экосистемы TypeScript.\n\nБольше генераторов SDK можно найти на <a href=\"https://openapi.tools/#sdk\" class=\"external-link\" target=\"_blank\">OpenAPI.Tools</a>.\n\n/// tip | Совет\n\nFastAPI автоматически генерирует спецификации **OpenAPI 3.1**, поэтому любой используемый инструмент должен поддерживать эту версию.\n\n///\n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 1, "header": "Генераторы SDK с открытым исходным кодом", "header_level": 2, "token_count": 281}
{"id": "a2da6fabdd4da832", "text": "## Генераторы SDK от спонсоров FastAPI { #sdk-generators-from-fastapi-sponsors }\n\nВ этом разделе представлены решения с **венчурной поддержкой** и **поддержкой компаний** от компаний, которые спонсируют FastAPI. Эти продукты предоставляют **дополнительные возможности** и **интеграции** сверх высококачественно генерируемых SDK.\n\nБлагодаря  [**спонсорству FastAPI**](../help-fastapi.md#sponsor-the-author){.internal-link target=_blank}  эти компании помогают обеспечивать, чтобы фреймворк и его **экосистема** оставались здоровыми и **устойчивыми**.\n\nИх спонсорство также демонстрирует серьёзную приверженность **сообществу** FastAPI (вам), показывая, что им важно не только предоставлять **отличный сервис**, но и поддерживать **надёжный и процветающий фреймворк** FastAPI. \n\nНапример, вы можете попробовать:\n\n* <a href=\"https://speakeasy.com/editor?utm_source=fastapi+repo&utm_medium=github+sponsorship\" class=\"external-link\" target=\"_blank\">Speakeasy</a>\n* <a href=\"https://www.stainless.com/?utm_source=fastapi&utm_medium=referral\" class=\"external-link\" target=\"_blank\">Stainless</a>\n* <a href=\"https://developers.liblab.com/tutorials/sdk-for-fastapi?utm_source=fastapi\" class=\"external-link\" target=\"_blank\">liblab</a>", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md", "section_header": "Генераторы SDK от спонсоров FastAPI", "section_header_level": 2}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 2, "header": "Генераторы SDK от спонсоров FastAPI", "header_level": 2, "token_count": 451}
{"id": "65188b2756c5ad91", "text": "/?utm_source=fastapi&utm_medium=referral\" class=\"external-link\" target=\"_blank\">Stainless</a>\n* <a href=\"https://developers.liblab.com/tutorials/sdk-for-fastapi?utm_source=fastapi\" class=\"external-link\" target=\"_blank\">liblab</a>\n\nНекоторые из этих решений также могут быть open source или иметь бесплатные тарифы, так что вы сможете попробовать их без финансовых затрат. Другие коммерческие генераторы SDK доступны и их можно найти онлайн.", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md", "section_header": "Генераторы SDK от спонсоров FastAPI", "section_header_level": 2}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 3, "header": "Генераторы SDK от спонсоров FastAPI", "header_level": 2, "token_count": 152}
{"id": "a1b9859845d13f30", "text": "## Создать TypeScript SDK { #create-a-typescript-sdk }\n\nНачнём с простого приложения FastAPI:\n\n{* ../../docs_src/generate_clients/tutorial001_py39.py hl[7:9,12:13,16:17,21] *}\n\nОбратите внимание, что *операции пути (обработчики пути)* определяют модели, которые они используют для полезной нагрузки запроса и полезной нагрузки ответа, с помощью моделей `Item` и `ResponseMessage`.\n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 4, "header": "Создать TypeScript SDK", "header_level": 2, "token_count": 133}
{"id": "979c30d27a70e3d3", "text": "### Документация API { #api-docs }\n\nЕсли перейти на `/docs`, вы увидите **схемы** данных, отправляемых в запросах и принимаемых в ответах:\n\n<img src=\"/img/tutorial/generate-clients/image01.png\">\n\nВы видите эти схемы, потому что они были объявлены с моделями в приложении.\n\nЭта информация доступна в **схеме OpenAPI** приложения и затем отображается в документации API.\n\nТа же информация из моделей, включённая в OpenAPI, может использоваться для **генерации клиентского кода**.\n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 5, "header": "Документация API", "header_level": 3, "token_count": 163}
{"id": "195d62ec7b9187a0", "text": "### Hey API { #hey-api }\n\nКак только у нас есть приложение FastAPI с моделями, мы можем использовать Hey API для генерации TypeScript‑клиента. Самый быстрый способ сделать это — через npx.\n\n```sh\nnpx @hey-api/openapi-ts -i http://localhost:8000/openapi.json -o src/client\n```\n\nЭто сгенерирует TypeScript SDK в `./src/client`.\n\nВы можете узнать, как <a href=\"https://heyapi.dev/openapi-ts/get-started\" class=\"external-link\" target=\"_blank\">установить `@hey-api/openapi-ts`</a> и почитать о <a href=\"https://heyapi.dev/openapi-ts/output\" class=\"external-link\" target=\"_blank\">сгенерированном результате</a> на их сайте.\n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 6, "header": "Hey API", "header_level": 3, "token_count": 202}
{"id": "0ccab5da99f3299f", "text": "### Использование SDK { #using-the-sdk }\n\nТеперь вы можете импортировать и использовать клиентский код. Это может выглядеть так, обратите внимание, что вы получаете автозавершение для методoв:\n\n<img src=\"/img/tutorial/generate-clients/image02.png\">\n\nВы также получите автозавершение для отправляемой полезной нагрузки:\n\n<img src=\"/img/tutorial/generate-clients/image03.png\">\n\n/// tip | Совет\n\nОбратите внимание на автозавершение для `name` и `price`, это было определено в приложении FastAPI, в модели `Item`.\n\n///\n\nВы получите ошибки прямо в редакторе для отправляемых данных:\n\n<img src=\"/img/tutorial/generate-clients/image04.png\">\n\nОбъект ответа также будет иметь автозавершение:\n\n<img src=\"/img/tutorial/generate-clients/image05.png\">\n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 7, "header": "Использование SDK", "header_level": 3, "token_count": 234}
{"id": "59505f5f5c4bc07b", "text": "## Приложение FastAPI с тегами { #fastapi-app-with-tags }\n\nВо многих случаях ваше приложение FastAPI будет больше, и вы, вероятно, будете использовать теги, чтобы разделять разные группы *операций пути*.\n\nНапример, у вас может быть раздел для **items** и другой раздел для **users**, и они могут быть разделены тегами:\n\n{* ../../docs_src/generate_clients/tutorial002_py39.py hl[21,26,34] *}\n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 8, "header": "Приложение FastAPI с тегами", "header_level": 2, "token_count": 135}
{"id": "399f80bad35ef437", "text": "### Генерация TypeScript‑клиента с тегами { #generate-a-typescript-client-with-tags }\n\nЕсли вы генерируете клиент для приложения FastAPI с использованием тегов, обычно клиентский код также будет разделён по тегам.\n\nТаким образом вы сможете иметь всё правильно упорядоченным и сгруппированным в клиентском коде:\n\n<img src=\"/img/tutorial/generate-clients/image06.png\">\n\nВ этом случае у вас есть:\n\n* `ItemsService`\n* `UsersService`\n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 9, "header": "Генерация TypeScript‑клиента с тегами", "header_level": 3, "token_count": 147}
{"id": "9be5e7c2b63eecf3", "text": "### Имена методов клиента { #client-method-names }\n\nСейчас сгенерированные имена методов вроде `createItemItemsPost` выглядят не очень аккуратно:\n\n```TypeScript\nItemsService.createItemItemsPost({name: \"Plumbus\", price: 5})\n```\n\n...это потому, что генератор клиента использует внутренний **ID операции** OpenAPI для каждой *операции пути*.\n\nOpenAPI требует, чтобы каждый ID операции был уникален среди всех *операций пути*, поэтому FastAPI использует **имя функции**, **путь** и **HTTP‑метод/операцию** для генерации этого ID операции, так как таким образом можно гарантировать уникальность ID операций.\n\nНо далее я покажу, как это улучшить. \n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 10, "header": "Имена методов клиента", "header_level": 3, "token_count": 232}
{"id": "cf389544d2de7f6d", "text": "## Пользовательские ID операций и лучшие имена методов { #custom-operation-ids-and-better-method-names }\n\nВы можете **изменить** способ **генерации** этих ID операций, чтобы сделать их проще, а имена методов в клиентах — **более простыми**.\n\nВ этом случае вам нужно будет обеспечить, чтобы каждый ID операции был **уникальным** другим способом.\n\nНапример, вы можете гарантировать, что у каждой *операции пути* есть тег, и затем генерировать ID операции на основе **тега** и **имени** *операции пути* (имени функции).\n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 11, "header": "Пользовательские ID операций и лучшие имена методов", "header_level": 2, "token_count": 197}
{"id": "c9b03a741d8aa346", "text": "### Пользовательская функция генерации уникального ID { #custom-generate-unique-id-function }\n\nFastAPI использует **уникальный ID** для каждой *операции пути*, который применяется для **ID операции**, а также для имён любых необходимых пользовательских моделей запросов или ответов.\n\nВы можете кастомизировать эту функцию. Она принимает `APIRoute` и возвращает строку.\n\nНапример, здесь берётся первый тег (скорее всего у вас один тег) и имя *операции пути* (имя функции).\n\nЗатем вы можете передать эту пользовательскую функцию в **FastAPI** через параметр `generate_unique_id_function`:\n\n{* ../../docs_src/generate_clients/tutorial003_py39.py hl[6:7,10] *}\n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 12, "header": "Пользовательская функция генерации уникального ID", "header_level": 3, "token_count": 218}
{"id": "37cef5282f8cd457", "text": "### Генерация TypeScript‑клиента с пользовательскими ID операций { #generate-a-typescript-client-with-custom-operation-ids }\n\nТеперь, если снова сгенерировать клиент, вы увидите, что имена методов улучшились:\n\n<img src=\"/img/tutorial/generate-clients/image07.png\">\n\nКак видите, теперь имена методов содержат тег, а затем имя функции; больше они не включают информацию из URL‑пути и HTTP‑операции.\n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 13, "header": "Генерация TypeScript‑клиента с пользовательскими ID операций", "header_level": 3, "token_count": 136}
{"id": "1648927923319e93", "text": "### Предобработка спецификации OpenAPI для генератора клиента { #preprocess-the-openapi-specification-for-the-client-generator }\n\nСгенерированном коде всё ещё есть **дублирующаяся информация**.\n\nМы уже знаем, что этот метод относится к **items**, потому что это слово есть в `ItemsService` (взято из тега), но при этом имя тега всё ещё добавлено префиксом к имени метода. \n\nСкорее всего мы захотим оставить это в OpenAPI в целом, так как это гарантирует, что ID операций будут **уникальны**.\n\nНо для сгенерированного клиента мы можем **модифицировать** ID операций OpenAPI непосредственно перед генерацией клиентов, чтобы сделать имена методов более приятными и **чистыми**.\n\nМы можем скачать OpenAPI JSON в файл `openapi.json`, а затем **убрать этот префикс‑тег** таким скриптом:\n\n{* ../../docs_src/generate_clients/tutorial004_py39.py *}\n\n//// tab | Node.js\n\n```Javascript\n{!> ../../docs_src/generate_clients/tutorial004.js!}\n```\n\n////\n\nПосле этого ID операций будут переименованы с чего‑то вроде `items-get_items` просто в `get_items`, и генератор клиента сможет создавать более простые имена методов.\n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 14, "header": "Предобработка спецификации OpenAPI для генератора клиента", "header_level": 3, "token_count": 402}
{"id": "dcf9043673b379da", "text": "### Генерация TypeScript‑клиента с предобработанным OpenAPI { #generate-a-typescript-client-with-the-preprocessed-openapi }\n\nТак как конечный результат теперь в файле `openapi.json`, нужно обновить входное расположение:\n\n```sh\nnpx @hey-api/openapi-ts -i ./openapi.json -o src/client\n```\n\nПосле генерации нового клиента у вас будут **чистые имена методов**, со всем **автозавершением**, **ошибками прямо в редакторе** и т.д.:\n\n<img src=\"/img/tutorial/generate-clients/image08.png\">\n\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 15, "header": "Генерация TypeScript‑клиента с предобработанным OpenAPI", "header_level": 3, "token_count": 163}
{"id": "b9248479b25725dd", "text": "## Преимущества { #benefits }\n\nПри использовании автоматически сгенерированных клиентов вы получите **автозавершение** для:\n\n* Методов.\n* Данных запроса — в теле запроса, query‑параметрах и т.д.\n* Данных ответа.\n\nУ вас также будут **ошибки прямо в редакторе** для всего.\n\nИ каждый раз, когда вы обновляете код бэкенда и **перегенерируете** фронтенд, в нём появятся новые *операции пути* как методы, старые будут удалены, а любые другие изменения отразятся в сгенерированном коде. \n\nЭто также означает, что если что‑то изменилось, это будет **отражено** в клиентском коде автоматически. И если вы **соберёте** клиент, он завершится с ошибкой, если где‑то есть **несоответствие** в используемых данных.\n\nТаким образом, вы **обнаружите многие ошибки** очень рано в цикле разработки, вместо того чтобы ждать, когда ошибки проявятся у конечных пользователей в продакшн, и затем пытаться отладить, в чём проблема.\n", "metadata": {"title": "Генерация SDK", "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "source_mtime": "2026-01-12T17:48:12.994407+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\generate-clients.md"}, "doc_id": "6a208211fdd5", "source_path": "docs\\advanced\\generate-clients.md", "title": "Генерация SDK", "chunk_index": 16, "header": "Преимущества", "header_level": 2, "token_count": 375}
{"id": "ebba04292abcdd2e", "text": "# Расширенное руководство пользователя { #advanced-user-guide }\n\n", "metadata": {"title": "Расширенное руководство пользователя", "doc_id": "2c75e9d87519", "source_path": "docs\\advanced\\index.md", "source_mtime": "2026-01-12T17:48:13.000455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\index.md"}, "doc_id": "2c75e9d87519", "source_path": "docs\\advanced\\index.md", "title": "Расширенное руководство пользователя", "chunk_index": 0, "header": "Расширенное руководство пользователя", "header_level": 1, "token_count": 20}
{"id": "af23fe2b1391422a", "text": "## Дополнительные возможности { #additional-features }\n\nОсновное [Учебник - Руководство пользователя](../tutorial/index.md){.internal-link target=_blank} должно быть достаточно, чтобы познакомить вас со всеми основными функциями **FastAPI**.\n\nВ следующих разделах вы увидите другие варианты, конфигурации и дополнительные возможности.\n\n/// tip | Совет\n\nСледующие разделы **не обязательно являются \"продвинутыми\"**.\n\nИ вполне возможно, что для вашего случая использования решение находится в одном из них.\n\n///\n\n", "metadata": {"title": "Расширенное руководство пользователя", "doc_id": "2c75e9d87519", "source_path": "docs\\advanced\\index.md", "source_mtime": "2026-01-12T17:48:13.000455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\index.md"}, "doc_id": "2c75e9d87519", "source_path": "docs\\advanced\\index.md", "title": "Расширенное руководство пользователя", "chunk_index": 1, "header": "Дополнительные возможности", "header_level": 2, "token_count": 184}
{"id": "19c9c3139898339e", "text": "## Сначала прочитайте Учебник - Руководство пользователя { #read-the-tutorial-first }\n\nВы все еще можете использовать большинство функций **FastAPI** со знаниями из [Учебник - Руководство пользователя](../tutorial/index.md){.internal-link target=_blank}.\n\nИ следующие разделы предполагают, что вы уже прочитали его, и предполагают, что вы знаете эти основные идеи.\n", "metadata": {"title": "Расширенное руководство пользователя", "doc_id": "2c75e9d87519", "source_path": "docs\\advanced\\index.md", "source_mtime": "2026-01-12T17:48:13.000455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\index.md"}, "doc_id": "2c75e9d87519", "source_path": "docs\\advanced\\index.md", "title": "Расширенное руководство пользователя", "chunk_index": 2, "header": "Сначала прочитайте Учебник - Руководство пользователя", "header_level": 2, "token_count": 128}
{"id": "0397bb04fc9090f9", "text": "# Расширенное использование middleware { #advanced-middleware }\n\nВ основном руководстве вы читали, как добавить [пользовательское middleware](../tutorial/middleware.md){.internal-link target=_blank} в ваше приложение.\n\nА затем — как работать с [CORS с помощью `CORSMiddleware`](../tutorial/cors.md){.internal-link target=_blank}.\n\nВ этом разделе посмотрим, как использовать другие middleware.\n\n", "metadata": {"title": "Расширенное использование middleware", "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "source_mtime": "2026-01-12T17:48:13.005990+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\middleware.md"}, "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "title": "Расширенное использование middleware", "chunk_index": 0, "header": "Расширенное использование middleware", "header_level": 1, "token_count": 115}
{"id": "d6911119f0339cab", "text": "## Добавление ASGI middleware { #adding-asgi-middlewares }\n\nТак как **FastAPI** основан на Starlette и реализует спецификацию <abbr title=\"Asynchronous Server Gateway Interface – Асинхронный шлюзовой интерфейс сервера\">ASGI</abbr>, вы можете использовать любое ASGI middleware.\n\nMiddleware не обязательно должно быть сделано специально для FastAPI или Starlette — достаточно, чтобы оно соответствовало спецификации ASGI.\n\nВ общем случае ASGI middleware — это классы, которые ожидают получить ASGI‑приложение первым аргументом.\n\nПоэтому в документации к сторонним ASGI middleware, скорее всего, вы увидите что‑то вроде:\n\n```Python\nfrom unicorn import UnicornMiddleware\n\napp = SomeASGIApp()\n\nnew_app = UnicornMiddleware(app, some_config=\"rainbow\")\n```\n\nНо FastAPI (точнее, Starlette) предоставляет более простой способ, который гарантирует корректную обработку внутренних ошибок сервера и корректную работу пользовательских обработчиков исключений.\n\nДля этого используйте `app.add_middleware()` (как в примере с CORS).\n\n```Python\nfrom fastapi import FastAPI\nfrom unicorn import UnicornMiddleware\n\napp = FastAPI()\n\napp.add_middleware(UnicornMiddleware, some_config=\"rainbow\")\n```\n\n`app.add_middleware()` принимает класс middleware в качестве первого аргумента и любые дополнительные аргументы, которые будут переданы этому middleware.\n\n", "metadata": {"title": "Расширенное использование middleware", "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "source_mtime": "2026-01-12T17:48:13.005990+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\middleware.md"}, "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "title": "Расширенное использование middleware", "chunk_index": 1, "header": "Добавление ASGI middleware", "header_level": 2, "token_count": 425}
{"id": "2f467dfda07f55ed", "text": "## Встроенные middleware { #integrated-middlewares }\n\n**FastAPI** включает несколько middleware для распространённых сценариев. Ниже рассмотрим, как их использовать.\n\n/// note | Технические детали\n\nВ следующих примерах вы также можете использовать `from starlette.middleware.something import SomethingMiddleware`.\n\n**FastAPI** предоставляет несколько middleware в `fastapi.middleware` для удобства разработчика. Но большинство доступных middleware приходит напрямую из Starlette.\n\n///\n\n", "metadata": {"title": "Расширенное использование middleware", "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "source_mtime": "2026-01-12T17:48:13.005990+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\middleware.md"}, "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "title": "Расширенное использование middleware", "chunk_index": 2, "header": "Встроенные middleware", "header_level": 2, "token_count": 147}
{"id": "e9410ae87407586d", "text": "## `HTTPSRedirectMiddleware` { #httpsredirectmiddleware }\n\nГарантирует, что все входящие запросы должны использовать либо `https`, либо `wss`.\n\nЛюбой входящий запрос по `http` или `ws` будет перенаправлен на безопасную схему.\n\n{* ../../docs_src/advanced_middleware/tutorial001_py39.py hl[2,6] *}\n\n", "metadata": {"title": "Расширенное использование middleware", "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "source_mtime": "2026-01-12T17:48:13.005990+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\middleware.md"}, "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "title": "Расширенное использование middleware", "chunk_index": 3, "header": "`HTTPSRedirectMiddleware`", "header_level": 2, "token_count": 99}
{"id": "c0ad209131d910e1", "text": "## `TrustedHostMiddleware` { #trustedhostmiddleware }\n\nГарантирует, что во всех входящих запросах корректно установлен `Host`‑заголовок, чтобы защититься от атак на HTTP‑заголовок Host.\n\n{* ../../docs_src/advanced_middleware/tutorial002_py39.py hl[2,6:8] *}\n\nПоддерживаются следующие аргументы:\n\n- `allowed_hosts` — список доменных имён, которые следует разрешить как имена хостов. Подстановки вида `*.example.com` поддерживаются для сопоставления поддоменов. Чтобы разрешить любой хост, используйте либо `allowed_hosts=[\"*\"]`, либо не добавляйте это middleware.\n- `www_redirect` — если установлено в True, запросы к не‑www версиям разрешённых хостов будут перенаправляться на их www‑аналоги. По умолчанию — `True`.\n\nЕсли входящий запрос не проходит валидацию, будет отправлен ответ `400`.\n\n", "metadata": {"title": "Расширенное использование middleware", "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "source_mtime": "2026-01-12T17:48:13.005990+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\middleware.md"}, "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "title": "Расширенное использование middleware", "chunk_index": 4, "header": "`TrustedHostMiddleware`", "header_level": 2, "token_count": 293}
{"id": "7c571e6d928b8fb2", "text": "## `GZipMiddleware` { #gzipmiddleware }\n\nОбрабатывает GZip‑ответы для любых запросов, которые включают `\"gzip\"` в заголовке `Accept-Encoding`.\n\nЭто middleware обрабатывает как обычные, так и потоковые ответы.\n\n{* ../../docs_src/advanced_middleware/tutorial003_py39.py hl[2,6] *}\n\nПоддерживаются следующие аргументы:\n\n- `minimum_size` — не сжимать GZip‑ом ответы, размер которых меньше этого минимального значения в байтах. По умолчанию — `500`.\n- `compresslevel` — уровень GZip‑сжатия. Целое число от 1 до 9. По умолчанию — `9`. Более низкое значение — быстреее сжатие, но больший размер файла; более высокое значение — более медленное сжатие, но меньший размер файла.\n\n", "metadata": {"title": "Расширенное использование middleware", "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "source_mtime": "2026-01-12T17:48:13.005990+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\middleware.md"}, "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "title": "Расширенное использование middleware", "chunk_index": 5, "header": "`GZipMiddleware`", "header_level": 2, "token_count": 250}
{"id": "92b47a49dd815ae2", "text": "## Другие middleware { #other-middlewares }\n\nСуществует много других ASGI middleware.\n\nНапример:\n\n- <a href=\"https://github.com/encode/uvicorn/blob/master/uvicorn/middleware/proxy_headers.py\" class=\"external-link\" target=\"_blank\">`ProxyHeadersMiddleware` от Uvicorn</a>\n- <a href=\"https://github.com/florimondmanca/msgpack-asgi\" class=\"external-link\" target=\"_blank\">MessagePack</a>\n\nЧтобы увидеть другие доступные middleware, посмотрите <a href=\"https://www.starlette.dev/middleware/\" class=\"external-link\" target=\"_blank\">документацию по middleware в Starlette</a> и <a href=\"https://github.com/florimondmanca/awesome-asgi\" class=\"external-link\" target=\"_blank\">список ASGI Awesome</a>.\n", "metadata": {"title": "Расширенное использование middleware", "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "source_mtime": "2026-01-12T17:48:13.005990+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\middleware.md"}, "doc_id": "fad782efdd93", "source_path": "docs\\advanced\\middleware.md", "title": "Расширенное использование middleware", "chunk_index": 6, "header": "Другие middleware", "header_level": 2, "token_count": 198}
{"id": "13fa035d5f3c24e0", "text": "# Обратные вызовы в OpenAPI { #openapi-callbacks }\n\nВы можете создать API с *операцией пути* (обработчиком пути), которая будет инициировать HTTP-запрос к *внешнему API*, созданному кем-то другим (скорее всего тем же разработчиком, который будет использовать ваш API).\n\nПроцесс, происходящий, когда ваше приложение API обращается к *внешнему API*, называется «callback» (обратный вызов). Программное обеспечение, написанное внешним разработчиком, отправляет HTTP-запрос вашему API, а затем ваш API выполняет обратный вызов, отправляя HTTP-запрос во *внешний API* (который, вероятно, тоже создал тот же разработчик).\n\nВ этом случае вам может понадобиться задокументировать, как должно выглядеть это внешнее API: какую *операцию пути* оно должно иметь, какое тело запроса ожидать, какой ответ возвращать и т.д.\n\n", "metadata": {"title": "Обратные вызовы в OpenAPI", "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "source_mtime": "2026-01-12T17:48:13.008000+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-callbacks.md"}, "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "title": "Обратные вызовы в OpenAPI", "chunk_index": 0, "header": "Обратные вызовы в OpenAPI", "header_level": 1, "token_count": 323}
{"id": "ea14bf3ceeeecafc", "text": "## Приложение с обратными вызовами { #an-app-with-callbacks }\n\nДавайте рассмотрим это на примере.\n\nПредставьте, что вы разрабатываете приложение, позволяющее создавать счета.\n\nЭти счета будут иметь `id`, `title` (необязательный), `customer` и `total`.\n\nПользователь вашего API (внешний разработчик) создаст счет в вашем API с помощью POST-запроса.\n\nЗатем ваш API (предположим) сделает следующее:\n\n* Отправит счет клиенту внешнего разработчика.\n* Получит оплату.\n* Отправит уведомление обратно пользователю API (внешнему разработчику).\n    * Это будет сделано отправкой POST-запроса (из *вашего API*) в *внешний API*, предоставленный этим внешним разработчиком (это и есть «callback»).\n\n", "metadata": {"title": "Обратные вызовы в OpenAPI", "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "source_mtime": "2026-01-12T17:48:13.008000+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-callbacks.md"}, "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "title": "Обратные вызовы в OpenAPI", "chunk_index": 1, "header": "Приложение с обратными вызовами", "header_level": 2, "token_count": 270}
{"id": "6439f82fd6005ce3", "text": "## Обычное приложение **FastAPI** { #the-normal-fastapi-app }\n\nСначала посмотрим, как будет выглядеть обычное приложение API до добавления обратного вызова.\n\nВ нём будет *операция пути*, которая получит тело запроса `Invoice`, и query-параметр `callback_url`, содержащий URL для обратного вызова.\n\nЭта часть вполне обычна, большая часть кода вам уже знакома:\n\n{* ../../docs_src/openapi_callbacks/tutorial001_py310.py hl[7:11,34:51] *}\n\n/// tip | Совет\n\nQuery-параметр `callback_url` использует тип Pydantic <a href=\"https://docs.pydantic.dev/latest/api/networks/\" class=\"external-link\" target=\"_blank\">Url</a>.\n\n///\n\nЕдинственное новое — это `callbacks=invoices_callback_router.routes` в качестве аргумента *декоратора операции пути*. Далее разберёмся, что это такое.\n\n", "metadata": {"title": "Обратные вызовы в OpenAPI", "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "source_mtime": "2026-01-12T17:48:13.008000+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-callbacks.md"}, "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "title": "Обратные вызовы в OpenAPI", "chunk_index": 2, "header": "Обычное приложение **FastAPI**", "header_level": 2, "token_count": 261}
{"id": "722ea1384edf0d4a", "text": "## Документирование обратного вызова { #documenting-the-callback }\n\nРеальный код обратного вызова будет сильно зависеть от вашего приложения API.\n\nИ, вероятно, он будет заметно отличаться от одного приложения к другому.\n\nЭто могут быть буквально одна-две строки кода, например:\n\n```Python\ncallback_url = \"https://example.com/api/v1/invoices/events/\"\nhttpx.post(callback_url, json={\"description\": \"Invoice paid\", \"paid\": True})\n```\n\nНо, возможно, самая важная часть обратного вызова — это убедиться, что пользователь вашего API (внешний разработчик) правильно реализует *внешний API* в соответствии с данными, которые *ваш API* будет отправлять в теле запроса обратного вызова и т.п.\n\nПоэтому далее мы добавим код, документирующий, как должен выглядеть этот *внешний API*, чтобы получать обратный вызов от *вашего API*.\n\nЭта документация отобразится в Swagger UI по адресу `/docs` в вашем API и позволит внешним разработчикам понять, как построить *внешний API*.\n\nВ этом примере сам обратный вызов не реализуется (это может быть всего одна строка кода), реализуется только часть с документацией.\n\n/// tip | Совет\n\nСам обратный вызов — это всего лишь HTTP-запрос.\n\nРеализуя обратный вызов, вы можете использовать, например, <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">HTTPX</a> или <a href=\"https://requests.readthedocs.io/\" class=\"external-link\" target=\"_blank\">Requests</a>.\n\n///\n\n", "metadata": {"title": "Обратные вызовы в OpenAPI", "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "source_mtime": "2026-01-12T17:48:13.008000+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-callbacks.md"}, "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "title": "Обратные вызовы в OpenAPI", "chunk_index": 3, "header": "Документирование обратного вызова", "header_level": 2, "token_count": 492}
{"id": "61e6ed324495cbdc", "text": "## Напишите код документации обратного вызова { #write-the-callback-documentation-code }\n\nЭтот код не будет выполняться в вашем приложении, он нужен только для *документирования* того, как должен выглядеть *внешний API*.\n\nНо вы уже знаете, как легко получить автоматическую документацию для API с **FastAPI**.\n\nМы используем те же знания, чтобы задокументировать, как должен выглядеть *внешний API*... создав *операции пути*, которые внешний API должен реализовать (те, которые ваш API будет вызывать).\n\n/// tip | Совет\n\nКогда вы пишете код для документирования обратного вызова, полезно представить, что вы — тот самый *внешний разработчик*. И что вы сейчас реализуете *внешний API*, а не *свой API*.\n\nВременное принятие этой точки зрения (внешнего разработчика) поможет интуитивно понять, куда поместить параметры, какую Pydantic-модель использовать для тела запроса, для ответа и т.д. во *внешнем API*.\n\n///\n\n", "metadata": {"title": "Обратные вызовы в OpenAPI", "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "source_mtime": "2026-01-12T17:48:13.008000+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-callbacks.md"}, "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "title": "Обратные вызовы в OpenAPI", "chunk_index": 4, "header": "Напишите код документации обратного вызова", "header_level": 2, "token_count": 352}
{"id": "187672603ebc7311", "text": "### Создайте `APIRouter` для обратного вызова { #create-a-callback-apirouter }\n\nСначала создайте новый `APIRouter`, который будет содержать один или несколько обратных вызовов.\n\n{* ../../docs_src/openapi_callbacks/tutorial001_py310.py hl[1,23] *}\n\n", "metadata": {"title": "Обратные вызовы в OpenAPI", "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "source_mtime": "2026-01-12T17:48:13.008000+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-callbacks.md"}, "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "title": "Обратные вызовы в OpenAPI", "chunk_index": 5, "header": "Создайте `APIRouter` для обратного вызова", "header_level": 3, "token_count": 73}
{"id": "03798118bd96937b", "text": "### Создайте *операцию пути* для обратного вызова { #create-the-callback-path-operation }\n\nЧтобы создать *операцию пути* для обратного вызова, используйте тот же `APIRouter`, который вы создали выше.\n\nОна должна выглядеть как обычная *операция пути* FastAPI:\n\n* Вероятно, в ней должно быть объявление тела запроса, например `body: InvoiceEvent`.\n* А также может быть объявление модели ответа, например `response_model=InvoiceEventReceived`.\n\n{* ../../docs_src/openapi_callbacks/tutorial001_py310.py hl[14:16,19:20,26:30] *}\n\nЕсть 2 основных отличия от обычной *операции пути*:\n\n* Ей не нужен реальный код, потому что ваше приложение никогда не будет вызывать эту функцию. Она используется только для документирования *внешнего API*. Поэтому в функции может быть просто `pass`.\n* *Путь* может содержать <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#key-expression\" class=\"external-link\" target=\"_blank\">выражение OpenAPI 3</a> (подробнее ниже), где можно использовать переменные с параметрами и части исходного HTTP-запроса, отправленного *вашему API*.\n\n", "metadata": {"title": "Обратные вызовы в OpenAPI", "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "source_mtime": "2026-01-12T17:48:13.008000+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-callbacks.md"}, "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "title": "Обратные вызовы в OpenAPI", "chunk_index": 6, "header": "Создайте *операцию пути* для обратного вызова", "header_level": 3, "token_count": 380}
{"id": "e2372033908f7d74", "text": "### Выражение пути для обратного вызова { #the-callback-path-expression }\n\n*Путь* обратного вызова может содержать <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#key-expression\" class=\"external-link\" target=\"_blank\">выражение OpenAPI 3</a>, которое может включать части исходного запроса, отправленного *вашему API*.\n\nВ нашем случае это `str`:\n\n```Python\n\"{$callback_url}/invoices/{$request.body.id}\"\n```\n\nИтак, если пользователь вашего API (внешний разработчик) отправляет HTTP-запрос вашему API по адресу:\n\n```\nhttps://yourapi.com/invoices/?callback_url=https://www.external.org/events\n```\n\nс телом JSON:\n\n```JSON\n{\n    \"id\": \"2expen51ve\",\n    \"customer\": \"Mr. Richie Rich\",\n    \"total\": \"9999\"\n}\n```\n\nто *ваш API* обработает счёт и, в какой-то момент позже, отправит запрос обратного вызова на `callback_url` (*внешний API*):\n\n```\nhttps://www.external.org/events/invoices/2expen51ve\n```\n\nс телом JSON примерно такого вида:\n\n```JSON\n{\n    \"description\": \"Payment celebration\",\n    \"paid\": true\n}\n```\n\nи будет ожидать от *внешнего API* ответ с телом JSON вида:\n\n```JSON\n{\n    \"ok\": true\n}\n```\n\n/// tip | Совет\n\nОбратите внимание, что используемый URL обратного вызова содержит URL, полученный как query-параметр в `callback_url` (`https://www.external.org/events`), а также `id` счёта из тела JSON (`2expen51ve`).\n\n///\n\n", "metadata": {"title": "Обратные вызовы в OpenAPI", "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "source_mtime": "2026-01-12T17:48:13.008000+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-callbacks.md"}, "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "title": "Обратные вызовы в OpenAPI", "chunk_index": 7, "header": "Выражение пути для обратного вызова", "header_level": 3, "token_count": 462}
{"id": "9539605f5f548358", "text": "### Подключите маршрутизатор обратного вызова { #add-the-callback-router }\n\nК этому моменту у вас есть необходимые *операции пути* обратного вызова (те, которые *внешний разработчик* должен реализовать во *внешнем API*) в созданном выше маршрутизаторе обратных вызовов.\n\nТеперь используйте параметр `callbacks` в *декораторе операции пути вашего API*, чтобы передать атрибут `.routes` (это, по сути, просто `list` маршрутов/*операций пути*) из этого маршрутизатора обратных вызовов:\n\n{* ../../docs_src/openapi_callbacks/tutorial001_py310.py hl[33] *}\n\n/// tip | Совет\n\nОбратите внимание, что вы передаёте не сам маршрутизатор (`invoices_callback_router`) в `callback=`, а его атрибут `.routes`, то есть `invoices_callback_router.routes`.\n\n///\n\n", "metadata": {"title": "Обратные вызовы в OpenAPI", "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "source_mtime": "2026-01-12T17:48:13.008000+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-callbacks.md"}, "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "title": "Обратные вызовы в OpenAPI", "chunk_index": 8, "header": "Подключите маршрутизатор обратного вызова", "header_level": 3, "token_count": 271}
{"id": "d41ddeba5ee35a6f", "text": "### Проверьте документацию { #check-the-docs }\n\nТеперь вы можете запустить приложение и перейти по адресу <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a>.\n\nВы увидите документацию, включающую раздел «Callbacks» для вашей *операции пути*, который показывает, как должен выглядеть *внешний API*:\n\n<img src=\"/img/tutorial/openapi-callbacks/image01.png\">\n", "metadata": {"title": "Обратные вызовы в OpenAPI", "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "source_mtime": "2026-01-12T17:48:13.008000+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-callbacks.md"}, "doc_id": "bf69b5f7f527", "source_path": "docs\\advanced\\openapi-callbacks.md", "title": "Обратные вызовы в OpenAPI", "chunk_index": 9, "header": "Проверьте документацию", "header_level": 3, "token_count": 148}
{"id": "735bd4e078cd9aa6", "text": "# Вебхуки OpenAPI { #openapi-webhooks }\n\nБывают случаи, когда вы хотите сообщить пользователям вашего API, что ваше приложение может вызвать их приложение (отправив HTTP-запрос) с некоторыми данными, обычно чтобы уведомить о каком-то событии.\n\nЭто означает, что вместо обычного процесса, когда пользователи отправляют запросы вашему API, ваш API (или ваше приложение) может отправлять запросы в их систему (в их API, их приложение).\n\nОбычно это называется вебхуком.\n\n", "metadata": {"title": "Вебхуки OpenAPI", "doc_id": "5eadc83068aa", "source_path": "docs\\advanced\\openapi-webhooks.md", "source_mtime": "2026-01-12T17:48:13.016460+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-webhooks.md"}, "doc_id": "5eadc83068aa", "source_path": "docs\\advanced\\openapi-webhooks.md", "title": "Вебхуки OpenAPI", "chunk_index": 0, "header": "Вебхуки OpenAPI", "header_level": 1, "token_count": 175}
{"id": "ec0b81cac56cf074", "text": "## Шаги вебхуков { #webhooks-steps }\n\nОбычно процесс таков: вы определяете в своем коде, какое сообщение вы будете отправлять, то есть тело запроса.\n\nВы также определяете, в какие моменты (при каких событиях) ваше приложение будет отправлять эти запросы.\n\nА ваши пользователи каким-то образом (например, в веб‑панели) указывают URL-адрес, на который ваше приложение должно отправлять эти запросы.\n\nВся логика регистрации URL-адресов для вебхуков и код, который реально отправляет эти запросы, целиком на вашей стороне. Вы пишете это так, как вам нужно, в своем собственном коде.\n\n", "metadata": {"title": "Вебхуки OpenAPI", "doc_id": "5eadc83068aa", "source_path": "docs\\advanced\\openapi-webhooks.md", "source_mtime": "2026-01-12T17:48:13.016460+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-webhooks.md"}, "doc_id": "5eadc83068aa", "source_path": "docs\\advanced\\openapi-webhooks.md", "title": "Вебхуки OpenAPI", "chunk_index": 1, "header": "Шаги вебхуков", "header_level": 2, "token_count": 229}
{"id": "7119cc930eabe338", "text": "## Документирование вебхуков с помощью FastAPI и OpenAPI { #documenting-webhooks-with-fastapi-and-openapi }\n\nС FastAPI, используя OpenAPI, вы можете определить имена этих вебхуков, типы HTTP-операций, которые ваше приложение может отправлять (например, `POST`, `PUT` и т.д.), а также тела запросов, которые ваше приложение будет отправлять.\n\nЭто значительно упростит вашим пользователям реализацию их API для приема ваших вебхук-запросов; возможно, они даже смогут автоматически сгенерировать часть кода своего API.\n\n/// info | Информация\n\nВебхуки доступны в OpenAPI 3.1.0 и выше, поддерживаются в FastAPI `0.99.0` и новее.\n\n///\n\n", "metadata": {"title": "Вебхуки OpenAPI", "doc_id": "5eadc83068aa", "source_path": "docs\\advanced\\openapi-webhooks.md", "source_mtime": "2026-01-12T17:48:13.016460+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-webhooks.md"}, "doc_id": "5eadc83068aa", "source_path": "docs\\advanced\\openapi-webhooks.md", "title": "Вебхуки OpenAPI", "chunk_index": 2, "header": "Документирование вебхуков с помощью FastAPI и OpenAPI", "header_level": 2, "token_count": 242}
{"id": "bd21db178c4f2247", "text": "## Приложение с вебхуками { #an-app-with-webhooks }\n\nПри создании приложения на **FastAPI** есть атрибут `webhooks`, с помощью которого можно объявлять вебхуки так же, как вы объявляете операции пути (обработчики пути), например с `@app.webhooks.post()`.\n\n{* ../../docs_src/openapi_webhooks/tutorial001_py39.py hl[9:13,36:53] *}\n\nОпределенные вами вебхуки попадут в схему **OpenAPI** и в автоматический **интерфейс документации**.\n\n/// info | Информация\n\nОбъект `app.webhooks` на самом деле — это обычный `APIRouter`, тот же тип, который вы используете при структурировании приложения по нескольким файлам.\n\n///\n\nОбратите внимание: в случае с вебхуками вы на самом деле не объявляете путь (например, `/items/`), передаваемый туда текст — это лишь идентификатор вебхука (имя события). Например, в `@app.webhooks.post(\"new-subscription\")` имя вебхука — `new-subscription`.\n\nЭто связано с тем, что предполагается: фактический URL‑путь, по которому они хотят получать запрос вебхука, ваши пользователи укажут каким-то другим образом (например, в веб‑панели).\n\n", "metadata": {"title": "Вебхуки OpenAPI", "doc_id": "5eadc83068aa", "source_path": "docs\\advanced\\openapi-webhooks.md", "source_mtime": "2026-01-12T17:48:13.016460+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-webhooks.md"}, "doc_id": "5eadc83068aa", "source_path": "docs\\advanced\\openapi-webhooks.md", "title": "Вебхуки OpenAPI", "chunk_index": 3, "header": "Приложение с вебхуками", "header_level": 2, "token_count": 412}
{"id": "92621c1892fd3af3", "text": "### Посмотрите документацию { #check-the-docs }\n\nТеперь вы можете запустить приложение и перейти по ссылке <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a>.\n\nВы увидите, что в документации есть обычные операции пути, а также появились вебхуки:\n\n<img src=\"/img/tutorial/openapi-webhooks/image01.png\">\n", "metadata": {"title": "Вебхуки OpenAPI", "doc_id": "5eadc83068aa", "source_path": "docs\\advanced\\openapi-webhooks.md", "source_mtime": "2026-01-12T17:48:13.016460+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\openapi-webhooks.md"}, "doc_id": "5eadc83068aa", "source_path": "docs\\advanced\\openapi-webhooks.md", "title": "Вебхуки OpenAPI", "chunk_index": 4, "header": "Посмотрите документацию", "header_level": 3, "token_count": 130}
{"id": "012660d4fe0a475b", "text": "# Расширенная конфигурация операций пути { #path-operation-advanced-configuration }\n\n", "metadata": {"title": "Расширенная конфигурация операций пути", "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "source_mtime": "2026-01-12T17:48:13.022012+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\path-operation-advanced-configuration.md"}, "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "title": "Расширенная конфигурация операций пути", "chunk_index": 0, "header": "Расширенная конфигурация операций пути", "header_level": 1, "token_count": 28}
{"id": "8b5a9dd3049fc9df", "text": "## OpenAPI operationId { #openapi-operationid }\n\n/// warning | Предупреждение\n\nЕсли вы не «эксперт» по OpenAPI, скорее всего, это вам не нужно.\n\n///\n\nВы можете задать OpenAPI `operationId`, который будет использоваться в вашей *операции пути*, с помощью параметра `operation_id`.\n\nНужно убедиться, что он уникален для каждой операции.\n\n{* ../../docs_src/path_operation_advanced_configuration/tutorial001_py39.py hl[6] *}\n\n", "metadata": {"title": "Расширенная конфигурация операций пути", "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "source_mtime": "2026-01-12T17:48:13.022012+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\path-operation-advanced-configuration.md"}, "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "title": "Расширенная конфигурация операций пути", "chunk_index": 1, "header": "OpenAPI operationId", "header_level": 2, "token_count": 126}
{"id": "3e3bb777ebeb1433", "text": "### Использование имени функции-обработчика пути как operationId { #using-the-path-operation-function-name-as-the-operationid }\n\nЕсли вы хотите использовать имена функций ваших API в качестве `operationId`, вы можете пройти по всем из них и переопределить `operation_id` каждой *операции пути* с помощью их `APIRoute.name`.\n\nДелать это следует после добавления всех *операций пути*.\n\n{* ../../docs_src/path_operation_advanced_configuration/tutorial002_py39.py hl[2, 12:21, 24] *}\n\n/// tip | Совет\n\nЕсли вы вызываете `app.openapi()` вручную, обновите `operationId` до этого.\n\n///\n\n/// warning | Предупреждение\n\nЕсли вы делаете это, убедитесь, что каждая из ваших *функций-обработчиков пути* имеет уникальное имя.\n\nДаже если они находятся в разных модулях (файлах Python).\n\n///\n\n", "metadata": {"title": "Расширенная конфигурация операций пути", "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "source_mtime": "2026-01-12T17:48:13.022012+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\path-operation-advanced-configuration.md"}, "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "title": "Расширенная конфигурация операций пути", "chunk_index": 2, "header": "Использование имени функции-обработчика пути как operationId", "header_level": 3, "token_count": 266}
{"id": "672b8616e3ca3512", "text": "## Исключить из OpenAPI { #exclude-from-openapi }\n\nЧтобы исключить *операцию пути* из генерируемой схемы OpenAPI (а значит, и из автоматической документации), используйте параметр `include_in_schema` и установите его в `False`:\n\n{* ../../docs_src/path_operation_advanced_configuration/tutorial003_py39.py hl[6] *}\n\n", "metadata": {"title": "Расширенная конфигурация операций пути", "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "source_mtime": "2026-01-12T17:48:13.022012+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\path-operation-advanced-configuration.md"}, "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "title": "Расширенная конфигурация операций пути", "chunk_index": 3, "header": "Исключить из OpenAPI", "header_level": 2, "token_count": 100}
{"id": "2feb34480cc8d396", "text": "## Расширенное описание из docstring { #advanced-description-from-docstring }\n\nВы можете ограничить количество строк из docstring *функции-обработчика пути*, используемых для OpenAPI.\n\nДобавление `\\f` (экранированного символа «form feed») заставит **FastAPI** обрезать текст, используемый для OpenAPI, в этой точке.\n\nЭта часть не попадёт в документацию, но другие инструменты (например, Sphinx) смогут использовать остальное.\n\n{* ../../docs_src/path_operation_advanced_configuration/tutorial004_py310.py hl[17:27] *}\n\n", "metadata": {"title": "Расширенная конфигурация операций пути", "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "source_mtime": "2026-01-12T17:48:13.022012+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\path-operation-advanced-configuration.md"}, "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "title": "Расширенная конфигурация операций пути", "chunk_index": 4, "header": "Расширенное описание из docstring", "header_level": 2, "token_count": 168}
{"id": "9ca8f3e5b96161ea", "text": "## Дополнительные ответы { #additional-responses }\n\nВы, вероятно, уже видели, как объявлять `response_model` и `status_code` для *операции пути*.\n\nЭто определяет метаданные об основном ответе *операции пути*.\n\nТакже можно объявлять дополнительные ответы с их моделями, статус-кодами и т.д.\n\nВ документации есть целая глава об этом — [Дополнительные ответы в OpenAPI](additional-responses.md){.internal-link target=_blank}.\n\n", "metadata": {"title": "Расширенная конфигурация операций пути", "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "source_mtime": "2026-01-12T17:48:13.022012+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\path-operation-advanced-configuration.md"}, "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "title": "Расширенная конфигурация операций пути", "chunk_index": 5, "header": "Дополнительные ответы", "header_level": 2, "token_count": 151}
{"id": "fb4e71f0ac7c340f", "text": "## Дополнительные данные OpenAPI { #openapi-extra }\n\nКогда вы объявляете *операцию пути* в своём приложении, **FastAPI** автоматически генерирует соответствующие метаданные об этой *операции пути* для включения в схему OpenAPI.\n\n/// note | Технические детали\n\nВ спецификации OpenAPI это называется <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#operation-object\" class=\"external-link\" target=\"_blank\">Объект операции</a>.\n\n///\n\nОн содержит всю информацию об *операции пути* и используется для генерации автоматической документации.\n\nТам есть `tags`, `parameters`, `requestBody`, `responses` и т.д.\n\nЭта спецификация OpenAPI, специфичная для *операции пути*, обычно генерируется автоматически **FastAPI**, но вы также можете её расширить.\n\n/// tip | Совет\n\nЭто низкоуровневая возможность расширения.\n\nЕсли вам нужно лишь объявить дополнительные ответы, удобнее сделать это через [Дополнительные ответы в OpenAPI](additional-responses.md){.internal-link target=_blank}.\n\n///\n\nВы можете расширить схему OpenAPI для *операции пути* с помощью параметра `openapi_extra`.\n\n", "metadata": {"title": "Расширенная конфигурация операций пути", "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "source_mtime": "2026-01-12T17:48:13.022012+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\path-operation-advanced-configuration.md"}, "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "title": "Расширенная конфигурация операций пути", "chunk_index": 6, "header": "Дополнительные данные OpenAPI", "header_level": 2, "token_count": 401}
{"id": "a4b643f48316b680", "text": "### Расширения OpenAPI { #openapi-extensions }\n\n`openapi_extra` может пригодиться, например, чтобы объявить [Расширения OpenAPI](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions):\n\n{* ../../docs_src/path_operation_advanced_configuration/tutorial005_py39.py hl[6] *}\n\nЕсли вы откроете автоматическую документацию API, ваше расширение появится внизу страницы конкретной *операции пути*.\n\n<img src=\"/img/tutorial/path-operation-advanced-configuration/image01.png\">\n\nИ если вы посмотрите на итоговый OpenAPI (по адресу `/openapi.json` вашего API), вы также увидите своё расширение в составе описания соответствующей *операции пути*:\n\n```JSON hl_lines=\"22\"\n{\n    \"openapi\": \"3.1.0\",\n    \"info\": {\n        \"title\": \"FastAPI\",\n        \"version\": \"0.1.0\"\n    },\n    \"paths\": {\n        \"/items/\": {\n            \"get\": {\n                \"summary\": \"Read Items\",\n                \"operationId\": \"read_items_items__get\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {}\n                            }\n                        }\n                    }\n                },\n                \"x-aperture-labs-portal\": \"blue\"\n            }\n        }\n    }\n}\n```\n\n", "metadata": {"title": "Расширенная конфигурация операций пути", "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "source_mtime": "2026-01-12T17:48:13.022012+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\path-operation-advanced-configuration.md"}, "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "title": "Расширенная конфигурация операций пути", "chunk_index": 7, "header": "Расширения OpenAPI", "header_level": 3, "token_count": 367}
{"id": "47da537c015a491f", "text": "### Пользовательская схема OpenAPI для операции пути { #custom-openapi-path-operation-schema }\n\nСловарь в `openapi_extra` будет объединён с автоматически сгенерированной схемой OpenAPI для *операции пути*.\n\nТаким образом, вы можете добавить дополнительные данные к автоматически сгенерированной схеме.\n\nНапример, вы можете решить читать и валидировать запрос своим кодом, не используя автоматические возможности FastAPI и Pydantic, но при этом захотите описать запрос в схеме OpenAPI.\n\nЭто можно сделать с помощью `openapi_extra`:\n\n{* ../../docs_src/path_operation_advanced_configuration/tutorial006_py39.py hl[19:36, 39:40] *}\n\nВ этом примере мы не объявляли никакую Pydantic-модель. Фактически тело запроса даже не <abbr title=\"преобразовано из простого формата, например байтов, в объекты Python\">распарсено</abbr> как JSON, оно читается напрямую как `bytes`, а функция `magic_data_reader()` будет отвечать за его парсинг каким-то способом.\n\nТем не менее, мы можем объявить ожидаемую схему для тела запроса.\n\n", "metadata": {"title": "Расширенная конфигурация операций пути", "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "source_mtime": "2026-01-12T17:48:13.022012+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\path-operation-advanced-configuration.md"}, "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "title": "Расширенная конфигурация операций пути", "chunk_index": 8, "header": "Пользовательская схема OpenAPI для операции пути", "header_level": 3, "token_count": 373}
{"id": "012660d4fe0a475b", "text": "### Пользовательский тип содержимого в OpenAPI { #custom-openapi-content-type }\n\nИспользуя тот же приём, вы можете воспользоваться Pydantic-моделью, чтобы определить JSON Schema, которая затем будет включена в пользовательский раздел схемы OpenAPI для *операции пути*.\n\nИ вы можете сделать это, даже если тип данных в запросе — не JSON.\n\nНапример, в этом приложении мы не используем встроенную функциональность FastAPI для извлечения JSON Schema из моделей Pydantic, равно как и автоматическую валидацию JSON. Мы объявляем тип содержимого запроса как YAML, а не JSON:\n\n//// tab | Pydantic v2\n\n{* ../../docs_src/path_operation_advanced_configuration/tutorial007_py39.py hl[15:20, 22] *}\n\n////\n\n//// tab | Pydantic v1\n\n{* ../../docs_src/path_operation_advanced_configuration/tutorial007_pv1_py39.py hl[15:20, 22] *}\n\n////\n\n/// info | Информация\n\nВ Pydantic версии 1 метод для получения JSON Schema модели назывался `Item.schema()`, в Pydantic версии 2 метод называется `Item.model_json_schema()`.\n\n///\n\nТем не менее, хотя мы не используем встроенную функциональность по умолчанию, мы всё равно используем Pydantic-модель, чтобы вручную сгенерировать JSON Schema для данных, которые мы хотим получить в YAML.\n\nЗатем мы работаем с запросом напрямую и извлекаем тело как `bytes`. Это означает, что FastAPI даже не попытается распарсить полезную нагрузку запроса как JSON.\n\nА затем в нашем коде мы напрямую парсим этот YAML и снова используем ту же Pydantic-модель для валидации YAML-содержимого:", "metadata": {"title": "Расширенная конфигурация операций пути", "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "source_mtime": "2026-01-12T17:48:13.022012+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\path-operation-advanced-configuration.md", "section_header": "Пользовательский тип содержимого в OpenAPI", "section_header_level": 3}, "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "title": "Расширенная конфигурация операций пути", "chunk_index": 9, "header": "Пользовательский тип содержимого в OpenAPI", "header_level": 3, "token_count": 508}
{"id": "8b5a9dd3049fc9df", "text": "полезную нагрузку запроса как JSON.\n\nА затем в нашем коде мы напрямую парсим этот YAML и снова используем ту же Pydantic-модель для валидации YAML-содержимого:\n\n//// tab | Pydantic v2\n\n{* ../../docs_src/path_operation_advanced_configuration/tutorial007_py39.py hl[24:31] *}\n\n////\n\n//// tab | Pydantic v1\n\n{* ../../docs_src/path_operation_advanced_configuration/tutorial007_pv1_py39.py hl[24:31] *}\n\n////\n\n/// info | Информация\n\nВ Pydantic версии 1 метод для парсинга и валидации объекта назывался `Item.parse_obj()`, в Pydantic версии 2 метод называется `Item.model_validate()`.\n\n///\n\n/// tip | Совет\n\nЗдесь мы переиспользуем ту же Pydantic-модель.\n\nНо аналогично мы могли бы валидировать данные и каким-то другим способом.\n\n///", "metadata": {"title": "Расширенная конфигурация операций пути", "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "source_mtime": "2026-01-12T17:48:13.022012+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\path-operation-advanced-configuration.md", "section_header": "Пользовательский тип содержимого в OpenAPI", "section_header_level": 3}, "doc_id": "4cd9a3918fee", "source_path": "docs\\advanced\\path-operation-advanced-configuration.md", "title": "Расширенная конфигурация операций пути", "chunk_index": 10, "header": "Пользовательский тип содержимого в OpenAPI", "header_level": 3, "token_count": 254}
{"id": "91c21bd573c4e2a6", "text": "# Response - Изменение статус-кода { #response-change-status-code }\n\nВы, вероятно, уже читали о том, что можно установить [статус-код ответа по умолчанию](../tutorial/response-status-code.md){.internal-link target=_blank}.\n\nНо в некоторых случаях нужно вернуть другой статус-код, отличный от значения по умолчанию.\n\n", "metadata": {"title": "Response - Изменение статус-кода", "doc_id": "c089e892f58e", "source_path": "docs\\advanced\\response-change-status-code.md", "source_mtime": "2026-01-12T17:48:13.029402+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-change-status-code.md"}, "doc_id": "c089e892f58e", "source_path": "docs\\advanced\\response-change-status-code.md", "title": "Response - Изменение статус-кода", "chunk_index": 0, "header": "Response - Изменение статус-кода", "header_level": 1, "token_count": 107}
{"id": "c0b8bf09b703f7ce", "text": "## Пример использования { #use-case }\n\nНапример, представьте, что вы хотите по умолчанию возвращать HTTP статус-код «OK» `200`.\n\nНо если данные не существовали, вы хотите создать их и вернуть HTTP статус-код «CREATED» `201`.\n\nПри этом вы всё ещё хотите иметь возможность фильтровать и преобразовывать возвращаемые данные с помощью `response_model`.\n\nДля таких случаев вы можете использовать параметр `Response`.\n\n", "metadata": {"title": "Response - Изменение статус-кода", "doc_id": "c089e892f58e", "source_path": "docs\\advanced\\response-change-status-code.md", "source_mtime": "2026-01-12T17:48:13.029402+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-change-status-code.md"}, "doc_id": "c089e892f58e", "source_path": "docs\\advanced\\response-change-status-code.md", "title": "Response - Изменение статус-кода", "chunk_index": 1, "header": "Пример использования", "header_level": 2, "token_count": 145}
{"id": "0ebce087a4a201d9", "text": "## Использование параметра `Response` { #use-a-response-parameter }\n\nВы можете объявить параметр типа `Response` в вашей *функции обработки пути* (как и для cookies и HTTP-заголовков).\n\nИ затем вы можете установить `status_code` в этом *временном* объекте ответа.\n\n{* ../../docs_src/response_change_status_code/tutorial001_py39.py hl[1,9,12] *}\n\nПосле этого вы можете вернуть любой объект, который вам нужен, как обычно (`dict`, модель базы данных и т.д.).\n\nИ если вы объявили `response_model`, он всё равно будет использоваться для фильтрации и преобразования возвращаемого объекта.\n\n**FastAPI** будет использовать этот *временный* ответ для извлечения статус-кода (а также cookies и HTTP-заголовков) и поместит их в финальный ответ, который содержит возвращаемое вами значение, отфильтрованное любым `response_model`.\n\nВы также можете объявить параметр `Response` в зависимостях и установить в них статус-код. Но помните, что последнее установленное значение будет иметь приоритет.\n", "metadata": {"title": "Response - Изменение статус-кода", "doc_id": "c089e892f58e", "source_path": "docs\\advanced\\response-change-status-code.md", "source_mtime": "2026-01-12T17:48:13.029402+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-change-status-code.md"}, "doc_id": "c089e892f58e", "source_path": "docs\\advanced\\response-change-status-code.md", "title": "Response - Изменение статус-кода", "chunk_index": 2, "header": "Использование параметра `Response`", "header_level": 2, "token_count": 330}
{"id": "0226ab33e8eb1597", "text": "# Cookies в ответе { #response-cookies }\n\n", "metadata": {"title": "Cookies в ответе", "doc_id": "506fef655d41", "source_path": "docs\\advanced\\response-cookies.md", "source_mtime": "2026-01-12T17:48:13.038349+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-cookies.md"}, "doc_id": "506fef655d41", "source_path": "docs\\advanced\\response-cookies.md", "title": "Cookies в ответе", "chunk_index": 0, "header": "Cookies в ответе", "header_level": 1, "token_count": 11}
{"id": "cb00a449210ce850", "text": "## Использование параметра `Response` { #use-a-response-parameter }\n\nВы можете объявить параметр типа `Response` в вашей функции-обработчике пути.\n\nЗатем установить cookies в этом временном объекте ответа.\n\n{* ../../docs_src/response_cookies/tutorial002_py39.py hl[1, 8:9] *}\n\nПосле этого можно вернуть любой объект, как и раньше (например, `dict`, объект модели базы данных и так далее).\n\nЕсли вы указали `response_model`, он всё равно будет использоваться для фильтрации и преобразования возвращаемого объекта.\n\n**FastAPI** извлечет cookies (а также HTTP-заголовки и статус-код) из временного ответа и включит их в окончательный ответ, содержащий ваше возвращаемое значение, отфильтрованное через `response_model`.\n\nВы также можете объявить параметр типа `Response` в зависимостях и устанавливать cookies (и HTTP-заголовки) там.\n\n", "metadata": {"title": "Cookies в ответе", "doc_id": "506fef655d41", "source_path": "docs\\advanced\\response-cookies.md", "source_mtime": "2026-01-12T17:48:13.038349+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-cookies.md"}, "doc_id": "506fef655d41", "source_path": "docs\\advanced\\response-cookies.md", "title": "Cookies в ответе", "chunk_index": 1, "header": "Использование параметра `Response`", "header_level": 2, "token_count": 281}
{"id": "68ee570ff7e73ec5", "text": "## Возвращение `Response` напрямую { #return-a-response-directly }\n\nВы также можете установить Cookies, если возвращаете `Response` напрямую в вашем коде.\n\nДля этого создайте объект `Response`, как описано в разделе [Возвращение ответа напрямую](response-directly.md){.internal-link target=_blank}.\n\nЗатем установите cookies и верните этот объект:\n\n{* ../../docs_src/response_cookies/tutorial001_py39.py hl[10:12] *}\n\n/// tip | Совет\n\nИмейте в виду, что если вы возвращаете ответ напрямую, вместо использования параметра `Response`, FastAPI вернёт его напрямую.\n\nУбедитесь, что ваши данные имеют корректный тип. Например, они должны быть совместимы с JSON, если вы возвращаете `JSONResponse`.\n\nТакже убедитесь, что вы не отправляете данные, которые должны были быть отфильтрованы через `response_model`.\n\n///\n\n", "metadata": {"title": "Cookies в ответе", "doc_id": "506fef655d41", "source_path": "docs\\advanced\\response-cookies.md", "source_mtime": "2026-01-12T17:48:13.038349+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-cookies.md"}, "doc_id": "506fef655d41", "source_path": "docs\\advanced\\response-cookies.md", "title": "Cookies в ответе", "chunk_index": 2, "header": "Возвращение `Response` напрямую", "header_level": 2, "token_count": 265}
{"id": "71c3c03e0c6f78ba", "text": "### Дополнительная информация { #more-info }\n\n/// note | Технические детали\n\nВы также можете использовать `from starlette.responses import Response` или `from starlette.responses import JSONResponse`.\n\n**FastAPI** предоставляет `fastapi.responses`, которые являются теми же объектами, что и `starlette.responses`, просто для удобства. Однако большинство доступных типов ответов поступает непосредственно из **Starlette**.\n\nИ так как `Response` часто используется для установки HTTP-заголовков и cookies, **FastAPI** также предоставляет его как `fastapi.Response`.\n\n///\n\nЧтобы увидеть все доступные параметры и настройки, ознакомьтесь с <a href=\"https://www.starlette.dev/responses/#set-cookie\" class=\"external-link\" target=\"_blank\">документацией Starlette</a>.\n", "metadata": {"title": "Cookies в ответе", "doc_id": "506fef655d41", "source_path": "docs\\advanced\\response-cookies.md", "source_mtime": "2026-01-12T17:48:13.038349+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-cookies.md"}, "doc_id": "506fef655d41", "source_path": "docs\\advanced\\response-cookies.md", "title": "Cookies в ответе", "chunk_index": 3, "header": "Дополнительная информация", "header_level": 3, "token_count": 235}
{"id": "8902297d57a5fdb0", "text": "# Возврат ответа напрямую { #return-a-response-directly }\n\nКогда вы создаёте **FastAPI** *операцию пути*, вы можете возвращать из неё любые данные: `dict`, `list`, Pydantic-модель, модель базы данных и т.д.\n\nПо умолчанию **FastAPI** автоматически преобразует возвращаемое значение в JSON с помощью `jsonable_encoder`, как описано в [JSON кодировщик](../tutorial/encoder.md){.internal-link target=_blank}.\n\nЗатем \"под капотом\" эти данные, совместимые с JSON (например `dict`), помещаются в `JSONResponse`, который используется для отправки ответа клиенту.\n\nНо вы можете возвращать `JSONResponse` напрямую из ваших *операций пути*.\n\nЭто может быть полезно, например, если нужно вернуть пользовательские HTTP-заголовки или cookie.\n\n", "metadata": {"title": "Возврат ответа напрямую", "doc_id": "3c0169e63500", "source_path": "docs\\advanced\\response-directly.md", "source_mtime": "2026-01-12T17:48:13.044311+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-directly.md"}, "doc_id": "3c0169e63500", "source_path": "docs\\advanced\\response-directly.md", "title": "Возврат ответа напрямую", "chunk_index": 0, "header": "Возврат ответа напрямую", "header_level": 1, "token_count": 260}
{"id": "617708ef252103b0", "text": "## Возврат `Response` { #return-a-response }\n\nНа самом деле, вы можете возвращать любой объект `Response` или его подкласс.\n\n/// tip | Подсказка\n\n`JSONResponse` сам по себе является подклассом `Response`.\n\n///\n\nИ когда вы возвращаете `Response`, **FastAPI** передаст его напрямую.\n\nЭто не приведет к преобразованию данных с помощью Pydantic-моделей, содержимое не будет преобразовано в какой-либо тип и т.д.\n\nЭто даёт вам большую гибкость. Вы можете возвращать любые типы данных, переопределять любые объявления или валидацию данных и т.д.\n\n", "metadata": {"title": "Возврат ответа напрямую", "doc_id": "3c0169e63500", "source_path": "docs\\advanced\\response-directly.md", "source_mtime": "2026-01-12T17:48:13.044311+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-directly.md"}, "doc_id": "3c0169e63500", "source_path": "docs\\advanced\\response-directly.md", "title": "Возврат ответа напрямую", "chunk_index": 1, "header": "Возврат `Response`", "header_level": 2, "token_count": 201}
{"id": "f51e5c942cdb1955", "text": "## Использование `jsonable_encoder` в `Response` { #using-the-jsonable-encoder-in-a-response }\n\nПоскольку **FastAPI** не изменяет объект `Response`, который вы возвращаете, вы должны убедиться, что его содержимое готово к отправке.\n\nНапример, вы не можете поместить Pydantic-модель в `JSONResponse`, не преобразовав её сначала в `dict` с помощью преобразования всех типов данных (таких как `datetime`, `UUID` и т.д.) в совместимые с JSON типы.\n\nВ таких случаях вы можете использовать `jsonable_encoder` для преобразования данных перед передачей их в ответ:\n\n{* ../../docs_src/response_directly/tutorial001_py310.py hl[5:6,20:21] *}\n\n/// note | Технические детали\n\nВы также можете использовать `from starlette.responses import JSONResponse`.\n\n**FastAPI** предоставляет `starlette.responses` через `fastapi.responses` просто для вашего удобства, как разработчика. Но большинство доступных Response-классов поступают напрямую из Starlette.\n\n///\n\n", "metadata": {"title": "Возврат ответа напрямую", "doc_id": "3c0169e63500", "source_path": "docs\\advanced\\response-directly.md", "source_mtime": "2026-01-12T17:48:13.044311+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-directly.md"}, "doc_id": "3c0169e63500", "source_path": "docs\\advanced\\response-directly.md", "title": "Возврат ответа напрямую", "chunk_index": 2, "header": "Использование `jsonable_encoder` в `Response`", "header_level": 2, "token_count": 307}
{"id": "4612275bd87060f1", "text": "## Возврат пользовательского `Response` { #returning-a-custom-response }\n\nПример выше показывает все необходимые части, но он пока не очень полезен, так как вы могли бы просто вернуть `item` напрямую, и **FastAPI** поместил бы его в `JSONResponse`, преобразовав в `dict` и т.д. Всё это происходит по умолчанию.\n\nТеперь давайте посмотрим, как можно использовать это для возврата пользовательского ответа.\n\nДопустим, вы хотите вернуть ответ в формате <a href=\"https://en.wikipedia.org/wiki/XML\" class=\"external-link\" target=\"_blank\">XML</a>.\n\nВы можете поместить ваш XML-контент в строку, поместить её в `Response` и вернуть:\n\n{* ../../docs_src/response_directly/tutorial002_py39.py hl[1,18] *}\n\n", "metadata": {"title": "Возврат ответа напрямую", "doc_id": "3c0169e63500", "source_path": "docs\\advanced\\response-directly.md", "source_mtime": "2026-01-12T17:48:13.044311+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-directly.md"}, "doc_id": "3c0169e63500", "source_path": "docs\\advanced\\response-directly.md", "title": "Возврат ответа напрямую", "chunk_index": 3, "header": "Возврат пользовательского `Response`", "header_level": 2, "token_count": 235}
{"id": "4b4aa54655579d83", "text": "## Примечания { #notes }\n\nКогда вы возвращаете объект `Response` напрямую, его данные не валидируются, не преобразуются (не сериализуются) и не документируются автоматически.\n\nНо вы всё равно можете задокументировать это, как описано в [Дополнительные ответы в OpenAPI](additional-responses.md){.internal-link target=_blank}.\n\nВ следующих разделах вы увидите, как использовать/объявлять такие кастомные `Response`, при этом сохраняя автоматическое преобразование данных, документацию и т.д.\n", "metadata": {"title": "Возврат ответа напрямую", "doc_id": "3c0169e63500", "source_path": "docs\\advanced\\response-directly.md", "source_mtime": "2026-01-12T17:48:13.044311+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-directly.md"}, "doc_id": "3c0169e63500", "source_path": "docs\\advanced\\response-directly.md", "title": "Возврат ответа напрямую", "chunk_index": 4, "header": "Примечания", "header_level": 2, "token_count": 177}
{"id": "cce6ec675f1b83b7", "text": "# HTTP-заголовки ответа { #response-headers }\n\n", "metadata": {"title": "HTTP-заголовки ответа", "doc_id": "b430823f29b9", "source_path": "docs\\advanced\\response-headers.md", "source_mtime": "2026-01-12T17:48:13.048431+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-headers.md"}, "doc_id": "b430823f29b9", "source_path": "docs\\advanced\\response-headers.md", "title": "HTTP-заголовки ответа", "chunk_index": 0, "header": "HTTP-заголовки ответа", "header_level": 1, "token_count": 15}
{"id": "530bf1ce660bd06e", "text": "## Использовать параметр `Response` { #use-a-response-parameter }\n\nВы можете объявить параметр типа `Response` в вашей функции-обработчике пути (как можно сделать и для cookie).\n\nА затем вы можете устанавливать HTTP-заголовки в этом *временном* объекте ответа.\n\n{* ../../docs_src/response_headers/tutorial002_py39.py hl[1, 7:8] *}\n\nПосле этого вы можете вернуть любой нужный объект, как обычно (например, `dict`, модель из базы данных и т.д.).\n\nИ, если вы объявили `response_model`, он всё равно будет использован для фильтрации и преобразования возвращённого объекта.\n\n**FastAPI** использует этот *временный* ответ, чтобы извлечь HTTP-заголовки (а также cookie и статус-код) и поместит их в финальный HTTP-ответ, который содержит возвращённое вами значение, отфильтрованное согласно `response_model`.\n\nВы также можете объявлять параметр `Response` в зависимостях и устанавливать в них заголовки (и cookie).\n\n", "metadata": {"title": "HTTP-заголовки ответа", "doc_id": "b430823f29b9", "source_path": "docs\\advanced\\response-headers.md", "source_mtime": "2026-01-12T17:48:13.048431+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-headers.md"}, "doc_id": "b430823f29b9", "source_path": "docs\\advanced\\response-headers.md", "title": "HTTP-заголовки ответа", "chunk_index": 1, "header": "Использовать параметр `Response`", "header_level": 2, "token_count": 321}
{"id": "7ead9c0b29542418", "text": "## Вернуть `Response` напрямую { #return-a-response-directly }\n\nВы также можете добавить HTTP-заголовки, когда возвращаете `Response` напрямую.\n\nСоздайте ответ, как описано в [Вернуть Response напрямую](response-directly.md){.internal-link target=_blank}, и передайте заголовки как дополнительный параметр:\n\n{* ../../docs_src/response_headers/tutorial001_py39.py hl[10:12] *}\n\n/// note | Технические детали\n\nВы также можете использовать `from starlette.responses import Response` или `from starlette.responses import JSONResponse`.\n\n**FastAPI** предоставляет те же самые `starlette.responses` как `fastapi.responses` — для вашего удобства как разработчика. Но большинство доступных классов ответов поступают напрямую из Starlette.\n\nИ поскольку `Response` часто используется для установки заголовков и cookie, **FastAPI** также предоставляет его как `fastapi.Response`.\n\n///\n\n", "metadata": {"title": "HTTP-заголовки ответа", "doc_id": "b430823f29b9", "source_path": "docs\\advanced\\response-headers.md", "source_mtime": "2026-01-12T17:48:13.048431+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-headers.md"}, "doc_id": "b430823f29b9", "source_path": "docs\\advanced\\response-headers.md", "title": "HTTP-заголовки ответа", "chunk_index": 2, "header": "Вернуть `Response` напрямую", "header_level": 2, "token_count": 269}
{"id": "659f77c21e919927", "text": "## Пользовательские HTTP-заголовки { #custom-headers }\n\nПомните, что собственные проприетарные заголовки можно добавлять, <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers\" class=\"external-link\" target=\"_blank\">используя префикс `X-`</a>.\n\nНо если у вас есть пользовательские заголовки, которые вы хотите показывать клиенту в браузере, вам нужно добавить их в настройки CORS (подробнее см. в [CORS (Cross-Origin Resource Sharing)](../tutorial/cors.md){.internal-link target=_blank}), используя параметр `expose_headers`, описанный в <a href=\"https://www.starlette.dev/middleware/#corsmiddleware\" class=\"external-link\" target=\"_blank\">документации Starlette по CORS</a>.\n", "metadata": {"title": "HTTP-заголовки ответа", "doc_id": "b430823f29b9", "source_path": "docs\\advanced\\response-headers.md", "source_mtime": "2026-01-12T17:48:13.048431+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\response-headers.md"}, "doc_id": "b430823f29b9", "source_path": "docs\\advanced\\response-headers.md", "title": "HTTP-заголовки ответа", "chunk_index": 3, "header": "Пользовательские HTTP-заголовки", "header_level": 2, "token_count": 220}
{"id": "8b9aa7589c368206", "text": "# Настройки и переменные окружения { #settings-and-environment-variables }\n\nВо многих случаях вашему приложению могут понадобиться внешние настройки или конфигурации, например секретные ключи, учетные данные для базы данных, учетные данные для email‑сервисов и т.д.\n\nБольшинство таких настроек являются изменяемыми (могут меняться), например URL базы данных. И многие из них могут быть «чувствительными», например секреты.\n\nПо этой причине обычно их передают через переменные окружения, которые считываются приложением.\n\n/// tip | Совет\n\nЧтобы понять, что такое переменные окружения, вы можете прочитать [Переменные окружения](../environment-variables.md){.internal-link target=_blank}.\n\n///\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 0, "header": "Настройки и переменные окружения", "header_level": 1, "token_count": 261}
{"id": "ebd8d121e669fb05", "text": "## Типы и валидация { #types-and-validation }\n\nПеременные окружения могут содержать только текстовые строки, так как они внешние по отношению к Python и должны быть совместимы с другими программами и остальной системой (и даже с разными операционными системами, такими как Linux, Windows, macOS).\n\nЭто означает, что любое значение, прочитанное в Python из переменной окружения, будет `str`, а любые преобразования к другим типам или любая валидация должны выполняться в коде.\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 1, "header": "Типы и валидация", "header_level": 2, "token_count": 167}
{"id": "05f86a982375bdd6", "text": "## Pydantic `Settings` { #pydantic-settings }\n\nК счастью, Pydantic предоставляет отличную утилиту для работы с этими настройками, поступающими из переменных окружения, — <a href=\"https://docs.pydantic.dev/latest/concepts/pydantic_settings/\" class=\"external-link\" target=\"_blank\">Pydantic: управление настройками</a>.\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 2, "header": "Pydantic `Settings`", "header_level": 2, "token_count": 106}
{"id": "c4760260a44af3af", "text": "### Установка `pydantic-settings` { #install-pydantic-settings }\n\nСначала убедитесь, что вы создали [виртуальное окружение](../virtual-environments.md){.internal-link target=_blank}, активировали его, а затем установили пакет `pydantic-settings`:\n\n<div class=\"termy\">\n\n```console\n$ pip install pydantic-settings\n---> 100%\n```\n\n</div>\n\nОн также включен при установке набора `all` с:\n\n<div class=\"termy\">\n\n```console\n$ pip install \"fastapi[all]\"\n---> 100%\n```\n\n</div>\n\n/// info | Информация\n\nВ Pydantic v1 он входил в основной пакет. Теперь он распространяется как отдельный пакет, чтобы вы могли установить его только при необходимости.\n\n///\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 3, "header": "Установка `pydantic-settings`", "header_level": 3, "token_count": 217}
{"id": "e7f0594c30ef052f", "text": "### Создание объекта `Settings` { #create-the-settings-object }\n\nИмпортируйте `BaseSettings` из Pydantic и создайте подкласс, очень похожий на Pydantic‑модель.\n\nАналогично Pydantic‑моделям, вы объявляете атрибуты класса с аннотациями типов и, при необходимости, значениями по умолчанию.\n\nВы можете использовать все те же возможности валидации и инструменты, что и для Pydantic‑моделей, например разные типы данных и дополнительную валидацию через `Field()`.\n\n//// tab | Pydantic v2\n\n{* ../../docs_src/settings/tutorial001_py39.py hl[2,5:8,11] *}\n\n////\n\n//// tab | Pydantic v1\n\n/// info | Информация\n\nВ Pydantic v1 вы бы импортировали `BaseSettings` напрямую из `pydantic`, а не из `pydantic_settings`.\n\n///\n\n{* ../../docs_src/settings/tutorial001_pv1_py39.py hl[2,5:8,11] *}\n\n////\n\n/// tip | Совет\n\nЕсли вам нужно что-то быстро скопировать и вставить, не используйте этот пример — воспользуйтесь последним ниже.\n\n///\n\nЗатем, когда вы создаете экземпляр этого класса `Settings` (в нашем случае объект `settings`), Pydantic прочитает переменные окружения регистронезависимо, то есть переменная в верхнем регистре `APP_NAME` будет прочитана для атрибута `app_name`.\n\nДалее он преобразует и провалидирует данные. Поэтому при использовании объекта `settings` вы получите данные тех типов, которые объявили (например, `items_per_user` будет `int`).\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 4, "header": "Создание объекта `Settings`", "header_level": 3, "token_count": 493}
{"id": "31e9bce9c697ec56", "text": "### Использование `settings` { #use-the-settings }\n\nЗатем вы можете использовать новый объект `settings` в вашем приложении:\n\n{* ../../docs_src/settings/tutorial001_py39.py hl[18:20] *}\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 5, "header": "Использование `settings`", "header_level": 3, "token_count": 52}
{"id": "7004623bfc6bbc60", "text": "### Запуск сервера { #run-the-server }\n\nДалее вы можете запустить сервер, передав конфигурации через переменные окружения. Например, можно задать `ADMIN_EMAIL` и `APP_NAME` так:\n\n<div class=\"termy\">\n\n```console\n$ ADMIN_EMAIL=\"deadpool@example.com\" APP_NAME=\"ChimichangApp\" fastapi run main.py\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n</div>\n\n/// tip | Совет\n\nЧтобы задать несколько переменных окружения для одной команды, просто разделяйте их пробелами и укажите все перед командой.\n\n///\n\nТогда параметр `admin_email` будет установлен в `\"deadpool@example.com\"`.\n\n`app_name` будет `\"ChimichangApp\"`.\n\nА `items_per_user` сохранит значение по умолчанию `50`.\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 6, "header": "Запуск сервера", "header_level": 3, "token_count": 240}
{"id": "0b886fb5ecf0aa66", "text": "## Настройки в другом модуле { #settings-in-another-module }\n\nВы можете вынести эти настройки в другой модуль, как показано в разделе [Большие приложения — несколько файлов](../tutorial/bigger-applications.md){.internal-link target=_blank}.\n\nНапример, у вас может быть файл `config.py` со следующим содержимым:\n\n{* ../../docs_src/settings/app01_py39/config.py *}\n\nА затем использовать его в файле `main.py`:\n\n{* ../../docs_src/settings/app01_py39/main.py hl[3,11:13] *}\n\n/// tip | Совет\n\nВам также понадобится файл `__init__.py`, как в разделе [Большие приложения — несколько файлов](../tutorial/bigger-applications.md){.internal-link target=_blank}.\n\n///\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 7, "header": "Настройки в другом модуле", "header_level": 2, "token_count": 209}
{"id": "411f3a563851a1af", "text": "## Настройки как зависимость { #settings-in-a-dependency }\n\nИногда может быть полезно предоставлять настройки через зависимость, вместо глобального объекта `settings`, используемого повсюду.\n\nЭто особенно удобно при тестировании, так как очень легко переопределить зависимость своими настройками.\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 8, "header": "Настройки как зависимость", "header_level": 2, "token_count": 108}
{"id": "5b7d7054fcc070b8", "text": "### Файл конфигурации { #the-config-file }\n\nПродолжая предыдущий пример, ваш файл `config.py` может выглядеть так:\n\n{* ../../docs_src/settings/app02_an_py39/config.py hl[10] *}\n\nОбратите внимание, что теперь мы не создаем экземпляр по умолчанию `settings = Settings()`.\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 9, "header": "Файл конфигурации", "header_level": 3, "token_count": 95}
{"id": "e9fe110479a08db6", "text": "### Основной файл приложения { #the-main-app-file }\n\nТеперь мы создаем зависимость, которая возвращает новый `config.Settings()`.\n\n{* ../../docs_src/settings/app02_an_py39/main.py hl[6,12:13] *}\n\n/// tip | Совет\n\nСкоро мы обсудим `@lru_cache`.\n\nПока можно считать, что `get_settings()` — это обычная функция.\n\n///\n\nЗатем мы можем запросить ее в *функции-обработчике пути* как зависимость и использовать там, где нужно.\n\n{* ../../docs_src/settings/app02_an_py39/main.py hl[17,19:21] *}\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 10, "header": "Основной файл приложения", "header_level": 3, "token_count": 166}
{"id": "35c6fbb362c55906", "text": "### Настройки и тестирование { #settings-and-testing }\n\nДалее будет очень просто предоставить другой объект настроек во время тестирования, создав переопределение зависимости для `get_settings`:\n\n{* ../../docs_src/settings/app02_an_py39/test_main.py hl[9:10,13,21] *}\n\nВ переопределении зависимости мы задаем новое значение `admin_email` при создании нового объекта `Settings`, а затем возвращаем этот новый объект.\n\nПосле этого можно протестировать, что он используется.\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 11, "header": "Настройки и тестирование", "header_level": 3, "token_count": 148}
{"id": "153df07640f93942", "text": "## Чтение файла `.env` { #reading-a-env-file }\n\nЕсли у вас много настроек, которые могут часто меняться, возможно в разных окружениях, может быть удобно поместить их в файл и читать оттуда как переменные окружения.\n\nЭта практика достаточно распространена и имеет название: такие переменные окружения обычно размещают в файле `.env`, а сам файл называют «dotenv».\n\n/// tip | Совет\n\nФайл, начинающийся с точки (`.`), является скрытым в системах, подобных Unix, таких как Linux и macOS.\n\nНо файл dotenv не обязательно должен иметь именно такое имя.\n\n///\n\nPydantic поддерживает чтение таких файлов с помощью внешней библиотеки. Подробнее вы можете прочитать здесь: <a href=\"https://docs.pydantic.dev/latest/concepts/pydantic_settings/#dotenv-env-support\" class=\"external-link\" target=\"_blank\">Pydantic Settings: поддержка Dotenv (.env)</a>.\n\n/// tip | Совет\n\nЧтобы это работало, вам нужно `pip install python-dotenv`.\n\n///\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 12, "header": "Чтение файла `.env`", "header_level": 2, "token_count": 332}
{"id": "0224e60c66fa9490", "text": "### Файл `.env` { #the-env-file }\n\nУ вас может быть файл `.env` со следующим содержимым:\n\n```bash\nADMIN_EMAIL=\"deadpool@example.com\"\nAPP_NAME=\"ChimichangApp\"\n```\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 13, "header": "Файл `.env`", "header_level": 3, "token_count": 53}
{"id": "4da1a5058ccc7173", "text": "### Чтение настроек из `.env` { #read-settings-from-env }\n\nЗатем обновите ваш `config.py` так:\n\n//// tab | Pydantic v2\n\n{* ../../docs_src/settings/app03_an_py39/config.py hl[9] *}\n\n/// tip | Совет\n\nАтрибут `model_config` используется только для конфигурации Pydantic. Подробнее см. <a href=\"https://docs.pydantic.dev/latest/concepts/config/\" class=\"external-link\" target=\"_blank\">Pydantic: Concepts: Configuration</a>.\n\n///\n\n////\n\n//// tab | Pydantic v1\n\n{* ../../docs_src/settings/app03_an_py39/config_pv1.py hl[9:10] *}\n\n/// tip | Совет\n\nКласс `Config` используется только для конфигурации Pydantic. Подробнее см. <a href=\"https://docs.pydantic.dev/1.10/usage/model_config/\" class=\"external-link\" target=\"_blank\">Pydantic Model Config</a>.\n\n///\n\n////\n\n/// info | Информация\n\nВ Pydantic версии 1 конфигурация задавалась во внутреннем классе `Config`, в Pydantic версии 2 — в атрибуте `model_config`. Этот атрибут принимает `dict`, и чтобы получить автозавершение и ошибки «на лету», вы можете импортировать и использовать `SettingsConfigDict` для описания этого `dict`.\n\n///\n\nЗдесь мы задаем параметр конфигурации `env_file` внутри вашего класса Pydantic `Settings` и устанавливаем значение равным имени файла dotenv, который хотим использовать.\n\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 14, "header": "Чтение настроек из `.env`", "header_level": 3, "token_count": 424}
{"id": "8b9aa7589c368206", "text": "### Создание `Settings` только один раз с помощью `lru_cache` { #creating-the-settings-only-once-with-lru-cache }\n\nЧтение файла с диска обычно затратная (медленная) операция, поэтому, вероятно, вы захотите сделать это один раз и затем переиспользовать один и тот же объект настроек, а не читать файл при каждом запросе.\n\nНо каждый раз, когда мы делаем:\n\n```Python\nSettings()\n```\n\nсоздается новый объект `Settings`, и при создании он снова считывает файл `.env`.\n\nЕсли бы функция зависимости была такой:\n\n```Python\ndef get_settings():\n    return Settings()\n```\n\nмы бы создавали этот объект для каждого запроса и читали файл `.env` на каждый запрос. \n\nНо так как мы используем декоратор `@lru_cache` сверху, объект `Settings` будет создан только один раз — при первом вызове. \n\n{* ../../docs_src/settings/app03_an_py39/main.py hl[1,11] *}\n\nЗатем при любых последующих вызовах `get_settings()` в зависимостях для следующих запросов, вместо выполнения внутреннего кода `get_settings()` и создания нового объекта `Settings`, будет возвращаться тот же объект, что был возвращен при первом вызове, снова и снова.\n\n#### Технические детали `lru_cache` { #lru-cache-technical-details }\n\n`@lru_cache` модифицирует декорируемую функцию так, что она возвращает то же значение, что и в первый раз, вместо повторного вычисления, то есть вместо выполнения кода функции каждый раз.", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md", "section_header": "Создание `Settings` только один раз с помощью `lru_cache`", "section_header_level": 3}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 15, "header": "Создание `Settings` только один раз с помощью `lru_cache`", "header_level": 3, "token_count": 462}
{"id": "ebd8d121e669fb05", "text": "_cache` модифицирует декорируемую функцию так, что она возвращает то же значение, что и в первый раз, вместо повторного вычисления, то есть вместо выполнения кода функции каждый раз.\n\nТаким образом, функция под декоратором будет выполнена один раз для каждой комбинации аргументов. Затем значения, возвращенные для каждой из этих комбинаций, будут использоваться снова и снова при вызове функции с точно такой же комбинацией аргументов.\n\nНапример, если у вас есть функция:\n\n```Python\n@lru_cache\ndef say_hi(name: str, salutation: str = \"Ms.\"):\n    return f\"Hello {salutation} {name}\"\n```\n\nваша программа может выполняться так:\n\n```mermaid\nsequenceDiagram\n\nparticipant code as Code\nparticipant function as say_hi()\nparticipant execute as Execute function\n\n    rect rgba(0, 255, 0, .1)\n        code ->> function: say_hi(name=\"Camila\")\n        function ->> execute: execute function code\n        execute ->> code: return the result\n    end\n\n    rect rgba(0, 255, 255, .1)\n        code ->> function: say_hi(name=\"Camila\")\n        function ->> code: return stored result\n    end\n\n    rect rgba(0, 255, 0, .1)\n        code ->> function: say_hi(name=\"Rick\")\n        function ->> execute: execute function code\n        execute ->> code: return the result\n    end\n\n    rect rgba(0, 255, 0, .1)\n        code ->> function: say_hi(name=\"Rick\", salutation=\"Mr.\")\n        function ->> execute: execute function code\n        execute ->> code: return the result\n    end\n\n    rect rgba(0, 255, 255, .1)\n        code ->> function: say_hi(name=\"Rick\")\n        function ->> code: return stored result\n    end", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md", "section_header": "Создание `Settings` только один раз с помощью `lru_cache`", "section_header_level": 3}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 16, "header": "Создание `Settings` только один раз с помощью `lru_cache`", "header_level": 3, "token_count": 477}
{"id": "05f86a982375bdd6", "text": ".\")\n        function ->> execute: execute function code\n        execute ->> code: return the result\n    end\n\n    rect rgba(0, 255, 255, .1)\n        code ->> function: say_hi(name=\"Rick\")\n        function ->> code: return stored result\n    end\n\n    rect rgba(0, 255, 255, .1)\n        code ->> function: say_hi(name=\"Camila\")\n        function ->> code: return stored result\n    end\n```\n\nВ случае нашей зависимости `get_settings()` функция вообще не принимает аргументов, поэтому она всегда возвращает одно и то же значение.\n\nТаким образом, она ведет себя почти как глобальная переменная. Но так как используется функция‑зависимость, мы можем легко переопределить ее для тестирования.\n\n`@lru_cache` — часть `functools`, что входит в стандартную библиотеку Python. Подробнее можно прочитать в <a href=\"https://docs.python.org/3/library/functools.html#functools.lru_cache\" class=\"external-link\" target=\"_blank\">документации Python по `@lru_cache`</a>.", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md", "section_header": "Создание `Settings` только один раз с помощью `lru_cache`", "section_header_level": 3}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 17, "header": "Создание `Settings` только один раз с помощью `lru_cache`", "header_level": 3, "token_count": 311}
{"id": "11a97a1d47e71a38", "text": "## Итоги { #recap }\n\nВы можете использовать Pydantic Settings для управления настройками и конфигурациями вашего приложения с полной мощью Pydantic‑моделей.\n\n* Используя зависимость, вы упрощаете тестирование.\n* Можно использовать файлы `.env`.\n* `@lru_cache` позволяет не читать файл dotenv снова и снова для каждого запроса, при этом давая возможность переопределять его во время тестирования.\n", "metadata": {"title": "Настройки и переменные окружения", "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "source_mtime": "2026-01-12T17:48:13.053874+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\settings.md"}, "doc_id": "2f2503e1f2ce", "source_path": "docs\\advanced\\settings.md", "title": "Настройки и переменные окружения", "chunk_index": 18, "header": "Итоги", "header_level": 2, "token_count": 143}
{"id": "91852a5f582dffa2", "text": "# Подприложения — Mounts (монтирование) { #sub-applications-mounts }\n\nЕсли вам нужны два независимых приложения FastAPI, каждое со своим собственным OpenAPI и собственными интерфейсами документации, вы можете иметь основное приложение и «смонтировать» одно (или несколько) подприложений.\n\n", "metadata": {"title": "Подприложения — Mounts (монтирование)", "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "source_mtime": "2026-01-12T17:48:13.058365+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\sub-applications.md"}, "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "title": "Подприложения — Mounts (монтирование)", "chunk_index": 0, "header": "Подприложения — Mounts (монтирование)", "header_level": 1, "token_count": 109}
{"id": "8357df44a006e8ef", "text": "## Монтирование приложения **FastAPI** { #mounting-a-fastapi-application }\n\n«Монтирование» означает добавление полностью независимого приложения по конкретному пути; далее оно будет обрабатывать всё под этим путём, используя объявленные в подприложении _операции пути_.\n\n", "metadata": {"title": "Подприложения — Mounts (монтирование)", "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "source_mtime": "2026-01-12T17:48:13.058365+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\sub-applications.md"}, "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "title": "Подприложения — Mounts (монтирование)", "chunk_index": 1, "header": "Монтирование приложения **FastAPI**", "header_level": 2, "token_count": 101}
{"id": "c6d3132fff114872", "text": "### Приложение верхнего уровня { #top-level-application }\n\nСначала создайте основное, верхнего уровня, приложение **FastAPI** и его *операции пути*:\n\n{* ../../docs_src/sub_applications/tutorial001_py39.py hl[3, 6:8] *}\n\n", "metadata": {"title": "Подприложения — Mounts (монтирование)", "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "source_mtime": "2026-01-12T17:48:13.058365+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\sub-applications.md"}, "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "title": "Подприложения — Mounts (монтирование)", "chunk_index": 2, "header": "Приложение верхнего уровня", "header_level": 3, "token_count": 76}
{"id": "353941f7513d83c5", "text": "### Подприложение { #sub-application }\n\nЗатем создайте подприложение и его *операции пути*.\n\nЭто подприложение — обычное стандартное приложение FastAPI, но именно оно будет «смонтировано»:\n\n{* ../../docs_src/sub_applications/tutorial001_py39.py hl[11, 14:16] *}\n\n", "metadata": {"title": "Подприложения — Mounts (монтирование)", "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "source_mtime": "2026-01-12T17:48:13.058365+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\sub-applications.md"}, "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "title": "Подприложения — Mounts (монтирование)", "chunk_index": 3, "header": "Подприложение", "header_level": 3, "token_count": 95}
{"id": "3d394645f542266a", "text": "### Смонтируйте подприложение { #mount-the-sub-application }\n\nВ вашем приложении верхнего уровня, `app`, смонтируйте подприложение `subapi`.\n\nВ этом случае оно будет смонтировано по пути `/subapi`:\n\n{* ../../docs_src/sub_applications/tutorial001_py39.py hl[11, 19] *}\n\n", "metadata": {"title": "Подприложения — Mounts (монтирование)", "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "source_mtime": "2026-01-12T17:48:13.058365+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\sub-applications.md"}, "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "title": "Подприложения — Mounts (монтирование)", "chunk_index": 4, "header": "Смонтируйте подприложение", "header_level": 3, "token_count": 97}
{"id": "856e1f07c4a62259", "text": "### Проверьте автоматическую документацию API { #check-the-automatic-api-docs }\n\nТеперь запустите команду `fastapi` с вашим файлом:\n\n<div class=\"termy\">\n\n```console\n$ fastapi dev main.py\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n</div>\n\nИ откройте документацию по адресу <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a>.\n\nВы увидите автоматическую документацию API для основного приложения, включающую только его собственные _операции пути_:\n\n<img src=\"/img/tutorial/sub-applications/image01.png\">\n\nЗатем откройте документацию для подприложения по адресу <a href=\"http://127.0.0.1:8000/subapi/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/subapi/docs</a>.\n\nВы увидите автоматическую документацию API для подприложения, включающую только его собственные _операции пути_, все под корректным префиксом подпути `/subapi`:\n\n<img src=\"/img/tutorial/sub-applications/image02.png\">\n\nЕсли вы попробуете взаимодействовать с любым из двух интерфейсов, всё будет работать корректно, потому что браузер сможет обращаться к каждому конкретному приложению и подприложению.\n\n", "metadata": {"title": "Подприложения — Mounts (монтирование)", "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "source_mtime": "2026-01-12T17:48:13.058365+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\sub-applications.md"}, "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "title": "Подприложения — Mounts (монтирование)", "chunk_index": 5, "header": "Проверьте автоматическую документацию API", "header_level": 3, "token_count": 437}
{"id": "7e1026b3b15da672", "text": "### Технические подробности: `root_path` { #technical-details-root-path }\n\nКогда вы монтируете подприложение, как описано выше, FastAPI позаботится о передаче пути монтирования для подприложения, используя механизм из спецификации ASGI под названием `root_path`.\n\nТаким образом подприложение будет знать, что для интерфейса документации нужно использовать этот префикс пути.\n\nУ подприложения также могут быть свои собственные смонтированные подприложения, и всё будет работать корректно, потому что FastAPI автоматически обрабатывает все эти `root_path`.\n\nВы узнаете больше о `root_path` и о том, как использовать его явно, в разделе [За прокси](behind-a-proxy.md){.internal-link target=_blank}.\n", "metadata": {"title": "Подприложения — Mounts (монтирование)", "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "source_mtime": "2026-01-12T17:48:13.058365+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\sub-applications.md"}, "doc_id": "54d85e48ffa6", "source_path": "docs\\advanced\\sub-applications.md", "title": "Подприложения — Mounts (монтирование)", "chunk_index": 6, "header": "Технические подробности: `root_path`", "header_level": 3, "token_count": 257}
{"id": "e2beff365a828351", "text": "# Шаблоны { #templates }\n\nВы можете использовать любой шаблонизатор вместе с **FastAPI**.\n\nЧасто выбирают Jinja2 — тот же, что используется во Flask и других инструментах.\n\nЕсть утилиты для простой настройки, которые вы можете использовать прямо в своем приложении **FastAPI** (предоставляются Starlette).\n\n", "metadata": {"title": "Шаблоны", "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "source_mtime": "2026-01-12T17:48:13.064927+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\templates.md"}, "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "title": "Шаблоны", "chunk_index": 0, "header": "Шаблоны", "header_level": 1, "token_count": 115}
{"id": "fd8ea4fda7ffc4ff", "text": "## Установка зависимостей { #install-dependencies }\n\nУбедитесь, что вы создали [виртуальное окружение](../virtual-environments.md){.internal-link target=_blank}, активировали его и установили `jinja2`:\n\n<div class=\"termy\">\n\n```console\n$ pip install jinja2\n\n---> 100%\n```\n\n</div>\n\n", "metadata": {"title": "Шаблоны", "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "source_mtime": "2026-01-12T17:48:13.064927+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\templates.md"}, "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "title": "Шаблоны", "chunk_index": 1, "header": "Установка зависимостей", "header_level": 2, "token_count": 91}
{"id": "65e78740c8844633", "text": "## Использование `Jinja2Templates` { #using-jinja2templates }\n\n- Импортируйте `Jinja2Templates`.\n- Создайте объект `templates`, который сможете переиспользовать позже.\n- Объявите параметр `Request` в *операции пути*, которая будет возвращать шаблон.\n- Используйте созданный `templates`, чтобы отрендерить и вернуть `TemplateResponse`; передайте имя шаблона, объект `request` и словарь «context» с парами ключ-значение для использования внутри шаблона Jinja2.\n\n{* ../../docs_src/templates/tutorial001_py39.py hl[4,11,15:18] *}\n\n/// note | Примечание\n\nДо FastAPI 0.108.0, Starlette 0.29.0, `name` был первым параметром.\n\nТакже раньше, в предыдущих версиях, объект `request` передавался как часть пар ключ-значение в контексте для Jinja2.\n\n///\n\n/// tip | Совет\n\nЕсли указать `response_class=HTMLResponse`, интерфейс документации сможет определить, что ответ будет в формате HTML.\n\n///\n\n/// note | Технические детали\n\nМожно также использовать `from starlette.templating import Jinja2Templates`.\n\n**FastAPI** предоставляет тот же `starlette.templating` как `fastapi.templating` просто для удобства разработчика. Но большинство доступных ответов приходят напрямую из Starlette. Так же и с `Request` и `StaticFiles`.\n\n///\n\n", "metadata": {"title": "Шаблоны", "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "source_mtime": "2026-01-12T17:48:13.064927+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\templates.md"}, "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "title": "Шаблоны", "chunk_index": 2, "header": "Использование `Jinja2Templates`", "header_level": 2, "token_count": 423}
{"id": "9b682b7a3c4bc46a", "text": "## Написание шаблонов { #writing-templates }\n\nЗатем вы можете создать шаблон в `templates/item.html`, например:\n\n```jinja hl_lines=\"7\"\n{!../../docs_src/templates/templates/item.html!}\n```\n\n", "metadata": {"title": "Шаблоны", "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "source_mtime": "2026-01-12T17:48:13.064927+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\templates.md"}, "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "title": "Шаблоны", "chunk_index": 3, "header": "Написание шаблонов", "header_level": 2, "token_count": 59}
{"id": "7c279efb1d981c4f", "text": "### Значения контекста шаблона { #template-context-values }\n\nВ HTML, который содержит:\n\n{% raw %}\n\n```jinja\nItem ID: {{ id }}\n```\n\n{% endraw %}\n\n...будет показан `id`, взятый из переданного вами «context» `dict`:\n\n```Python\n{\"id\": id}\n```\n\nНапример, для ID `42` это отрендерится как:\n\n```html\nItem ID: 42\n```\n\n", "metadata": {"title": "Шаблоны", "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "source_mtime": "2026-01-12T17:48:13.064927+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\templates.md"}, "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "title": "Шаблоны", "chunk_index": 4, "header": "Значения контекста шаблона", "header_level": 3, "token_count": 113}
{"id": "6821625d0bb43f11", "text": "### Аргументы `url_for` в шаблоне { #template-url-for-arguments }\n\nВы также можете использовать `url_for()` внутри шаблона — он принимает те же аргументы, что использовались бы вашей *функцией-обработчиком пути*.\n\nТаким образом, фрагмент:\n\n{% raw %}\n\n```jinja\n<a href=\"{{ url_for('read_item', id=id) }}\">\n```\n\n{% endraw %}\n\n...сгенерирует ссылку на тот же URL, который обрабатывается *функцией-обработчиком пути* `read_item(id=id)`.\n\nНапример, для ID `42` это отрендерится как:\n\n```html\n<a href=\"/items/42\">\n```\n\n", "metadata": {"title": "Шаблоны", "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "source_mtime": "2026-01-12T17:48:13.064927+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\templates.md"}, "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "title": "Шаблоны", "chunk_index": 5, "header": "Аргументы `url_for` в шаблоне", "header_level": 3, "token_count": 196}
{"id": "9792eaaa0bed37c4", "text": "## Шаблоны и статические файлы { #templates-and-static-files }\n\nВы также можете использовать `url_for()` внутри шаблона, например, с `StaticFiles`, которые вы монтировали с `name=\"static\"`.\n\n```jinja hl_lines=\"4\"\n{!../../docs_src/templates/templates/item.html!}\n```\n\nВ этом примере будет создана ссылка на CSS-файл `static/styles.css` с помощью:\n\n```CSS hl_lines=\"4\"\n{!../../docs_src/templates/static/styles.css!}\n```\n\nИ, так как вы используете `StaticFiles`, этот CSS-файл будет автоматически «отдаваться» вашим приложением **FastAPI** по URL `/static/styles.css`.\n\n", "metadata": {"title": "Шаблоны", "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "source_mtime": "2026-01-12T17:48:13.064927+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\templates.md"}, "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "title": "Шаблоны", "chunk_index": 6, "header": "Шаблоны и статические файлы", "header_level": 2, "token_count": 181}
{"id": "fd12fd3d6363503d", "text": "## Подробнее { #more-details }\n\nБольше подробностей, включая то, как тестировать шаблоны, смотрите в <a href=\"https://www.starlette.dev/templates/\" class=\"external-link\" target=\"_blank\">документации Starlette по шаблонам</a>.\n", "metadata": {"title": "Шаблоны", "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "source_mtime": "2026-01-12T17:48:13.064927+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\templates.md"}, "doc_id": "9ea1616c9cee", "source_path": "docs\\advanced\\templates.md", "title": "Шаблоны", "chunk_index": 7, "header": "Подробнее", "header_level": 2, "token_count": 76}
{"id": "e37af32e84879e9a", "text": "# Тестирование зависимостей с переопределениями { #testing-dependencies-with-overrides }\n\n", "metadata": {"title": "Тестирование зависимостей с переопределениями", "doc_id": "e8b00759a407", "source_path": "docs\\advanced\\testing-dependencies.md", "source_mtime": "2026-01-12T17:48:13.069803+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\testing-dependencies.md"}, "doc_id": "e8b00759a407", "source_path": "docs\\advanced\\testing-dependencies.md", "title": "Тестирование зависимостей с переопределениями", "chunk_index": 0, "header": "Тестирование зависимостей с переопределениями", "header_level": 1, "token_count": 26}
{"id": "8b74f227666d02e7", "text": "## Переопределение зависимостей во время тестирования { #overriding-dependencies-during-testing }\n\nЕсть сценарии, когда может понадобиться переопределить зависимость во время тестирования.\n\nВы не хотите, чтобы исходная зависимость выполнялась (и любые её подзависимости тоже).\n\nВместо этого вы хотите предоставить другую зависимость, которая будет использоваться только во время тестов (возможно, только в некоторых конкретных тестах) и будет возвращать значение, которое можно использовать везде, где использовалось значение исходной зависимости.\n\n", "metadata": {"title": "Тестирование зависимостей с переопределениями", "doc_id": "e8b00759a407", "source_path": "docs\\advanced\\testing-dependencies.md", "source_mtime": "2026-01-12T17:48:13.069803+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\testing-dependencies.md"}, "doc_id": "e8b00759a407", "source_path": "docs\\advanced\\testing-dependencies.md", "title": "Тестирование зависимостей с переопределениями", "chunk_index": 1, "header": "Переопределение зависимостей во время тестирования", "header_level": 2, "token_count": 188}
{"id": "20347d452d4e9acb", "text": "### Варианты использования: внешний сервис { #use-cases-external-service }\n\nПример: у вас есть внешний провайдер аутентификации, к которому нужно обращаться.\n\nВы отправляете ему токен, а он возвращает аутентифицированного пользователя.\n\nТакой провайдер может брать плату за каждый запрос, и его вызов может занимать больше времени, чем использование фиксированного мок-пользователя для тестов.\n\nВероятно, вы захотите протестировать внешний провайдер один раз, но не обязательно вызывать его для каждого запускаемого теста.\n\nВ таком случае вы можете переопределить зависимость, которая обращается к этому провайдеру, и использовать собственную зависимость, возвращающую мок-пользователя, только для ваших тестов.\n\n", "metadata": {"title": "Тестирование зависимостей с переопределениями", "doc_id": "e8b00759a407", "source_path": "docs\\advanced\\testing-dependencies.md", "source_mtime": "2026-01-12T17:48:13.069803+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\testing-dependencies.md"}, "doc_id": "e8b00759a407", "source_path": "docs\\advanced\\testing-dependencies.md", "title": "Тестирование зависимостей с переопределениями", "chunk_index": 2, "header": "Варианты использования: внешний сервис", "header_level": 3, "token_count": 255}
{"id": "8f6b36959665a828", "text": "### Используйте атрибут `app.dependency_overrides` { #use-the-app-dependency-overrides-attribute }\n\nДля таких случаев у вашего приложения **FastAPI** есть атрибут `app.dependency_overrides`, это простой `dict`.\n\nЧтобы переопределить зависимость для тестирования, укажите в качестве ключа исходную зависимость (функцию), а в качестве значения — ваше переопределение зависимости (другую функцию).\n\nТогда **FastAPI** будет вызывать это переопределение вместо исходной зависимости.\n\n{* ../../docs_src/dependency_testing/tutorial001_an_py310.py hl[26:27,30] *}\n\n/// tip | Совет\n\nВы можете задать переопределение для зависимости, используемой в любом месте вашего приложения **FastAPI**.\n\nИсходная зависимость может использоваться в функции-обработчике пути, в декораторе операции пути (когда вы не используете возвращаемое значение), в вызове `.include_router()` и т.д.\n\nFastAPI всё равно сможет её переопределить.\n\n///\n\nЗатем вы можете сбросить переопределения (удалить их), установив `app.dependency_overrides` в пустой `dict`:\n\n```Python\napp.dependency_overrides = {}\n```\n\n/// tip | Совет\n\nЕсли вы хотите переопределять зависимость только во время некоторых тестов, задайте переопределение в начале теста (внутри функции теста) и сбросьте его в конце (в конце функции теста).\n\n///\n", "metadata": {"title": "Тестирование зависимостей с переопределениями", "doc_id": "e8b00759a407", "source_path": "docs\\advanced\\testing-dependencies.md", "source_mtime": "2026-01-12T17:48:13.069803+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\testing-dependencies.md"}, "doc_id": "e8b00759a407", "source_path": "docs\\advanced\\testing-dependencies.md", "title": "Тестирование зависимостей с переопределениями", "chunk_index": 3, "header": "Используйте атрибут `app.dependency_overrides`", "header_level": 3, "token_count": 449}
{"id": "f5194ff3ac4c1d8b", "text": "# Тестирование событий: lifespan и startup - shutdown { #testing-events-lifespan-and-startup-shutdown }\n\nЕсли вам нужно, чтобы `lifespan` выполнялся в ваших тестах, вы можете использовать `TestClient` вместе с оператором `with`:\n\n{* ../../docs_src/app_testing/tutorial004_py39.py hl[9:15,18,27:28,30:32,41:43] *}\n\nВы можете узнать больше подробностей в статье [Запуск lifespan в тестах на официальном сайте документации Starlette.](https://www.starlette.dev/lifespan/#running-lifespan-in-tests)\n\nДля устаревших событий `startup` и `shutdown` вы можете использовать `TestClient` следующим образом:\n\n{* ../../docs_src/app_testing/tutorial003_py39.py hl[9:12,20:24] *}\n", "metadata": {"source_path": "docs\\advanced\\testing-events.md", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\testing-events.md"}, "doc_id": "", "source_path": "docs\\advanced\\testing-events.md", "title": "", "chunk_index": 0, "header": "Тестирование событий: lifespan и startup - shutdown", "header_level": 1, "token_count": 228}
{"id": "7fe641734acd2ba5", "text": "# Тестирование WebSocket { #testing-websockets }\n\nВы можете использовать тот же `TestClient` для тестирования WebSocket.\n\nДля этого используйте `TestClient` с менеджером контекста `with`, подключаясь к WebSocket:\n\n{* ../../docs_src/app_testing/tutorial002_py39.py hl[27:31] *}\n\n/// note | Примечание\n\nПодробности смотрите в документации Starlette по <a href=\"https://www.starlette.dev/testclient/#testing-websocket-sessions\" class=\"external-link\" target=\"_blank\">тестированию WebSocket</a>.\n\n///\n", "metadata": {"title": "Тестирование WebSocket", "doc_id": "45c6f413cc6d", "source_path": "docs\\advanced\\testing-websockets.md", "source_mtime": "2026-01-12T17:48:13.081307+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\testing-websockets.md"}, "doc_id": "45c6f413cc6d", "source_path": "docs\\advanced\\testing-websockets.md", "title": "Тестирование WebSocket", "chunk_index": 0, "header": "Тестирование WebSocket", "header_level": 1, "token_count": 142}
{"id": "ae49926edc022a6e", "text": "# Прямое использование Request { #using-the-request-directly }\n\nДо этого вы объявляли нужные части HTTP-запроса вместе с их типами.\n\nИзвлекая данные из:\n\n* пути (как параметров),\n* HTTP-заголовков,\n* Cookie,\n* и т.д.\n\nТем самым **FastAPI** валидирует эти данные, преобразует их и автоматически генерирует документацию для вашего API.\n\nНо бывают ситуации, когда нужно обратиться к объекту `Request` напрямую.\n\n", "metadata": {"title": "Прямое использование Request", "doc_id": "82a444903904", "source_path": "docs\\advanced\\using-request-directly.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\using-request-directly.md"}, "doc_id": "82a444903904", "source_path": "docs\\advanced\\using-request-directly.md", "title": "Прямое использование Request", "chunk_index": 0, "header": "Прямое использование Request", "header_level": 1, "token_count": 162}
{"id": "88824a170676923a", "text": "## Подробности об объекте `Request` { #details-about-the-request-object }\n\nТак как под капотом **FastAPI** — это **Starlette** с дополнительным слоем инструментов, вы можете при необходимости напрямую использовать объект <a href=\"https://www.starlette.dev/requests/\" class=\"external-link\" target=\"_blank\">`Request`</a> из Starlette.\n\nЭто также означает, что если вы получаете данные напрямую из объекта `Request` (например, читаете тело запроса), то они не будут валидироваться, конвертироваться или документироваться (с OpenAPI, для автоматического пользовательского интерфейса API) средствами FastAPI.\n\nПри этом любой другой параметр, объявленный обычным образом (например, тело запроса с Pydantic-моделью), по-прежнему будет валидироваться, конвертироваться, аннотироваться и т.д.\n\nНо есть конкретные случаи, когда полезно получить объект `Request`.\n\n", "metadata": {"title": "Прямое использование Request", "doc_id": "82a444903904", "source_path": "docs\\advanced\\using-request-directly.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\using-request-directly.md"}, "doc_id": "82a444903904", "source_path": "docs\\advanced\\using-request-directly.md", "title": "Прямое использование Request", "chunk_index": 1, "header": "Подробности об объекте `Request`", "header_level": 2, "token_count": 296}
{"id": "ca3b5721f803a1fb", "text": "## Используйте объект `Request` напрямую { #use-the-request-object-directly }\n\nПредставим, что вы хотите получить IP-адрес/хост клиента внутри вашей *функции-обработчика пути*.\n\nДля этого нужно обратиться к запросу напрямую.\n\n{* ../../docs_src/using_request_directly/tutorial001_py39.py hl[1,7:8] *}\n\nЕсли объявить параметр *функции-обработчика пути* с типом `Request`, **FastAPI** поймёт, что нужно передать объект `Request` в этот параметр.\n\n/// tip | Совет\n\nОбратите внимание, что в этом примере мы объявляем path-параметр вместе с параметром `Request`.\n\nТаким образом, path-параметр будет извлечён, валидирован, преобразован к указанному типу и задокументирован в OpenAPI.\n\nТочно так же вы можете объявлять любые другие параметры как обычно и, дополнительно, получать `Request`.\n\n///\n\n", "metadata": {"title": "Прямое использование Request", "doc_id": "82a444903904", "source_path": "docs\\advanced\\using-request-directly.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\using-request-directly.md"}, "doc_id": "82a444903904", "source_path": "docs\\advanced\\using-request-directly.md", "title": "Прямое использование Request", "chunk_index": 2, "header": "Используйте объект `Request` напрямую", "header_level": 2, "token_count": 291}
{"id": "3e6acffcf341fe65", "text": "## Документация по `Request` { #request-documentation }\n\nПодробнее об <a href=\"https://www.starlette.dev/requests/\" class=\"external-link\" target=\"_blank\">объекте `Request` на официальном сайте документации Starlette</a>.\n\n/// note | Технические детали\n\nВы также можете использовать `from starlette.requests import Request`.\n\n**FastAPI** предоставляет его напрямую для удобства разработчика, но сам объект приходит из Starlette.\n\n///\n", "metadata": {"title": "Прямое использование Request", "doc_id": "82a444903904", "source_path": "docs\\advanced\\using-request-directly.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\using-request-directly.md"}, "doc_id": "82a444903904", "source_path": "docs\\advanced\\using-request-directly.md", "title": "Прямое использование Request", "chunk_index": 3, "header": "Документация по `Request`", "header_level": 2, "token_count": 133}
{"id": "6996fe36df2bbd2d", "text": "# Веб-сокеты { #websockets }\n\nВы можете использовать <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API\" class=\"external-link\" target=\"_blank\">веб-сокеты</a> в **FastAPI**.\n\n", "metadata": {"title": "Веб-сокеты", "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\websockets.md"}, "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "title": "Веб-сокеты", "chunk_index": 0, "header": "Веб-сокеты", "header_level": 1, "token_count": 62}
{"id": "f9968589abaf7b71", "text": "## Установка `websockets` { #install-websockets }\n\nУбедитесь, что вы создали [виртуальное окружение](../virtual-environments.md){.internal-link target=_blank}, активировали его и установили `websockets` (библиотека Python, упрощающая работу с протоколом \"WebSocket\"):\n\n<div class=\"termy\">\n\n```console\n$ pip install websockets\n\n---> 100%\n```\n\n</div>\n\n", "metadata": {"title": "Веб-сокеты", "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\websockets.md"}, "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "title": "Веб-сокеты", "chunk_index": 1, "header": "Установка `websockets`", "header_level": 2, "token_count": 116}
{"id": "5f38fb93f4bfe0d2", "text": "## Клиент WebSockets { #websockets-client }\n\n", "metadata": {"title": "Веб-сокеты", "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\websockets.md"}, "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "title": "Веб-сокеты", "chunk_index": 2, "header": "Клиент WebSockets", "header_level": 2, "token_count": 13}
{"id": "63599962aabfabe6", "text": "### В продакшн { #in-production }\n\nВ продакшн у вас, вероятно, есть фронтенд, созданный с помощью современного фреймворка вроде React, Vue.js или Angular.\n\nИ для взаимодействия с бекендом по WebSocket вы, скорее всего, будете использовать инструменты вашего фронтенда.\n\nТакже у вас может быть нативное мобильное приложение, которое напрямую, нативным кодом, взаимодействует с вашим WebSocket-бекендом.\n\nЛибо у вас может быть любой другой способ взаимодействия с WebSocket-эндпоинтом.\n\n---\n\nНо для этого примера мы воспользуемся очень простым HTML‑документом с небольшим JavaScript, всё внутри одной длинной строки.\n\nКонечно же, это неоптимально, и вы бы не использовали это в продакшн.\n\nВ продакшн у вас был бы один из вариантов выше.\n\nДля примера нам нужен наиболее простой способ, который позволит сосредоточиться на серверной части веб‑сокетов и получить рабочий код:\n\n{* ../../docs_src/websockets/tutorial001_py39.py hl[2,6:38,41:43] *}\n\n", "metadata": {"title": "Веб-сокеты", "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\websockets.md"}, "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "title": "Веб-сокеты", "chunk_index": 3, "header": "В продакшн", "header_level": 3, "token_count": 372}
{"id": "a60b9d763bd153d3", "text": "## Создание `websocket` { #create-a-websocket }\n\nСоздайте `websocket` в своем **FastAPI** приложении:\n\n{* ../../docs_src/websockets/tutorial001_py39.py hl[1,46:47] *}\n\n/// note | Технические детали\n\nВы также можете использовать `from starlette.websockets import WebSocket`.\n\n**FastAPI** напрямую предоставляет тот же самый `WebSocket` просто для удобства. На самом деле это `WebSocket` из Starlette.\n\n///\n\n", "metadata": {"title": "Веб-сокеты", "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\websockets.md"}, "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "title": "Веб-сокеты", "chunk_index": 4, "header": "Создание `websocket`", "header_level": 2, "token_count": 129}
{"id": "f732dead00c6a8b7", "text": "## Ожидание и отправка сообщений { #await-for-messages-and-send-messages }\n\nЧерез эндпоинт веб-сокета вы можете получать и отправлять сообщения.\n\n{* ../../docs_src/websockets/tutorial001_py39.py hl[48:52] *}\n\nВы можете получать и отправлять двоичные, текстовые и JSON данные.\n\n", "metadata": {"title": "Веб-сокеты", "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\websockets.md"}, "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "title": "Веб-сокеты", "chunk_index": 5, "header": "Ожидание и отправка сообщений", "header_level": 2, "token_count": 87}
{"id": "cbd6094907b23add", "text": "## Проверка в действии { #try-it }\n\nЕсли ваш файл называется `main.py`, то запустите приложение командой:\n\n<div class=\"termy\">\n\n```console\n$ fastapi dev main.py\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n</div>\n\nОткройте браузер по адресу <a href=\"http://127.0.0.1:8000\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000</a>.\n\nВы увидите следующую простенькую страницу:\n\n<img src=\"/img/tutorial/websockets/image01.png\">\n\nВы можете набирать сообщения в поле ввода и отправлять их:\n\n<img src=\"/img/tutorial/websockets/image02.png\">\n\nИ ваше **FastAPI** приложение с веб-сокетами ответит:\n\n<img src=\"/img/tutorial/websockets/image03.png\">\n\nВы можете отправлять и получать множество сообщений:\n\n<img src=\"/img/tutorial/websockets/image04.png\">\n\nИ все они будут использовать одно и то же веб-сокет соединение.\n\n", "metadata": {"title": "Веб-сокеты", "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\websockets.md"}, "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "title": "Веб-сокеты", "chunk_index": 6, "header": "Проверка в действии", "header_level": 2, "token_count": 291}
{"id": "94a246fc35d6b6af", "text": "## Использование `Depends` и не только { #using-depends-and-others }\n\nВы можете импортировать из `fastapi` и использовать в эндпоинте вебсокета:\n\n* `Depends`\n* `Security`\n* `Cookie`\n* `Header`\n* `Path`\n* `Query`\n\nОни работают так же, как и в других FastAPI эндпоинтах/*операциях пути*:\n\n{* ../../docs_src/websockets/tutorial002_an_py310.py hl[68:69,82] *}\n\n/// info | Примечание\n\nВ веб-сокете вызывать `HTTPException` не имеет смысла. Вместо этого нужно использовать `WebSocketException`.\n\nЗакрывающий статус код можно использовать из <a href=\"https://tools.ietf.org/html/rfc6455#section-7.4.1\" class=\"external-link\" target=\"_blank\">valid codes defined in the specification</a>.\n\n///\n\n", "metadata": {"title": "Веб-сокеты", "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\websockets.md"}, "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "title": "Веб-сокеты", "chunk_index": 7, "header": "Использование `Depends` и не только", "header_level": 2, "token_count": 237}
{"id": "2f2c2e6c1c437f8c", "text": "### Веб-сокеты с зависимостями: проверка в действии { #try-the-websockets-with-dependencies }\n\nЕсли ваш файл называется `main.py`, то запустите приложение командой:\n\n<div class=\"termy\">\n\n```console\n$ fastapi dev main.py\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n</div>\n\nОткройте браузер по адресу <a href=\"http://127.0.0.1:8000\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000</a>.\n\nТам вы можете задать:\n\n* \"Item ID\", используемый в пути.\n* \"Token\", используемый как query-параметр.\n\n/// tip | Подсказка\n\nОбратите внимание, что query-параметр `token` будет обработан в зависимости.\n\n///\n\nТеперь вы можете подключиться к веб-сокету и начинать отправку и получение сообщений:\n\n<img src=\"/img/tutorial/websockets/image05.png\">\n\n", "metadata": {"title": "Веб-сокеты", "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\websockets.md"}, "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "title": "Веб-сокеты", "chunk_index": 8, "header": "Веб-сокеты с зависимостями: проверка в действии", "header_level": 3, "token_count": 282}
{"id": "4f54f3f63bb4f43f", "text": "## Обработка отключений и работа с несколькими клиентами { #handling-disconnections-and-multiple-clients }\n\nЕсли веб-сокет соединение закрыто, то `await websocket.receive_text()` вызовет исключение `WebSocketDisconnect`, которое можно поймать и обработать как в этом примере:\n\n{* ../../docs_src/websockets/tutorial003_py39.py hl[79:81] *}\n\nЧтобы воспроизвести пример:\n\n* Откройте приложение в нескольких вкладках браузера.\n* Отправьте из них сообщения.\n* Затем закройте одну из вкладок.\n\nЭто вызовет исключение `WebSocketDisconnect`, и все остальные клиенты получат следующее сообщение:\n\n```\nClient #1596980209979 left the chat\n```\n\n/// tip | Подсказка\n\nПриложение выше - это всего лишь простой минимальный пример, демонстрирующий обработку и передачу сообщений нескольким веб-сокет соединениям.\n\nНо имейте в виду, что это будет работать только в одном процессе и только пока он активен, так как всё обрабатывается в простом списке в оперативной памяти.\n\nЕсли нужно что-то легко интегрируемое с FastAPI, но более надежное и с поддержкой Redis, PostgreSQL или другого, то можно воспользоваться <a href=\"https://github.com/encode/broadcaster\" class=\"external-link\" target=\"_blank\">encode/broadcaster</a>.\n\n///\n\n", "metadata": {"title": "Веб-сокеты", "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\websockets.md"}, "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "title": "Веб-сокеты", "chunk_index": 9, "header": "Обработка отключений и работа с несколькими клиентами", "header_level": 2, "token_count": 421}
{"id": "73bd4a9171a2bd6e", "text": "## Дополнительная информация { #more-info }\n\nДля более глубокого изучения темы воспользуйтесь документацией Starlette:\n\n* <a href=\"https://www.starlette.dev/websockets/\" class=\"external-link\" target=\"_blank\">The `WebSocket` class</a>.\n* <a href=\"https://www.starlette.dev/endpoints/#websocketendpoint\" class=\"external-link\" target=\"_blank\">Class-based WebSocket handling</a>.\n", "metadata": {"title": "Веб-сокеты", "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "source_mtime": "2026-01-12T17:48:13.085552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\websockets.md"}, "doc_id": "f4a1da77f16e", "source_path": "docs\\advanced\\websockets.md", "title": "Веб-сокеты", "chunk_index": 10, "header": "Дополнительная информация", "header_level": 2, "token_count": 107}
{"id": "63312a4ae101aae6", "text": "# Подключение WSGI — Flask, Django и другие { #including-wsgi-flask-django-others }\n\nВы можете монтировать WSGI‑приложения, как вы видели в [Подприложения — Mounts](sub-applications.md){.internal-link target=_blank}, [За прокси‑сервером](behind-a-proxy.md){.internal-link target=_blank}.\n\nДля этого вы можете использовать `WSGIMiddleware` и обернуть им ваше WSGI‑приложение, например Flask, Django и т.д.\n\n", "metadata": {"title": "Подключение WSGI — Flask, Django и другие", "doc_id": "6025d27842c0", "source_path": "docs\\advanced\\wsgi.md", "source_mtime": "2026-01-12T17:48:13.096498+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\wsgi.md"}, "doc_id": "6025d27842c0", "source_path": "docs\\advanced\\wsgi.md", "title": "Подключение WSGI — Flask, Django и другие", "chunk_index": 0, "header": "Подключение WSGI — Flask, Django и другие", "header_level": 1, "token_count": 141}
{"id": "4e7a547177b7b3e5", "text": "## Использование `WSGIMiddleware` { #using-wsgimiddleware }\n\nНужно импортировать `WSGIMiddleware`.\n\nЗатем оберните WSGI‑приложение (например, Flask) в middleware (Промежуточный слой).\n\nПосле этого смонтируйте его на путь.\n\n{* ../../docs_src/wsgi/tutorial001_py39.py hl[2:3,3] *}\n\n", "metadata": {"title": "Подключение WSGI — Flask, Django и другие", "doc_id": "6025d27842c0", "source_path": "docs\\advanced\\wsgi.md", "source_mtime": "2026-01-12T17:48:13.096498+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\wsgi.md"}, "doc_id": "6025d27842c0", "source_path": "docs\\advanced\\wsgi.md", "title": "Подключение WSGI — Flask, Django и другие", "chunk_index": 1, "header": "Использование `WSGIMiddleware`", "header_level": 2, "token_count": 107}
{"id": "ad5b7dfa00d94266", "text": "## Проверьте { #check-it }\n\nТеперь каждый HTTP‑запрос по пути `/v1/` будет обрабатываться приложением Flask.\n\nА всё остальное будет обрабатываться **FastAPI**.\n\nЕсли вы запустите это и перейдёте по <a href=\"http://localhost:8000/v1/\" class=\"external-link\" target=\"_blank\">http://localhost:8000/v1/</a>, вы увидите HTTP‑ответ от Flask:\n\n```txt\nHello, World from Flask!\n```\n\nА если вы перейдёте по <a href=\"http://localhost:8000/v2\" class=\"external-link\" target=\"_blank\">http://localhost:8000/v2</a>, вы увидите HTTP‑ответ от FastAPI:\n\n```JSON\n{\n    \"message\": \"Hello World\"\n}\n```\n", "metadata": {"title": "Подключение WSGI — Flask, Django и другие", "doc_id": "6025d27842c0", "source_path": "docs\\advanced\\wsgi.md", "source_mtime": "2026-01-12T17:48:13.096498+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\wsgi.md"}, "doc_id": "6025d27842c0", "source_path": "docs\\advanced\\wsgi.md", "title": "Подключение WSGI — Flask, Django и другие", "chunk_index": 2, "header": "Проверьте", "header_level": 2, "token_count": 203}
{"id": "68857fea257435ac", "text": "# HTTP Basic Auth { #http-basic-auth }\n\nДля самых простых случаев можно использовать HTTP Basic Auth.\n\nПри HTTP Basic Auth приложение ожидает HTTP-заголовок, который содержит имя пользователя и пароль.\n\nЕсли его нет, возвращается ошибка HTTP 401 «Unauthorized».\n\nТакже возвращается заголовок `WWW-Authenticate` со значением `Basic` и необязательным параметром `realm`.\n\nЭто говорит браузеру показать встроенное окно запроса имени пользователя и пароля.\n\nЗатем, когда вы вводите эти данные, браузер автоматически отправляет их в заголовке.\n\n", "metadata": {"title": "HTTP Basic Auth", "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "source_mtime": "2026-01-12T17:48:13.110955+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\http-basic-auth.md"}, "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "title": "HTTP Basic Auth", "chunk_index": 0, "header": "HTTP Basic Auth", "header_level": 1, "token_count": 172}
{"id": "8fbb0d29d774b8e8", "text": "## Простой HTTP Basic Auth { #simple-http-basic-auth }\n\n* Импортируйте `HTTPBasic` и `HTTPBasicCredentials`.\n* Создайте «схему» `security` с помощью `HTTPBasic`.\n* Используйте эту `security` как зависимость в вашей *операции пути*.\n* Она возвращает объект типа `HTTPBasicCredentials`:\n    * Он содержит отправленные `username` и `password`.\n\n{* ../../docs_src/security/tutorial006_an_py39.py hl[4,8,12] *}\n\nКогда вы впервые откроете URL (или нажмёте кнопку «Execute» в документации), браузер попросит ввести имя пользователя и пароль:\n\n<img src=\"/img/tutorial/security/image12.png\">\n\n", "metadata": {"title": "HTTP Basic Auth", "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "source_mtime": "2026-01-12T17:48:13.110955+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\http-basic-auth.md"}, "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "title": "HTTP Basic Auth", "chunk_index": 1, "header": "Простой HTTP Basic Auth", "header_level": 2, "token_count": 194}
{"id": "9972330b2c1d92da", "text": "## Проверка имени пользователя { #check-the-username }\n\nВот более полный пример.\n\nИспользуйте зависимость, чтобы проверить, корректны ли имя пользователя и пароль.\n\nДля этого используйте стандартный модуль Python <a href=\"https://docs.python.org/3/library/secrets.html\" class=\"external-link\" target=\"_blank\">`secrets`</a> для проверки имени пользователя и пароля.\n\n`secrets.compare_digest()` должен получать `bytes` или `str`, который содержит только символы ASCII (английские символы). Это значит, что он не будет работать с символами вроде `á`, как в `Sebastián`.\n\nЧтобы это обработать, сначала преобразуем `username` и `password` в `bytes`, закодировав их в UTF-8.\n\nЗатем можно использовать `secrets.compare_digest()`, чтобы убедиться, что `credentials.username` равен `\"stanleyjobson\"`, а `credentials.password` — `\"swordfish\"`.\n\n{* ../../docs_src/security/tutorial007_an_py39.py hl[1,12:24] *}\n\nЭто было бы похоже на:\n\n```Python\nif not (credentials.username == \"stanleyjobson\") or not (credentials.password == \"swordfish\"):\n    # Вернуть ошибку\n    ...\n```\n\nНо используя `secrets.compare_digest()`, вы защитите код от атак типа «тайминговая атака» (атака по времени).\n\n", "metadata": {"title": "HTTP Basic Auth", "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "source_mtime": "2026-01-12T17:48:13.110955+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\http-basic-auth.md"}, "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "title": "HTTP Basic Auth", "chunk_index": 2, "header": "Проверка имени пользователя", "header_level": 2, "token_count": 371}
{"id": "68857fea257435ac", "text": "### Тайминговые атаки { #timing-attacks }\n\nЧто такое «тайминговая атака»?\n\nПредставим, что злоумышленники пытаются угадать имя пользователя и пароль.\n\nИ они отправляют запрос с именем пользователя `johndoe` и паролем `love123`.\n\nТогда Python-код в вашем приложении будет эквивалентен чему-то вроде:\n\n```Python\nif \"johndoe\" == \"stanleyjobson\" and \"love123\" == \"swordfish\":\n    ...\n```\n\nНо в момент, когда Python сравнит первую `j` в `johndoe` с первой `s` в `stanleyjobson`, он вернёт `False`, потому что уже ясно, что строки не совпадают, решив, что «нет смысла тратить ресурсы на сравнение остальных букв». И ваше приложение ответит «Неверное имя пользователя или пароль».\n\nЗатем злоумышленники попробуют имя пользователя `stanleyjobsox` и пароль `love123`.\n\nИ ваш код сделает что-то вроде:\n\n```Python\nif \"stanleyjobsox\" == \"stanleyjobson\" and \"love123\" == \"swordfish\":\n    ...\n```\n\nPythonу придётся сравнить весь общий префикс `stanleyjobso` в `stanleyjobsox` и `stanleyjobson`, прежде чем понять, что строки отличаются. Поэтому на ответ «Неверное имя пользователя или пароль» уйдёт на несколько микросекунд больше.\n\n#### Время ответа помогает злоумышленникам { #the-time-to-answer-helps-the-attackers }", "metadata": {"title": "HTTP Basic Auth", "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "source_mtime": "2026-01-12T17:48:13.110955+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\http-basic-auth.md", "section_header": "Тайминговые атаки", "section_header_level": 3}, "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "title": "HTTP Basic Auth", "chunk_index": 3, "header": "Тайминговые атаки", "header_level": 3, "token_count": 475}
{"id": "8fbb0d29d774b8e8", "text": "этому на ответ «Неверное имя пользователя или пароль» уйдёт на несколько микросекунд больше.\n\n#### Время ответа помогает злоумышленникам { #the-time-to-answer-helps-the-attackers }\n\nЗамечая, что сервер прислал «Неверное имя пользователя или пароль» на несколько микросекунд позже, злоумышленники поймут, что какая-то часть была угадана — начальные буквы верны.\n\nТогда они могут попробовать снова, зная, что правильнее что-то ближе к `stanleyjobsox`, чем к `johndoe`.\n\n#### «Профессиональная» атака { #a-professional-attack }\n\nКонечно, злоумышленники не будут делать всё это вручную — они напишут программу, возможно, с тысячами или миллионами попыток в секунду. И будут подбирать по одной дополнительной верной букве за раз.\n\nТак за минуты или часы они смогут угадать правильные имя пользователя и пароль — с «помощью» нашего приложения — используя лишь время, затраченное на ответ.\n\n#### Исправление с помощью `secrets.compare_digest()` { #fix-it-with-secrets-compare-digest }\n\nНо в нашем коде мы используем `secrets.compare_digest()`.\n\nВкратце: сравнение `stanleyjobsox` с `stanleyjobson` займёт столько же времени, сколько и сравнение `johndoe` с `stanleyjobson`. То же относится и к паролю.", "metadata": {"title": "HTTP Basic Auth", "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "source_mtime": "2026-01-12T17:48:13.110955+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\http-basic-auth.md", "section_header": "Тайминговые атаки", "section_header_level": 3}, "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "title": "HTTP Basic Auth", "chunk_index": 4, "header": "Тайминговые атаки", "header_level": 3, "token_count": 474}
{"id": "9972330b2c1d92da", "text": "сравнение `stanleyjobsox` с `stanleyjobson` займёт столько же времени, сколько и сравнение `johndoe` с `stanleyjobson`. То же относится и к паролю.\n\nТаким образом, используя `secrets.compare_digest()` в коде приложения, вы защитите его от всего этого класса атак на безопасность.", "metadata": {"title": "HTTP Basic Auth", "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "source_mtime": "2026-01-12T17:48:13.110955+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\http-basic-auth.md", "section_header": "Тайминговые атаки", "section_header_level": 3}, "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "title": "HTTP Basic Auth", "chunk_index": 5, "header": "Тайминговые атаки", "header_level": 3, "token_count": 109}
{"id": "210535c82aa37224", "text": "### Возврат ошибки { #return-the-error }\n\nПосле того как обнаружено, что учётные данные некорректны, верните `HTTPException` со статус-кодом ответа 401 (тем же, что и при отсутствии учётных данных) и добавьте HTTP-заголовок `WWW-Authenticate`, чтобы браузер снова показал окно входа:\n\n{* ../../docs_src/security/tutorial007_an_py39.py hl[26:30] *}\n", "metadata": {"title": "HTTP Basic Auth", "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "source_mtime": "2026-01-12T17:48:13.110955+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\http-basic-auth.md"}, "doc_id": "040ee4091e68", "source_path": "docs\\advanced\\security\\http-basic-auth.md", "title": "HTTP Basic Auth", "chunk_index": 6, "header": "Возврат ошибки", "header_level": 3, "token_count": 131}
{"id": "bb737298833922c2", "text": "# Расширенная безопасность { #advanced-security }\n\n", "metadata": {"title": "Расширенная безопасность", "doc_id": "4a4d24694f8a", "source_path": "docs\\advanced\\security\\index.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\index.md"}, "doc_id": "4a4d24694f8a", "source_path": "docs\\advanced\\security\\index.md", "title": "Расширенная безопасность", "chunk_index": 0, "header": "Расширенная безопасность", "header_level": 1, "token_count": 16}
{"id": "c4d402eb16274e94", "text": "## Дополнительные возможности { #additional-features }\n\nЕсть дополнительные возможности для работы с безопасностью помимо тех, что описаны в [Учебник — Руководство пользователя: Безопасность](../../tutorial/security/index.md){.internal-link target=_blank}.\n\n/// tip | Совет\n\nСледующие разделы **не обязательно являются «продвинутыми»**.\n\nИ возможно, что решение для вашего варианта использования находится в одном из них.\n\n///\n\n", "metadata": {"title": "Расширенная безопасность", "doc_id": "4a4d24694f8a", "source_path": "docs\\advanced\\security\\index.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\index.md"}, "doc_id": "4a4d24694f8a", "source_path": "docs\\advanced\\security\\index.md", "title": "Расширенная безопасность", "chunk_index": 1, "header": "Дополнительные возможности", "header_level": 2, "token_count": 147}
{"id": "17ea0e1e5e1da27a", "text": "## Сначала прочитайте руководство { #read-the-tutorial-first }\n\nВ следующих разделах предполагается, что вы уже прочитали основной [Учебник — Руководство пользователя: Безопасность](../../tutorial/security/index.md){.internal-link target=_blank}.\n\nВсе они основаны на тех же концепциях, но предоставляют дополнительные возможности.\n", "metadata": {"title": "Расширенная безопасность", "doc_id": "4a4d24694f8a", "source_path": "docs\\advanced\\security\\index.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\index.md"}, "doc_id": "4a4d24694f8a", "source_path": "docs\\advanced\\security\\index.md", "title": "Расширенная безопасность", "chunk_index": 2, "header": "Сначала прочитайте руководство", "header_level": 2, "token_count": 117}
{"id": "129ab07419015e16", "text": "# OAuth2 scopes { #oauth2-scopes }\n\nВы можете использовать OAuth2 scopes (scope - область, рамки) напрямую с **FastAPI** — они интегрированы и работают бесшовно.\n\nЭто позволит вам иметь более детальную систему разрешений по стандарту OAuth2, интегрированную в ваше OpenAPI‑приложение (и документацию API).\n\nOAuth2 со scopes — это механизм, который используют многие крупные провайдеры аутентификации: Facebook, Google, GitHub, Microsoft, X (Twitter) и т.д. Они применяют его, чтобы предоставлять конкретные разрешения пользователям и приложениям.\n\nКаждый раз, когда вы «входите через» Facebook, Google, GitHub, Microsoft, X (Twitter), это приложение использует OAuth2 со scopes.\n\nВ этом разделе вы увидите, как управлять аутентификацией и авторизацией с теми же OAuth2 scopes в вашем приложении на **FastAPI**.\n\n/// warning | Предупреждение\n\nЭто более-менее продвинутый раздел. Если вы только начинаете, можете пропустить его.\n\nВам не обязательно нужны OAuth2 scopes — аутентификацию и авторизацию можно реализовать любым нужным вам способом.\n\nНо OAuth2 со scopes можно красиво интегрировать в ваш API (через OpenAPI) и документацию API.\n\nТак или иначе, вы все равно будете применять эти scopes или какие-то другие требования безопасности/авторизации, как вам нужно, в вашем коде.\n\nВо многих случаях OAuth2 со scopes может быть избыточным.", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md", "section_header": "OAuth2 scopes", "section_header_level": 1}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 0, "header": "OAuth2 scopes", "header_level": 1, "token_count": 492}
{"id": "11c330cb4143e4cf", "text": "е применять эти scopes или какие-то другие требования безопасности/авторизации, как вам нужно, в вашем коде.\n\nВо многих случаях OAuth2 со scopes может быть избыточным.\n\nНо если вы знаете, что это нужно, или вам просто интересно — продолжайте чтение.\n\n///", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md", "section_header": "OAuth2 scopes", "section_header_level": 1}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 1, "header": "OAuth2 scopes", "header_level": 1, "token_count": 96}
{"id": "bd6a69886e8321ff", "text": "## OAuth2 scopes и OpenAPI { #oauth2-scopes-and-openapi }\n\nСпецификация OAuth2 определяет «scopes» как список строк, разделённых пробелами.\n\nСодержимое каждой такой строки может иметь любой формат, но не должно содержать пробелов.\n\nЭти scopes представляют «разрешения».\n\nВ OpenAPI (например, в документации API) можно определить «схемы безопасности» (security schemes).\n\nКогда одна из таких схем безопасности использует OAuth2, вы также можете объявлять и использовать scopes.\n\nКаждый «scope» — это просто строка (без пробелов).\n\nОбычно они используются для объявления конкретных разрешений безопасности, например:\n\n- `users:read` или `users:write` — распространённые примеры.\n- `instagram_basic` используется Facebook / Instagram.\n- `https://www.googleapis.com/auth/drive` используется Google.\n\n/// info | Информация\n\nВ OAuth2 «scope» — это просто строка, объявляющая требуемое конкретное разрешение.\n\nНеважно, есть ли там другие символы, такие как `:`, или это URL.\n\nЭти детали зависят от реализации.\n\nДля OAuth2 это просто строки.\n\n///\n\n", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md"}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 2, "header": "OAuth2 scopes и OpenAPI", "header_level": 2, "token_count": 360}
{"id": "957994d5fcf924bd", "text": "## Взгляд издалека { #global-view }\n\nСначала быстро посмотрим, что изменилось по сравнению с примерами из основного раздела **Учебник - Руководство пользователя** — [OAuth2 с паролем (и хешированием), Bearer с JWT-токенами](../../tutorial/security/oauth2-jwt.md){.internal-link target=_blank}. Теперь — с использованием OAuth2 scopes:\n\n{* ../../docs_src/security/tutorial005_an_py310.py hl[5,9,13,47,65,106,108:116,122:126,130:136,141,157] *}\n\nТеперь рассмотрим эти изменения шаг за шагом.\n\n", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md"}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 3, "header": "Взгляд издалека", "header_level": 2, "token_count": 180}
{"id": "de2b6283e5436818", "text": "## OAuth2 схема безопасности { #oauth2-security-scheme }\n\nПервое изменение — мы объявляем схему безопасности OAuth2 с двумя доступными scopes: `me` и `items`.\n\nПараметр `scopes` получает `dict`, где каждый scope — это ключ, а описание — значение:\n\n{* ../../docs_src/security/tutorial005_an_py310.py hl[63:66] *}\n\nТак как теперь мы объявляем эти scopes, они появятся в документации API при входе/авторизации.\n\nИ вы сможете выбрать, какие scopes вы хотите выдать доступ: `me` и `items`.\n\nЭто тот же механизм, когда вы даёте разрешения при входе через Facebook, Google, GitHub и т.д.:\n\n<img src=\"/img/tutorial/security/image11.png\">\n\n", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md"}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 4, "header": "OAuth2 схема безопасности", "header_level": 2, "token_count": 217}
{"id": "4520b3fbff81d57d", "text": "## JWT-токены со scopes { #jwt-token-with-scopes }\n\nТеперь измените операцию пути, выдающую токен, чтобы возвращать запрошенные scopes.\n\nМы всё ещё используем тот же `OAuth2PasswordRequestForm`. Он включает свойство `scopes` с `list` из `str` — каждый scope, полученный в запросе.\n\nИ мы возвращаем scopes как часть JWT‑токена.\n\n/// danger | Опасность\n\nДля простоты здесь мы просто добавляем полученные scopes прямо в токен.\n\nНо в вашем приложении, в целях безопасности, следует убедиться, что вы добавляете только те scopes, которые пользователь действительно может иметь, или те, которые вы заранее определили.\n\n///\n\n{* ../../docs_src/security/tutorial005_an_py310.py hl[157] *}\n\n", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md"}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 5, "header": "JWT-токены со scopes", "header_level": 2, "token_count": 237}
{"id": "129ab07419015e16", "text": "## Объявление scopes в *обработчиках путей* и зависимостях { #declare-scopes-in-path-operations-and-dependencies }\n\nТеперь объявим, что операция пути для `/users/me/items/` требует scope `items`.\n\nДля этого импортируем и используем `Security` из `fastapi`.\n\nВы можете использовать `Security` для объявления зависимостей (как `Depends`), но `Security` также принимает параметр `scopes` со списком scopes (строк).\n\nВ этом случае мы передаём функцию‑зависимость `get_current_active_user` в `Security` (точно так же, как сделали бы с `Depends`).\n\nНо мы также передаём `list` scopes — в данном случае только один scope: `items` (их могло быть больше).\n\nИ функция‑зависимость `get_current_active_user` тоже может объявлять подзависимости не только через `Depends`, но и через `Security`, объявляя свою подзависимость (`get_current_user`) и дополнительные требования по scopes.\n\nВ данном случае требуется scope `me` (их также могло быть больше одного).\n\n/// note | Примечание\n\nВам не обязательно добавлять разные scopes в разных местах.\n\nМы делаем это здесь, чтобы показать, как **FastAPI** обрабатывает scopes, объявленные на разных уровнях.\n\n///\n\n{* ../../docs_src/security/tutorial005_an_py310.py hl[5,141,172] *}\n\n/// info | Технические детали\n\n`Security` на самом деле является подклассом `Depends` и имеет всего один дополнительный параметр, который мы рассмотрим позже.", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md", "section_header": "Объявление scopes в *обработчиках путей* и зависимостях", "section_header_level": 2}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 6, "header": "Объявление scopes в *обработчиках путей* и зависимостях", "header_level": 2, "token_count": 481}
{"id": "11c330cb4143e4cf", "text": "172] *}\n\n/// info | Технические детали\n\n`Security` на самом деле является подклассом `Depends` и имеет всего один дополнительный параметр, который мы рассмотрим позже.\n\nНо используя `Security` вместо `Depends`, **FastAPI** будет знать, что можно объявлять security scopes, использовать их внутри и документировать API в OpenAPI.\n\nОднако когда вы импортируете `Query`, `Path`, `Depends`, `Security` и другие из `fastapi`, это на самом деле функции, возвращающие специальные классы.\n\n///", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md", "section_header": "Объявление scopes в *обработчиках путей* и зависимостях", "section_header_level": 2}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 7, "header": "Объявление scopes в *обработчиках путей* и зависимостях", "header_level": 2, "token_count": 177}
{"id": "a3827206dc1ae270", "text": "## Использование `SecurityScopes` { #use-securityscopes }\n\nТеперь обновим зависимость `get_current_user`.\n\nИменно её используют зависимости выше.\n\nЗдесь мы используем ту же схему OAuth2, созданную ранее, объявляя её как зависимость: `oauth2_scheme`.\n\nПоскольку у этой функции‑зависимости нет собственных требований по scopes, мы можем использовать `Depends` с `oauth2_scheme` — нам не нужно использовать `Security`, если не требуется указывать security scopes.\n\nМы также объявляем специальный параметр типа `SecurityScopes`, импортированный из `fastapi.security`.\n\nКласс `SecurityScopes` похож на `Request` (через `Request` мы получали сам объект запроса).\n\n{* ../../docs_src/security/tutorial005_an_py310.py hl[9,106] *}\n\n", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md"}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 8, "header": "Использование `SecurityScopes`", "header_level": 2, "token_count": 240}
{"id": "d6d0410624dce1fb", "text": "## Использование `scopes` { #use-the-scopes }\n\nПараметр `security_scopes` будет типа `SecurityScopes`.\n\nУ него есть свойство `scopes` со списком, содержащим все scopes, требуемые им самим и всеми зависимостями, использующими его как подзависимость. То есть всеми «зависящими»… это может звучать запутанно, ниже есть дополнительное объяснение.\n\nОбъект `security_scopes` (класс `SecurityScopes`) также предоставляет атрибут `scope_str` — это одна строка с этими scopes, разделёнными пробелами (мы будем её использовать).\n\nМы создаём `HTTPException`, который можем переиспользовать (`raise`) в нескольких местах.\n\nВ этом исключении мы включаем требуемые scopes (если есть) в виде строки, разделённой пробелами (используя `scope_str`). Эту строку со scopes мы помещаем в HTTP‑заголовок `WWW-Authenticate` (это часть спецификации).\n\n{* ../../docs_src/security/tutorial005_an_py310.py hl[106,108:116] *}\n\n", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md"}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 9, "header": "Использование `scopes`", "header_level": 2, "token_count": 327}
{"id": "85fd0f4048154c8d", "text": "## Проверка `username` и формата данных { #verify-the-username-and-data-shape }\n\nМы проверяем, что получили `username`, и извлекаем scopes.\n\nЗатем валидируем эти данные с помощью Pydantic‑модели (перехватывая исключение `ValidationError`), и если возникает ошибка при чтении JWT‑токена или при валидации данных с Pydantic, мы вызываем `HTTPException`, созданное ранее.\n\nДля этого мы обновляем Pydantic‑модель `TokenData`, добавляя новое свойство `scopes`.\n\nВалидируя данные с помощью Pydantic, мы можем удостовериться, что у нас, например, именно `list` из `str` со scopes и `str` с `username`.\n\nА не, скажем, `dict` или что‑то ещё — ведь это могло бы где‑то позже сломать приложение и создать риск для безопасности.\n\nМы также проверяем, что существует пользователь с таким именем, и если нет — вызываем то же исключение, созданное ранее.\n\n{* ../../docs_src/security/tutorial005_an_py310.py hl[47,117:129] *}\n\n", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md"}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 10, "header": "Проверка `username` и формата данных", "header_level": 2, "token_count": 319}
{"id": "53b8ec5508716393", "text": "## Проверка `scopes` { #verify-the-scopes }\n\nТеперь проверяем, что все требуемые scopes — этой зависимостью и всеми зависящими (включая операции пути) — присутствуют среди scopes, предоставленных в полученном токене, иначе вызываем `HTTPException`.\n\nДля этого используем `security_scopes.scopes`, содержащий `list` со всеми этими scopes как `str`.\n\n{* ../../docs_src/security/tutorial005_an_py310.py hl[130:136] *}\n\n", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md"}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 11, "header": "Проверка `scopes`", "header_level": 2, "token_count": 143}
{"id": "129ab07419015e16", "text": "## Дерево зависимостей и scopes { #dependency-tree-and-scopes }\n\nЕщё раз рассмотрим дерево зависимостей и scopes.\n\nТак как у зависимости `get_current_active_user` есть подзависимость `get_current_user`, scope `\"me\"`, объявленный в `get_current_active_user`, будет включён в список требуемых scopes в `security_scopes.scopes`, передаваемый в `get_current_user`.\n\nСама операция пути тоже объявляет scope — `\"items\"`, поэтому он также будет в списке `security_scopes.scopes`, передаваемом в `get_current_user`.\n\nИерархия зависимостей и scopes выглядит так:", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md", "section_header": "Дерево зависимостей и scopes", "section_header_level": 2}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 12, "header": "Дерево зависимостей и scopes", "header_level": 2, "token_count": 183}
{"id": "11c330cb4143e4cf", "text": "пути тоже объявляет scope — `\"items\"`, поэтому он также будет в списке `security_scopes.scopes`, передаваемом в `get_current_user`.\n\nИерархия зависимостей и scopes выглядит так:\n\n- Операция пути `read_own_items`:\n  - Запрашивает scopes `[\"items\"]` с зависимостью:\n  - `get_current_active_user`:\n    - Функция‑зависимость `get_current_active_user`:\n      - Запрашивает scopes `[\"me\"]` с зависимостью:\n      - `get_current_user`:\n        - Функция‑зависимость `get_current_user`:\n          - Собственных scopes не запрашивает.\n          - Имеет зависимость, использующую `oauth2_scheme`.\n          - Имеет параметр `security_scopes` типа `SecurityScopes`:\n            - Этот параметр `security_scopes` имеет свойство `scopes` с `list`, содержащим все объявленные выше scopes, то есть:\n              - `security_scopes.scopes` будет содержать `[\"me\", \"items\"]` для операции пути `read_own_items`.\n              - `security_scopes.scopes` будет содержать `[\"me\"]` для операции пути `read_users_me`, потому что он объявлен в зависимости `get_current_active_user`.\n              - `security_scopes.scopes` будет содержать `[]` (ничего) для операции пути `read_system_status`, потому что там не объявлялся `Security` со `scopes`, и его зависимость `get_current_user` тоже не объявляет `scopes`.\n\n/// tip | Совет\n\nВажный и «магический» момент здесь в том, что `get_current_user` будет иметь разный список `scopes` для проверки для каждой операции пути.", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md", "section_header": "Дерево зависимостей и scopes", "section_header_level": 2}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 13, "header": "Дерево зависимостей и scopes", "header_level": 2, "token_count": 477}
{"id": "bd6a69886e8321ff", "text": "объявляет `scopes`.\n\n/// tip | Совет\n\nВажный и «магический» момент здесь в том, что `get_current_user` будет иметь разный список `scopes` для проверки для каждой операции пути.\n\nВсё это зависит от `scopes`, объявленных в каждой операции пути и в каждой зависимости в дереве зависимостей конкретной операции пути.\n\n///", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md", "section_header": "Дерево зависимостей и scopes", "section_header_level": 2}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 14, "header": "Дерево зависимостей и scopes", "header_level": 2, "token_count": 119}
{"id": "184a3e663574d357", "text": "## Больше деталей о `SecurityScopes` { #more-details-about-securityscopes }\n\nВы можете использовать `SecurityScopes` в любой точке и в нескольких местах — необязательно в «корневой» зависимости.\n\nОн всегда будет содержать security scopes, объявленные в текущих зависимостях `Security`, и всеми зависящими — для этой конкретной операции пути и этого конкретного дерева зависимостей.\n\nПоскольку `SecurityScopes` будет содержать все scopes, объявленные зависящими, вы можете использовать его, чтобы централизованно проверять наличие требуемых scopes в токене в одной функции‑зависимости, а затем объявлять разные требования по scopes в разных операциях пути.\n\nОни будут проверяться независимо для каждой операции пути.\n\n", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md"}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 15, "header": "Больше деталей о `SecurityScopes`", "header_level": 2, "token_count": 259}
{"id": "ae0e43ccc3d7f66a", "text": "## Проверим это { #check-it }\n\nОткройте документацию API — вы сможете аутентифицироваться и указать, какие scopes вы хотите авторизовать.\n\n<img src=\"/img/tutorial/security/image11.png\">\n\nЕсли вы не выберете ни один scope, вы будете «аутентифицированы», но при попытке доступа к `/users/me/` или `/users/me/items/` получите ошибку о недостаточных разрешениях. При этом доступ к `/status/` будет возможен.\n\nЕсли вы выберете scope `me`, но не `items`, вы сможете получить доступ к `/users/me/`, но не к `/users/me/items/`.\n\nТак и будет происходить со сторонним приложением, которое попытается обратиться к одной из этих операций пути с токеном, предоставленным пользователем, — в зависимости от того, сколько разрешений пользователь дал приложению.\n\n", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md"}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 16, "header": "Проверим это", "header_level": 2, "token_count": 269}
{"id": "4df5d3c72d109154", "text": "## О сторонних интеграциях { #about-third-party-integrations }\n\nВ этом примере мы используем OAuth2 «password flow» (аутентификация по паролю).\n\nЭто уместно, когда мы входим в наше собственное приложение, вероятно, с нашим собственным фронтендом.\n\nМы можем ему доверять при получении `username` и `password`, потому что он под нашим контролем.\n\nНо если вы создаёте OAuth2‑приложение, к которому будут подключаться другие (т.е. вы строите провайдера аутентификации наподобие Facebook, Google, GitHub и т.п.), вам следует использовать один из других «flows».\n\nСамый распространённый — «implicit flow».\n\nСамый безопасный — «code flow», но он сложнее в реализации, так как требует больше шагов. Из‑за сложности многие провайдеры в итоге рекомендуют «implicit flow».\n\n/// note | Примечание\n\nЧасто каждый провайдер аутентификации называет свои «flows» по‑разному — как часть бренда.\n\nНо в итоге они реализуют один и тот же стандарт OAuth2.\n\n///\n\nFastAPI включает утилиты для всех этих OAuth2‑flows в `fastapi.security.oauth2`.\n\n", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md"}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 17, "header": "О сторонних интеграциях", "header_level": 2, "token_count": 392}
{"id": "f620f300682e31aa", "text": "## `Security` в параметре `dependencies` декоратора { #security-in-decorator-dependencies }\n\nТочно так же, как вы можете определить `list` из `Depends` в параметре `dependencies` декоратора (см. [Зависимости в декораторах операции пути](../../tutorial/dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank}), вы можете использовать там и `Security` со `scopes`.\n", "metadata": {"title": "OAuth2 scopes", "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "source_mtime": "2026-01-12T17:48:13.117269+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\advanced\\security\\oauth2-scopes.md"}, "doc_id": "90946de2b31f", "source_path": "docs\\advanced\\security\\oauth2-scopes.md", "title": "OAuth2 scopes", "chunk_index": 18, "header": "`Security` в параметре `dependencies` декоратора", "header_level": 2, "token_count": 119}
{"id": "61ccf398e4b84515", "text": "# Развертывание FastAPI у облачных провайдеров { #deploy-fastapi-on-cloud-providers }\n\nВы можете использовать практически любого облачного провайдера, чтобы развернуть свое приложение на FastAPI.\n\nВ большинстве случаев у основных облачных провайдеров есть руководства по развертыванию FastAPI на их платформе.\n\n", "metadata": {"title": "Развертывание FastAPI у облачных провайдеров", "doc_id": "a592378a2c88", "source_path": "docs\\deployment\\cloud.md", "source_mtime": "2026-01-12T17:48:13.138104+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\cloud.md"}, "doc_id": "a592378a2c88", "source_path": "docs\\deployment\\cloud.md", "title": "Развертывание FastAPI у облачных провайдеров", "chunk_index": 0, "header": "Развертывание FastAPI у облачных провайдеров", "header_level": 1, "token_count": 108}
{"id": "608d23eae9cf9abb", "text": "## FastAPI Cloud { #fastapi-cloud }\n\n**<a href=\"https://fastapicloud.com\" class=\"external-link\" target=\"_blank\">FastAPI Cloud</a>** создан тем же автором и командой, стоящими за **FastAPI**.\n\nОн упрощает процесс **создания образа**, **развертывания** и **доступа** к API с минимальными усилиями.\n\nОн переносит тот же **опыт разработчика** создания приложений с FastAPI на их **развертывание** в облаке. \n\nFastAPI Cloud — основной спонсор и источник финансирования для open source проектов *FastAPI and friends*. \n\n", "metadata": {"title": "Развертывание FastAPI у облачных провайдеров", "doc_id": "a592378a2c88", "source_path": "docs\\deployment\\cloud.md", "source_mtime": "2026-01-12T17:48:13.138104+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\cloud.md"}, "doc_id": "a592378a2c88", "source_path": "docs\\deployment\\cloud.md", "title": "Развертывание FastAPI у облачных провайдеров", "chunk_index": 1, "header": "FastAPI Cloud", "header_level": 2, "token_count": 189}
{"id": "c359ecb4730053c6", "text": "## Облачные провайдеры — спонсоры { #cloud-providers-sponsors }\n\nНекоторые другие облачные провайдеры  [**спонсируют FastAPI**](../help-fastapi.md#sponsor-the-author){.internal-link target=_blank}  тоже. \n\nВозможно, вы захотите попробовать их сервисы и воспользоваться их руководствами:\n\n* <a href=\"https://docs.render.com/deploy-fastapi?utm_source=deploydoc&utm_medium=referral&utm_campaign=fastapi\" class=\"external-link\" target=\"_blank\">Render</a>\n* <a href=\"https://docs.railway.com/guides/fastapi?utm_medium=integration&utm_source=docs&utm_campaign=fastapi\" class=\"external-link\" target=\"_blank\">Railway</a>\n", "metadata": {"title": "Развертывание FastAPI у облачных провайдеров", "doc_id": "a592378a2c88", "source_path": "docs\\deployment\\cloud.md", "source_mtime": "2026-01-12T17:48:13.138104+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\cloud.md"}, "doc_id": "a592378a2c88", "source_path": "docs\\deployment\\cloud.md", "title": "Развертывание FastAPI у облачных провайдеров", "chunk_index": 2, "header": "Облачные провайдеры — спонсоры", "header_level": 2, "token_count": 200}
{"id": "a1fb697aca307723", "text": "# Концепции развёртывания { #deployments-concepts }\n\nПри развёртывании приложения **FastAPI** (и вообще любого веб‑API) есть несколько концепций, о которых стоит думать — с их помощью можно выбрать **наиболее подходящий** способ **развёртывания вашего приложения**.\n\nНекоторые из важных концепций:\n\n* Безопасность — HTTPS\n* Запуск при старте\n* Перезапуски\n* Репликация (количество запущенных процессов)\n* Память\n* Предварительные шаги перед запуском\n\nПосмотрим, как они влияют на **развёртывания**.\n\nВ конечном итоге цель — **обслуживать клиентов вашего API** безопасно, **избегать перебоев** и максимально эффективно использовать **вычислительные ресурсы** (например, удалённые серверы/виртуальные машины). \n\nЗдесь я немного расскажу о этих **концепциях**, чтобы у вас появилась **интуиция**, как развёртывать ваш API в разных окружениях, возможно даже в **будущих**, которых ещё не существует.\n\nУчитывая эти концепции, вы сможете **оценить и спроектировать** лучший способ развёртывания **своих API**.\n\nВ следующих главах я дам более **конкретные рецепты** по развёртыванию приложений FastAPI.", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md", "section_header": "Концепции развёртывания", "section_header_level": 1}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 0, "header": "Концепции развёртывания", "header_level": 1, "token_count": 477}
{"id": "15ed491146fcd48d", "text": "** лучший способ развёртывания **своих API**.\n\nВ следующих главах я дам более **конкретные рецепты** по развёртыванию приложений FastAPI.\n\nА пока давайте разберём важные **идеи**. Эти концепции применимы и к другим типам веб‑API.", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md", "section_header": "Концепции развёртывания", "section_header_level": 1}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 1, "header": "Концепции развёртывания", "header_level": 1, "token_count": 107}
{"id": "43bd1295fddc5190", "text": "## Безопасность — HTTPS { #security-https }\n\nВ [предыдущей главе про HTTPS](https.md){.internal-link target=_blank} мы разобрались, как HTTPS обеспечивает шифрование для вашего API.\n\nТакже мы увидели, что HTTPS обычно обеспечивает компонент, **внешний** по отношению к серверу вашего приложения — **TLS Termination Proxy**.\n\nИ должен быть компонент, отвечающий за **обновление HTTPS‑сертификатов** — это может быть тот же самый компонент или отдельный.\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 2, "header": "Безопасность — HTTPS", "header_level": 2, "token_count": 165}
{"id": "6eb24f38b1b90f13", "text": "### Примеры инструментов для HTTPS { #example-tools-for-https }\n\nНекоторые инструменты, которые можно использовать как TLS Termination Proxy:\n\n* Traefik\n    * Автоматически обновляет сертификаты \n* Caddy\n    * Автоматически обновляет сертификаты \n* Nginx\n    * С внешним компонентом (например, Certbot) для обновления сертификатов\n* HAProxy\n    * С внешним компонентом (например, Certbot) для обновления сертификатов\n* Kubernetes с Ingress Controller (например, Nginx)\n    * С внешним компонентом (например, cert-manager) для обновления сертификатов\n* Обрабатывается внутри облачного провайдера как часть его услуг (см. ниже )\n\nДругой вариант — использовать **облачный сервис**, который возьмёт на себя больше задач, включая настройку HTTPS. Там могут быть ограничения или дополнительная стоимость и т.п., но в таком случае вам не придётся самим настраивать TLS Termination Proxy.\n\nВ следующих главах я покажу конкретные примеры.\n\n---\n\nДалее рассмотрим концепции, связанные с программой, которая запускает ваш реальный API (например, Uvicorn).\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 3, "header": "Примеры инструментов для HTTPS", "header_level": 3, "token_count": 404}
{"id": "e2c7c56a10be77eb", "text": "## Программа и процесс { #program-and-process }\n\nМы часто будем говорить о работающем \"**процессе**\", поэтому полезно чётко понимать, что это значит и чем отличается от \"**программы**\".\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 4, "header": "Программа и процесс", "header_level": 2, "token_count": 74}
{"id": "28f2fbb2a69fbdcf", "text": "### Что такое программа { #what-is-a-program }\n\nСловом **программа** обычно называют разные вещи:\n\n* **Код**, который вы пишете, то есть **Python‑файлы**.\n* **Файл**, который может быть **запущен** операционной системой, например: `python`, `python.exe` или `uvicorn`.\n* Конкретную программу в момент, когда она **работает** в операционной системе, используя CPU и память. Это также называют **процессом**.\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 5, "header": "Что такое программа", "header_level": 3, "token_count": 160}
{"id": "a1fb697aca307723", "text": "### Что такое процесс { #what-is-a-process }\n\nСлово **процесс** обычно используют более конкретно — только для того, что реально выполняется в операционной системе (как в последнем пункте выше):\n\n* Конкретная программа в момент, когда она **запущена** в операционной системе.\n    * Речь не о файле и не о коде, а **конкретно** о том, что **исполняется** и управляется операционной системой.\n* Любая программа, любой код **могут что‑то делать** только когда **исполняются**, то есть когда есть **работающий процесс**.\n* Процесс можно **завершить** (или «убить») вами или операционной системой. В этот момент он перестаёт выполняться и **больше ничего делать не может**.\n* У каждого запущенного приложения на вашем компьютере есть свой процесс; у каждой программы, у каждого окна и т.д. Обычно одновременно **работает много процессов**, пока компьютер включён.\n* Могут **одновременно** работать **несколько процессов** одной и той же **программы**.\n\nЕсли вы посмотрите «диспетчер задач» или «системный монитор» (или аналогичные инструменты) в вашей операционной системе, то увидите множество работающих процессов.", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md", "section_header": "Что такое процесс", "section_header_level": 3}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 6, "header": "Что такое процесс", "header_level": 3, "token_count": 449}
{"id": "15ed491146fcd48d", "text": "ите «диспетчер задач» или «системный монитор» (или аналогичные инструменты) в вашей операционной системе, то увидите множество работающих процессов.\n\nНапример, вы, скорее всего, увидите несколько процессов одного и того же браузера (Firefox, Chrome, Edge и т.д.). Обычно браузеры запускают один процесс на вкладку плюс дополнительные процессы.\n\n<img class=\"shadow\" src=\"/img/deployment/concepts/image01.png\">\n\n---\n\nТеперь, когда мы понимаем разницу между **процессом** и **программой**, продолжим разговор о развёртываниях.", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md", "section_header": "Что такое процесс", "section_header_level": 3}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 7, "header": "Что такое процесс", "header_level": 3, "token_count": 219}
{"id": "1f1222594dd7fec4", "text": "## Запуск при старте { #running-on-startup }\n\nВ большинстве случаев, создавая веб‑API, вы хотите, чтобы он **работал постоянно**, без перерывов, чтобы клиенты всегда могли к нему обратиться. Разве что у вас есть особые причины запускать его только при определённых условиях, но обычно вы хотите, чтобы он был постоянно запущен и **доступен**.\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 8, "header": "Запуск при старте", "header_level": 2, "token_count": 138}
{"id": "5ac3090161c3232c", "text": "### На удалённом сервере { #in-a-remote-server }\n\nКогда вы настраиваете удалённый сервер (облачный сервер, виртуальную машину и т.п.), самый простой вариант — вручную использовать `fastapi run` (он использует Uvicorn) или что‑то похожее, как вы делаете при локальной разработке.\n\nЭто будет работать и полезно **во время разработки**.\n\nНо если соединение с сервером прервётся, **запущенный процесс**, скорее всего, завершится.\n\nА если сервер перезагрузится (например, после обновлений или миграций у облачного провайдера), вы, вероятно, **даже не заметите этого**. Из‑за этого вы не узнаете, что нужно вручную перезапустить процесс — и ваш API просто будет «мёртв». \n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 9, "header": "На удалённом сервере", "header_level": 3, "token_count": 263}
{"id": "c372e088fd2affb3", "text": "### Автоматический запуск при старте { #run-automatically-on-startup }\n\nКак правило, вы захотите, чтобы серверная программа (например, Uvicorn) запускалась автоматически при старте сервера и без **участия человека**, чтобы всегда был процесс, запущенный с вашим API (например, Uvicorn, запускающий ваше приложение FastAPI).\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 10, "header": "Автоматический запуск при старте", "header_level": 3, "token_count": 122}
{"id": "37b0cef19e97df0d", "text": "### Отдельная программа { #separate-program }\n\nЧтобы этого добиться, обычно используют **отдельную программу**, которая гарантирует запуск вашего приложения при старте. Во многих случаях она также запускает и другие компоненты/приложения, например базу данных.\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 11, "header": "Отдельная программа", "header_level": 3, "token_count": 97}
{"id": "c4affc1e2d65da6c", "text": "### Примеры инструментов для запуска при старте { #example-tools-to-run-at-startup }\n\nПримеры инструментов, которые могут с этим справиться:\n\n* Docker\n* Kubernetes\n* Docker Compose\n* Docker в режиме Swarm (Swarm Mode)\n* Systemd\n* Supervisor\n* Обработка внутри облачного провайдера как часть его услуг\n* Прочие...\n\nБолее конкретные примеры будут в следующих главах.\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 12, "header": "Примеры инструментов для запуска при старте", "header_level": 3, "token_count": 130}
{"id": "f10fd1ab9d1fd489", "text": "## Перезапуски { #restarts }\n\nПодобно тому как вы обеспечиваете запуск приложения при старте, вы, вероятно, захотите обеспечить его **перезапуск** после сбоев.\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 13, "header": "Перезапуски", "header_level": 2, "token_count": 70}
{"id": "8a1aa248983222ba", "text": "### Мы ошибаемся { #we-make-mistakes }\n\nМы, люди, постоянно совершаем **ошибки**. В программном обеспечении почти всегда есть **баги**, скрытые в разных местах. \n\nИ мы, как разработчики, продолжаем улучшать код — находим баги и добавляем новые возможности (иногда добавляя новые баги ).\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 14, "header": "Мы ошибаемся", "header_level": 3, "token_count": 116}
{"id": "8ce0f070ae5688a7", "text": "### Небольшие ошибки обрабатываются автоматически { #small-errors-automatically-handled }\n\nСоздавая веб‑API с FastAPI, если в нашем коде возникает ошибка, FastAPI обычно «локализует» её в пределах одного запроса, который эту ошибку вызвал. \n\nКлиент получит **500 Internal Server Error** для этого запроса, но приложение продолжит работать для последующих запросов, а не «упадёт» целиком.\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 15, "header": "Небольшие ошибки обрабатываются автоматически", "header_level": 3, "token_count": 137}
{"id": "4f71ac101b7ad9b8", "text": "### Большие ошибки — падения { #bigger-errors-crashes }\n\nТем не менее возможны случаи, когда код **роняет всё приложение**, приводя к сбою Uvicorn и Python. \n\nИ вы, скорее всего, не захотите, чтобы приложение оставалось «мёртвым» из‑за ошибки в одном месте — вы захотите, чтобы оно **продолжало работать** хотя бы для *операций пути*, которые не сломаны.\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 16, "header": "Большие ошибки — падения", "header_level": 3, "token_count": 148}
{"id": "8c7cf86776d71bab", "text": "### Перезапуск после падения { #restart-after-crash }\n\nВ случаях действительно серьёзных ошибок, которые роняют работающий **процесс**, вам понадобится внешний компонент, отвечающий за **перезапуск** процесса, как минимум пару раз...\n\n/// tip | Совет\n\n...Хотя если приложение **падает сразу же**, вероятно, нет смысла перезапускать его бесконечно. Но такие случаи вы, скорее всего, заметите во время разработки или как минимум сразу после развёртывания.\n\nДавайте сосредоточимся на основных сценариях, когда в каких‑то конкретных ситуациях **в будущем** приложение может падать целиком, и при этом имеет смысл его перезапускать.\n\n///\n\nСкорее всего, вы захотите, чтобы перезапуском вашего приложения занимался **внешний компонент**, потому что к тому моменту Uvicorn и Python уже упали, и внутри того же кода вашего приложения сделать уже ничего нельзя.\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 17, "header": "Перезапуск после падения", "header_level": 3, "token_count": 356}
{"id": "6efa1cb102e0e810", "text": "### Примеры инструментов для автоматического перезапуска { #example-tools-to-restart-automatically }\n\nВ большинстве случаев тот же инструмент, который **запускает программу при старте**, умеет обрабатывать и автоматические **перезапуски**.\n\nНапример, это может быть:\n\n* Docker\n* Kubernetes\n* Docker Compose\n* Docker в режиме Swarm (Swarm Mode)\n* Systemd\n* Supervisor\n* Обработка внутри облачного провайдера как часть его услуг\n* Прочие...\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 18, "header": "Примеры инструментов для автоматического перезапуска", "header_level": 3, "token_count": 158}
{"id": "1c3bcf77211b3b01", "text": "## Репликация — процессы и память { #replication-processes-and-memory }\n\nВ приложении FastAPI, используя серверную программу (например, команду `fastapi`, которая запускает Uvicorn), запуск в **одном процессе** уже позволяет обслуживать нескольких клиентов одновременно.\n\nНо во многих случаях вы захотите одновременно запустить несколько процессов‑воркеров.\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 19, "header": "Репликация — процессы и память", "header_level": 2, "token_count": 135}
{"id": "6a62839db4b67c9f", "text": "### Несколько процессов — Воркеры { #multiple-processes-workers }\n\nЕсли клиентов больше, чем способен обслужить один процесс (например, если виртуальная машина не слишком мощная), и на сервере есть **несколько ядер CPU**, вы можете запустить **несколько процессов** одного и того же приложения параллельно и распределять запросы между ними.\n\nКогда вы запускаете **несколько процессов** одной и той же программы API, их обычно называют **воркерами**.\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 20, "header": "Несколько процессов — Воркеры", "header_level": 3, "token_count": 182}
{"id": "4ec178d830c37e7e", "text": "### Процессы‑воркеры и порты { #worker-processes-and-ports }\n\nПомните из раздела [Об HTTPS](https.md){.internal-link target=_blank}, что на сервере только один процесс может слушать конкретную комбинацию порта и IP‑адреса?\n\nЭто по‑прежнему так.\n\nПоэтому, чтобы одновременно работало **несколько процессов**, должен быть **один процесс, слушающий порт**, который затем каким‑то образом передаёт коммуникацию каждому воркер‑процессу.\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 21, "header": "Процессы‑воркеры и порты", "header_level": 3, "token_count": 172}
{"id": "30f4fb0c618d4e72", "text": "### Память на процесс { #memory-per-process }\n\nКогда программа загружает что‑то в память (например, модель машинного обучения в переменную или содержимое большого файла в переменную), всё это **потребляет часть памяти (RAM)** сервера.\n\nИ разные процессы обычно **не делят память**. Это значит, что у каждого процесса свои переменные и своя память. Если ваш код потребляет много памяти, то **каждый процесс** будет потреблять сопоставимый объём памяти.\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 22, "header": "Память на процесс", "header_level": 3, "token_count": 173}
{"id": "f313b67c6a076ea0", "text": "### Память сервера { #server-memory }\n\nНапример, если ваш код загружает модель Машинного обучения размером **1 ГБ**, то при запуске одного процесса с вашим API он будет использовать как минимум 1 ГБ RAM. А если вы запустите **4 процесса** (4 воркера), каждый процесс будет использовать 1 ГБ RAM. Всего ваш API будет потреблять **4 ГБ RAM**.\n\nИ если у вашего удалённого сервера или виртуальной машины только 3 ГБ RAM, попытка загрузить более 4 ГБ вызовет проблемы. \n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 23, "header": "Память сервера", "header_level": 3, "token_count": 172}
{"id": "6381fa46948afd4b", "text": "### Несколько процессов — пример { #multiple-processes-an-example }\n\nВ этом примере есть **процесс‑менеджер**, который запускает и контролирует два **процесса‑воркера**.\n\nПроцесс‑менеджер, вероятно, будет тем, кто слушает **порт** на IP. И он будет передавать всю коммуникацию воркер‑процессам.\n\nЭти воркеры будут запускать ваше приложение, выполнять основные вычисления для получения **запроса** и возврата **ответа**, и загружать всё, что вы кладёте в переменные, в RAM.\n\n<img src=\"/img/deployment/concepts/process-ram.drawio.svg\">\n\nКонечно, на той же машине помимо вашего приложения, скорее всего, будут работать и **другие процессы**.\n\nИнтересная деталь: процент **использования CPU** каждым процессом со временем может сильно **меняться**, но **память (RAM)** обычно остаётся более‑менее **стабильной**.\n\nЕсли у вас API, который каждый раз выполняет сопоставимый объём вычислений, и у вас много клиентов, то **загрузка процессора**, вероятно, *тоже будет стабильной* (вместо того, чтобы быстро и постоянно «скакать»).\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 24, "header": "Несколько процессов — пример", "header_level": 3, "token_count": 417}
{"id": "a1fb697aca307723", "text": "### Примеры инструментов и стратегий репликации { #examples-of-replication-tools-and-strategies }\n\nЕсть несколько подходов для достижения этого, и я расскажу больше о конкретных стратегиях в следующих главах, например, говоря о Docker и контейнерах.\n\nГлавное ограничение: должен быть **один** компонент, который обрабатывает **порт** на **публичном IP**. И у него должен быть способ **передавать** коммуникацию реплицированным **процессам/воркерам**.\n\nНекоторые возможные комбинации и стратегии:\n\n* **Uvicorn** с `--workers`\n    * Один **процесс‑менеджер** Uvicorn будет слушать **IP** и **порт** и запускать **несколько процессов‑воркеров Uvicorn**.\n* **Kubernetes** и другие распределённые **контейнерные системы**\n    * Некий компонент на уровне **Kubernetes** будет слушать **IP** и **порт**. Репликация достигается с помощью **нескольких контейнеров**, в каждом из которых работает **один процесс Uvicorn**.\n* **Облачные сервисы**, которые берут это на себя\n    * Облачный сервис, скорее всего, **возьмёт репликацию на себя**. Он, возможно, позволит указать **процесс для запуска** или **образ контейнера**. В любом случае это, скорее всего, будет **один процесс Uvicorn**, а сервис займётся его репликацией.\n\n/// tip | Совет", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md", "section_header": "Примеры инструментов и стратегий репликации", "section_header_level": 3}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 25, "header": "Примеры инструментов и стратегий репликации", "header_level": 3, "token_count": 503}
{"id": "15ed491146fcd48d", "text": "уска** или **образ контейнера**. В любом случае это, скорее всего, будет **один процесс Uvicorn**, а сервис займётся его репликацией.\n\n/// tip | Совет\n\nНе беспокойтесь, если некоторые пункты про **контейнеры**, Docker или Kubernetes пока кажутся неочевидными.\n\nЯ расскажу больше про образы контейнеров, Docker, Kubernetes и т.п. в следующей главе: [FastAPI внутри контейнеров — Docker](docker.md){.internal-link target=_blank}.\n\n///", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md", "section_header": "Примеры инструментов и стратегий репликации", "section_header_level": 3}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 26, "header": "Примеры инструментов и стратегий репликации", "header_level": 3, "token_count": 167}
{"id": "15bb5d8b99a113fe", "text": "## Предварительные шаги перед запуском { #previous-steps-before-starting }\n\nВо многих случаях вы захотите выполнить некоторые шаги **перед запуском** приложения.\n\nНапример, запустить **миграции базы данных**.\n\nНо чаще всего эти шаги нужно выполнять только **один раз**.\n\nПоэтому вы захотите иметь **один процесс**, который выполнит эти **предварительные шаги**, прежде чем запускать приложение.\n\nИ вам нужно будет убедиться, что это делает один процесс **даже** если потом вы запускаете **несколько процессов** (несколько воркеров) самого приложения. Если эти шаги выполнят **несколько процессов**, они **дублируют** работу, запустив её **параллельно**, и, если речь о чём‑то деликатном (например, миграции БД), это может вызвать конфликты.\n\nКонечно, бывают случаи, когда нет проблем, если предварительные шаги выполняются несколько раз — тогда всё проще.\n\n/// tip | Совет\n\nТакже учтите, что в зависимости от вашей схемы развёртывания в некоторых случаях **предварительные шаги могут вовсе не требоваться**.\n\nТогда об этом можно не беспокоиться. \n\n///\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 27, "header": "Предварительные шаги перед запуском", "header_level": 2, "token_count": 435}
{"id": "ad387217b3164bcb", "text": "### Примеры стратегий для предварительных шагов { #examples-of-previous-steps-strategies }\n\nЭто будет **сильно зависеть** от того, как вы **развёртываете систему**, как запускаете программы, обрабатываете перезапуски и т.д.\n\nНекоторые возможные идеи:\n\n* «Init Container» в Kubernetes, который запускается перед контейнером с приложением\n* Bash‑скрипт, который выполняет предварительные шаги, а затем запускает приложение\n    * При этом всё равно нужен способ запускать/перезапускать *этот* bash‑скрипт, обнаруживать ошибки и т.п.\n\n/// tip | Совет\n\nЯ приведу более конкретные примеры с контейнерами в следующей главе: [FastAPI внутри контейнеров — Docker](docker.md){.internal-link target=_blank}.\n\n///\n\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 28, "header": "Примеры стратегий для предварительных шагов", "header_level": 3, "token_count": 270}
{"id": "a1fb697aca307723", "text": "## Использование ресурсов { #resource-utilization }\n\nВаш сервер(а) — это **ресурс**, который ваши программы могут потреблять или **использовать**: время вычислений на CPU и доступную оперативную память (RAM).\n\nКакую долю системных ресурсов вы хотите потреблять/использовать? Можно подумать «немного», но на практике вы, скорее всего, захотите потреблять **максимум без падений**.\n\nЕсли вы платите за 3 сервера, но используете лишь малую часть их RAM и CPU, вы, вероятно, **тратите деньги впустую**  и **электроэнергию серверов**  и т.п.\n\nВ таком случае лучше иметь 2 сервера и использовать более высокий процент их ресурсов (CPU, память, диск, сетевую полосу и т.д.).\n\nС другой стороны, если у вас 2 сервера и вы используете **100% их CPU и RAM**, в какой‑то момент один процесс попросит больше памяти, и сервер начнёт использовать диск как «память» (что в тысячи раз медленнее) или даже **упадёт**. Или процессу понадобятся вычисления, но ему придётся ждать освобождения CPU.\n\nВ таком случае лучше добавить **ещё один сервер** и запустить часть процессов на нём, чтобы у всех было **достаточно RAM и времени CPU**.", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md", "section_header": "Использование ресурсов", "section_header_level": 2}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 29, "header": "Использование ресурсов", "header_level": 2, "token_count": 463}
{"id": "15ed491146fcd48d", "text": "ся ждать освобождения CPU.\n\nВ таком случае лучше добавить **ещё один сервер** и запустить часть процессов на нём, чтобы у всех было **достаточно RAM и времени CPU**.\n\nТакже возможен **всплеск** использования вашего API: он мог «взорваться» по популярности, или какие‑то сервисы/боты начали его активно использовать. На такие случаи стоит иметь запас ресурсов.\n\nМожно задать **целевое значение**, например **между 50% и 90%** использования ресурсов. Скорее всего, именно эти вещи вы будете измерять и на их основе настраивать развёртывание.\n\nМожно использовать простые инструменты вроде `htop`, чтобы смотреть загрузку CPU и RAM на сервере или по процессам. Или более сложные распределённые системы мониторинга.", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md", "section_header": "Использование ресурсов", "section_header_level": 2}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 30, "header": "Использование ресурсов", "header_level": 2, "token_count": 285}
{"id": "82a5ee5bfcd3aee5", "text": "## Резюме { #recap }\n\nЗдесь вы прочитали о некоторых основных концепциях, которые, вероятно, стоит учитывать при выборе способа развёртывания приложения:\n\n* Безопасность — HTTPS\n* Запуск при старте\n* Перезапуски\n* Репликация (количество запущенных процессов)\n* Память\n* Предварительные шаги перед запуском\n\nПонимание этих идей и того, как их применять, даст вам интуицию, необходимую для принятия решений при настройке и доработке ваших развёртываний. \n\nВ следующих разделах я приведу более конкретные примеры возможных стратегий.\n", "metadata": {"title": "Концепции развёртывания", "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "source_mtime": "2026-01-12T17:48:13.140112+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\concepts.md"}, "doc_id": "c16adf89f515", "source_path": "docs\\deployment\\concepts.md", "title": "Концепции развёртывания", "chunk_index": 31, "header": "Резюме", "header_level": 2, "token_count": 232}
{"id": "605fa00c1ed16c08", "text": "# FastAPI в контейнерах — Docker { #fastapi-in-containers-docker }\n\nПри развёртывании приложений FastAPI распространённый подход — собирать **образ контейнера на Linux**. Обычно это делают с помощью <a href=\"https://www.docker.com/\" class=\"external-link\" target=\"_blank\">**Docker**</a>. Затем такой образ контейнера можно развернуть несколькими способами.\n\nИспользование Linux-контейнеров даёт ряд преимуществ: **безопасность**, **воспроизводимость**, **простоту** и другие.\n\n/// tip | Подсказка\n\nНет времени и вы уже знакомы с этим? Перейдите к [`Dockerfile` ниже ](#build-a-docker-image-for-fastapi).\n\n///\n\n<details>\n<summary>Предпросмотр Dockerfile 👀</summary>\n\n```Dockerfile\nFROM python:3.9\n\nWORKDIR /code\n\nCOPY ./requirements.txt /code/requirements.txt\n\nRUN pip install --no-cache-dir --upgrade -r /code/requirements.txt\n\nCOPY ./app /code/app\n\nCMD [\"fastapi\", \"run\", \"app/main.py\", \"--port\", \"80\"]\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 0, "header": "FastAPI в контейнерах — Docker", "header_level": 1, "token_count": 317}
{"id": "0da58613dc5e4ba7", "text": "# Если запускаете за прокси, например Nginx или Traefik, добавьте --proxy-headers\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 1, "header": "Если запускаете за прокси, например Nginx или Traefik, добавьте --proxy-headers", "header_level": 1, "token_count": 32}
{"id": "e548999b51d8e52b", "text": "# CMD [\"fastapi\", \"run\", \"app/main.py\", \"--port\", \"80\", \"--proxy-headers\"]\n```\n\n</details>\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 2, "header": "CMD [\"fastapi\", \"run\", \"app/main.py\", \"--port\", \"80\", \"--proxy-headers\"]", "header_level": 1, "token_count": 30}
{"id": "694d0e3335029f76", "text": "## Что такое контейнер { #what-is-a-container }\n\nКонтейнеры (в основном Linux-контейнеры) — это очень **легковесный** способ упаковать приложения вместе со всеми их зависимостями и необходимыми файлами, изолировав их от других контейнеров (других приложений или компонентов) в той же системе.\n\nLinux-контейнеры запускаются, используя то же ядро Linux хоста (машины, виртуальной машины, облачного сервера и т.п.). Это означает, что они очень легковесные (по сравнению с полноценными виртуальными машинами, эмулирующими целую операционную систему).\n\nТаким образом, контейнеры потребляют **малое количество ресурсов**, сопоставимое с запуском процессов напрямую (виртуальная машина потребовала бы намного больше ресурсов).\n\nУ контейнеров также есть собственные **изолированные** выполняемые процессы (обычно всего один процесс), файловая система и сеть, что упрощает развёртывание, безопасность, разработку и т.д.\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 3, "header": "Что такое контейнер", "header_level": 2, "token_count": 384}
{"id": "18824cdd08d67f0a", "text": "## Что такое образ контейнера { #what-is-a-container-image }\n\n**Контейнер** запускается из **образа контейнера**.\n\nОбраз контейнера — это **статическая** версия всех файлов, переменных окружения и команды/программы по умолчанию, которые должны присутствовать в контейнере. Здесь **статическая** означает, что **образ** не запущен, он не выполняется — это только упакованные файлы и метаданные.\n\nВ противоположность «**образу контейнера**» (хранящему статическое содержимое), «**контейнер**» обычно означает запущенный экземпляр, то, что **выполняется**.\n\nКогда **контейнер** запущен (на основе **образа контейнера**), он может создавать или изменять файлы, переменные окружения и т.д.. Эти изменения существуют только внутри контейнера и не сохраняются в исходном образе контейнера (не записываются на диск).\n\nОбраз контейнера можно сравнить с **файлами программы**, например `python` и каким-то файлом `main.py`.\n\nА сам **контейнер** (в отличие от **образа контейнера**) — это фактически запущенный экземпляр образа, сопоставимый с **процессом**. По сути, контейнер работает только тогда, когда в нём есть **запущенный процесс** (и обычно это один процесс). Контейнер останавливается, когда в нём не остаётся запущенных процессов.\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 4, "header": "Что такое образ контейнера", "header_level": 2, "token_count": 505}
{"id": "605fa00c1ed16c08", "text": "## Образы контейнеров { #container-images }\n\nDocker — один из основных инструментов для создания и управления **образами контейнеров** и **контейнерами**.\n\nСуществует публичный <a href=\"https://hub.docker.com/\" class=\"external-link\" target=\"_blank\">Docker Hub</a> с готовыми **официальными образами** для многих инструментов, окружений, баз данных и приложений.\n\nНапример, есть официальный <a href=\"https://hub.docker.com/_/python\" class=\"external-link\" target=\"_blank\">образ Python</a>.\n\nА также множество образов для разных вещей, например баз данных:\n\n* <a href=\"https://hub.docker.com/_/postgres\" class=\"external-link\" target=\"_blank\">PostgreSQL</a>\n* <a href=\"https://hub.docker.com/_/mysql\" class=\"external-link\" target=\"_blank\">MySQL</a>\n* <a href=\"https://hub.docker.com/_/mongo\" class=\"external-link\" target=\"_blank\">MongoDB</a>\n* <a href=\"https://hub.docker.com/_/redis\" class=\"external-link\" target=\"_blank\">Redis</a>, и т.д.\n\nИспользуя готовые образы, очень легко **комбинировать** разные инструменты и использовать их. Например, чтобы попробовать новую базу данных. В большинстве случаев можно воспользоваться **официальными образами** и просто настроить их через переменные окружения.\n\nТаким образом, во многих случаях вы можете изучить контейнеры и Docker и переиспользовать эти знания с множеством различных инструментов и компонентов.", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md", "section_header": "Образы контейнеров", "section_header_level": 2}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 5, "header": "Образы контейнеров", "header_level": 2, "token_count": 470}
{"id": "0da58613dc5e4ba7", "text": "жения.\n\nТаким образом, во многих случаях вы можете изучить контейнеры и Docker и переиспользовать эти знания с множеством различных инструментов и компонентов.\n\nНапример, вы можете запустить **несколько контейнеров**: с базой данных, Python-приложением, веб-сервером с фронтендом на React и связать их через внутреннюю сеть.\n\nВсе системы управления контейнерами (такие как Docker или Kubernetes) имеют интегрированные возможности для такого сетевого взаимодействия.", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md", "section_header": "Образы контейнеров", "section_header_level": 2}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 6, "header": "Образы контейнеров", "header_level": 2, "token_count": 185}
{"id": "d130506e06f3fa23", "text": "## Контейнеры и процессы { #containers-and-processes }\n\n**Образ контейнера** обычно включает в свои метаданные программу или команду по умолчанию, которую следует запускать при старте **контейнера**, а также параметры, передаваемые этой программе. Это очень похоже на запуск команды в терминале.\n\nКогда **контейнер** стартует, он выполняет указанную команду/программу (хотя вы можете переопределить это и запустить другую команду/программу).\n\nКонтейнер работает до тех пор, пока работает его **главный процесс** (команда или программа).\n\nОбычно в контейнере есть **один процесс**, но главный процесс может запускать подпроцессы, и тогда в том же контейнере будет **несколько процессов**.\n\nНельзя иметь работающий контейнер без **хотя бы одного запущенного процесса**. Если главный процесс останавливается, контейнер останавливается.\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 7, "header": "Контейнеры и процессы", "header_level": 2, "token_count": 330}
{"id": "e15c8b1a1b5bd3bc", "text": "## Создать Docker-образ для FastAPI { #build-a-docker-image-for-fastapi }\n\nИтак, давайте что-нибудь соберём! \n\nЯ покажу, как собрать **Docker-образ** для FastAPI **с нуля** на основе **официального образа Python**.\n\nИменно так стоит делать в **большинстве случаев**, например:\n\n* При использовании **Kubernetes** или похожих инструментов\n* При запуске на **Raspberry Pi**\n* При использовании облачного сервиса, который запускает для вас образ контейнера и т.п.\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 8, "header": "Создать Docker-образ для FastAPI", "header_level": 2, "token_count": 178}
{"id": "d5caf8b66bd37594", "text": "### Зависимости пакетов { #package-requirements }\n\nОбычно **зависимости** вашего приложения описаны в каком-то файле.\n\nКонкретный формат зависит в основном от инструмента, которым вы **устанавливаете** эти зависимости.\n\nЧаще всего используется файл `requirements.txt` с именами пакетов и их версиями по одному на строку.\n\nРазумеется, вы будете придерживаться тех же идей, что описаны здесь: [О версиях FastAPI](versions.md){.internal-link target=_blank}, чтобы задать диапазоны версий.\n\nНапример, ваш `requirements.txt` может выглядеть так:\n\n```\nfastapi[standard]>=0.113.0,<0.114.0\npydantic>=2.7.0,<3.0.0\n```\n\nИ обычно вы установите эти зависимости командой `pip`, например:\n\n<div class=\"termy\">\n\n```console\n$ pip install -r requirements.txt\n---> 100%\nSuccessfully installed fastapi pydantic\n```\n\n</div>\n\n/// info | Информация\n\nСуществуют и другие форматы и инструменты для описания и установки зависимостей.\n\n///\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 9, "header": "Зависимости пакетов", "header_level": 3, "token_count": 341}
{"id": "ec3852f5eecef381", "text": "### Создать код **FastAPI** { #create-the-fastapi-code }\n\n* Создайте директорию `app` и перейдите в неё.\n* Создайте пустой файл `__init__.py`.\n* Создайте файл `main.py` со следующим содержимым:\n\n```Python\nfrom typing import Union\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: Union[str, None] = None):\n    return {\"item_id\": item_id, \"q\": q}\n```\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 10, "header": "Создать код **FastAPI**", "header_level": 3, "token_count": 148}
{"id": "71001f398b218d38", "text": "### Dockerfile { #dockerfile }\n\nТеперь в той же директории проекта создайте файл `Dockerfile`:\n\n```{ .dockerfile .annotate }\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 11, "header": "Dockerfile", "header_level": 3, "token_count": 43}
{"id": "9d63083f7c1475a8", "text": "# (1)!\nFROM python:3.9\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 12, "header": "(1)!", "header_level": 1, "token_count": 11}
{"id": "973f78577046f488", "text": "# (2)!\nWORKDIR /code\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 13, "header": "(2)!", "header_level": 1, "token_count": 9}
{"id": "e70f060874054d97", "text": "# (3)!\nCOPY ./requirements.txt /code/requirements.txt\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 14, "header": "(3)!", "header_level": 1, "token_count": 14}
{"id": "a56b850d5c730361", "text": "# (4)!\nRUN pip install --no-cache-dir --upgrade -r /code/requirements.txt\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 15, "header": "(4)!", "header_level": 1, "token_count": 21}
{"id": "8499238608364905", "text": "# (5)!\nCOPY ./app /code/app\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 16, "header": "(5)!", "header_level": 1, "token_count": 11}
{"id": "605fa00c1ed16c08", "text": "# (6)!\nCMD [\"fastapi\", \"run\", \"app/main.py\", \"--port\", \"80\"]\n```\n\n1. Начинаем с официального базового образа Python.\n\n2. Устанавливаем текущую рабочую директорию в `/code`.\n\n    Здесь мы разместим файл `requirements.txt` и директорию `app`.\n\n3. Копируем файл с зависимостями в директорию `/code`.\n\n    Сначала копируйте **только** файл с зависимостями, не остальной код.\n\n    Так как этот файл **меняется нечасто**, Docker определит это и использует **кэш** на этом шаге, что позволит использовать кэш и на следующем шаге.\n\n4. Устанавливаем зависимости из файла с требованиями.\n\n    Опция `--no-cache-dir` указывает `pip` не сохранять загруженные пакеты локально, т.к. это нужно только если `pip` будет запускаться снова для установки тех же пакетов, а при работе с контейнерами это обычно не требуется.\n\n    /// note | Заметка\n\n    `--no-cache-dir` относится только к `pip` и не имеет отношения к Docker или контейнерам.\n\n    ///\n\n    Опция `--upgrade` указывает `pip` обновлять пакеты, если они уже установлены.\n\n    Поскольку предыдущий шаг с копированием файла может быть обработан **кэшем Docker**, этот шаг также **использует кэш Docker**, когда это возможно.", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md", "section_header": "(6)!", "section_header_level": 1}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 17, "header": "(6)!", "header_level": 1, "token_count": 446}
{"id": "0da58613dc5e4ba7", "text": "они уже установлены.\n\n    Поскольку предыдущий шаг с копированием файла может быть обработан **кэшем Docker**, этот шаг также **использует кэш Docker**, когда это возможно.\n\n    Использование кэша на этом шаге **сэкономит** вам много **времени** при повторных сборках образа во время разработки, вместо того чтобы **загружать и устанавливать** все зависимости **каждый раз**.\n\n5. Копируем директорию `./app` внутрь директории `/code`.\n\n    Так как здесь весь код, который **меняется чаще всего**, кэш Docker **вряд ли** будет использоваться для этого шагa или **последующих шагов**.\n\n    Поэтому важно разместить этот шаг **ближе к концу** `Dockerfile`, чтобы оптимизировать время сборки образа контейнера.\n\n6. Указываем **команду** для запуска `fastapi run`, под капотом используется Uvicorn.\n\n    `CMD` принимает список строк, каждая из которых — это то, что вы бы ввели в командной строке, разделяя пробелами.\n\n    Эта команда будет выполнена из **текущей рабочей директории**, той самой `/code`, которую вы задали выше `WORKDIR /code`.\n\n/// tip | Подсказка\n\nПосмотрите, что делает каждая строка, кликнув по номеру рядом со строкой. \n\n///\n\n/// warning | Предупреждение\n\nВсегда используйте **exec-форму** инструкции `CMD`, как описано ниже.\n\n///\n\n#### Используйте `CMD` — exec-форма { #use-cmd-exec-form }", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md", "section_header": "(6)!", "section_header_level": 1}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 18, "header": "(6)!", "header_level": 1, "token_count": 504}
{"id": "e548999b51d8e52b", "text": "///\n\n/// warning | Предупреждение\n\nВсегда используйте **exec-форму** инструкции `CMD`, как описано ниже.\n\n///\n\n#### Используйте `CMD` — exec-форма { #use-cmd-exec-form }\n\nИнструкцию Docker <a href=\"https://docs.docker.com/reference/dockerfile/#cmd\" class=\"external-link\" target=\"_blank\">`CMD`</a> можно писать в двух формах:\n\n **Exec**-форма:\n\n```Dockerfile", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md", "section_header": "(6)!", "section_header_level": 1}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 19, "header": "(6)!", "header_level": 1, "token_count": 122}
{"id": "941bdaa05b06ec67", "text": "# ✅ Делайте так\nCMD [\"fastapi\", \"run\", \"app/main.py\", \"--port\", \"80\"]\n```\n\n **Shell**-форма:\n\n```Dockerfile\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 20, "header": "✅ Делайте так", "header_level": 1, "token_count": 42}
{"id": "605fa00c1ed16c08", "text": "# ⛔️ Не делайте так\nCMD fastapi run app/main.py --port 80\n```\n\nОбязательно используйте **exec**-форму, чтобы FastAPI мог корректно завершаться и чтобы срабатывали [события lifespan](../advanced/events.md){.internal-link target=_blank}.\n\nПодробнее об этом читайте в <a href=\"https://docs.docker.com/reference/dockerfile/#shell-and-exec-form\" class=\"external-link\" target=\"_blank\">документации Docker о shell- и exec-формах</a>.\n\nЭто особенно заметно при использовании `docker compose`. См. раздел FAQ Docker Compose с техническими подробностями: <a href=\"https://docs.docker.com/compose/faq/#why-do-my-services-take-10-seconds-to-recreate-or-stop\" class=\"external-link\" target=\"_blank\">Почему мои сервисы пересоздаются или останавливаются 10 секунд?</a>.\n\n#### Структура директорий { #directory-structure }\n\nТеперь у вас должна быть такая структура:\n\n```\n.\n├── app\n│   ├── __init__.py\n│   └── main.py\n├── Dockerfile\n└── requirements.txt\n```\n\n#### За прокси-сервером TLS терминации { #behind-a-tls-termination-proxy }\n\nЕсли вы запускаете контейнер за прокси-сервером завершения TLS (балансировщиком нагрузки), таким как Nginx или Traefik, добавьте опцию `--proxy-headers`. Это сообщит Uvicorn (через FastAPI CLI), что приложение работает за HTTPS и можно доверять соответствующим заголовкам.\n\n```Dockerfile\nCMD [\"fastapi\", \"run\", \"app/main.py\", \"--proxy-headers\", \"--port\", \"80\"]\n```\n\n#### Кэш Docker { #docker-cache }", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md", "section_header": "⛔️ Не делайте так", "section_header_level": 1}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 21, "header": "⛔️ Не делайте так", "header_level": 1, "token_count": 500}
{"id": "0da58613dc5e4ba7", "text": "ложение работает за HTTPS и можно доверять соответствующим заголовкам.\n\n```Dockerfile\nCMD [\"fastapi\", \"run\", \"app/main.py\", \"--proxy-headers\", \"--port\", \"80\"]\n```\n\n#### Кэш Docker { #docker-cache }\n\nВ этом `Dockerfile` есть важная хитрость: мы сначала копируем **только файл с зависимостями**, а не весь код. Вот зачем.\n\n```Dockerfile\nCOPY ./requirements.txt /code/requirements.txt\n```\n\nDocker и подобные инструменты **строят** образы контейнеров **инкрементально**, добавляя **слой за слоем**, начиная с первой строки `Dockerfile` и добавляя любые файлы, создаваемые каждой инструкцией `Dockerfile`.\n\nDocker и подобные инструменты также используют **внутренний кэш** при сборке образа: если файл не изменился с момента предыдущей сборки, будет **переиспользован слой**, созданный в прошлый раз, вместо повторного копирования файла и создания нового слоя с нуля.\n\nСамо по себе избегание копирования всех файлов не всегда даёт много, но благодаря использованию кэша на этом шаге Docker сможет **использовать кэш и на следующем шаге**. Например, на шаге установки зависимостей:\n\n```Dockerfile\nRUN pip install --no-cache-dir --upgrade -r /code/requirements.txt\n```\n\nФайл с зависимостями **меняется нечасто**. Поэтому, копируя только его, Docker сможет **использовать кэш** для этого шага.", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md", "section_header": "⛔️ Не делайте так", "section_header_level": 1}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 22, "header": "⛔️ Не делайте так", "header_level": 1, "token_count": 481}
{"id": "e548999b51d8e52b", "text": "-r /code/requirements.txt\n```\n\nФайл с зависимостями **меняется нечасто**. Поэтому, копируя только его, Docker сможет **использовать кэш** для этого шага.\n\nА затем Docker сможет **использовать кэш и на следующем шаге**, где скачиваются и устанавливаются зависимости. Здесь мы как раз **экономим много времени**.  ...и не скучаем в ожидании. \n\nСкачивание и установка зависимостей **может занять минуты**, но использование **кэша** — **секунды**.\n\nПоскольку во время разработки вы будете пересобирать образ снова и снова, чтобы проверить изменения в коде, суммарно это сэкономит немало времени.\n\nЗатем, ближе к концу `Dockerfile`, мы копируем весь код. Так как он **меняется чаще всего**, мы ставим этот шаг в конец, потому что почти всегда всё, что после него, уже не сможет использовать кэш.\n\n```Dockerfile\nCOPY ./app /code/app\n```", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md", "section_header": "⛔️ Не делайте так", "section_header_level": 1}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 23, "header": "⛔️ Не делайте так", "header_level": 1, "token_count": 339}
{"id": "0fb2e508e6f0eed7", "text": "### Собрать Docker-образ { #build-the-docker-image }\n\nТеперь, когда все файлы на месте, соберём образ контейнера.\n\n* Перейдите в директорию проекта (где ваш `Dockerfile` и директория `app`).\n* Соберите образ FastAPI:\n\n<div class=\"termy\">\n\n```console\n$ docker build -t myimage .\n\n---> 100%\n```\n\n</div>\n\n/// tip | Подсказка\n\nОбратите внимание на точку `.` в конце — это то же самое, что `./`. Так мы указываем Docker, из какой директории собирать образ контейнера.\n\nВ данном случае это текущая директория (`.`).\n\n///\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 24, "header": "Собрать Docker-образ", "header_level": 3, "token_count": 198}
{"id": "ebc18b1ecf7c2b58", "text": "### Запустить Docker-контейнер { #start-the-docker-container }\n\n* Запустите контейнер на основе вашего образа:\n\n<div class=\"termy\">\n\n```console\n$ docker run -d --name mycontainer -p 80:80 myimage\n```\n\n</div>\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 25, "header": "Запустить Docker-контейнер", "header_level": 3, "token_count": 71}
{"id": "66a923eff7c5339f", "text": "## Проверка { #check-it }\n\nПроверьте работу по адресу вашего Docker-хоста, например: <a href=\"http://192.168.99.100/items/5?q=somequery\" class=\"external-link\" target=\"_blank\">http://192.168.99.100/items/5?q=somequery</a> или <a href=\"http://127.0.0.1/items/5?q=somequery\" class=\"external-link\" target=\"_blank\">http://127.0.0.1/items/5?q=somequery</a> (или аналогичный URL вашего Docker-хоста).\n\nВы увидите что-то вроде:\n\n```JSON\n{\"item_id\": 5, \"q\": \"somequery\"}\n```\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 26, "header": "Проверка", "header_level": 2, "token_count": 179}
{"id": "2e2c29fc446c06b7", "text": "## Интерактивная документация API { #interactive-api-docs }\n\nТеперь зайдите на <a href=\"http://192.168.99.100/docs\" class=\"external-link\" target=\"_blank\">http://192.168.99.100/docs</a> или <a href=\"http://127.0.0.1/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1/docs</a> (или аналогичный URL вашего Docker-хоста).\n\nВы увидите автоматическую интерактивную документацию API (на базе <a href=\"https://github.com/swagger-api/swagger-ui\" class=\"external-link\" target=\"_blank\">Swagger UI</a>):\n\n![Swagger UI](https://fastapi.tiangolo.com/img/index/index-01-swagger-ui-simple.png)\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 27, "header": "Интерактивная документация API", "header_level": 2, "token_count": 194}
{"id": "a63382c24b3f7330", "text": "## Альтернативная документация API { #alternative-api-docs }\n\nТакже можно открыть <a href=\"http://192.168.99.100/redoc\" class=\"external-link\" target=\"_blank\">http://192.168.99.100/redoc</a> или <a href=\"http://127.0.0.1/redoc\" class=\"external-link\" target=\"_blank\">http://127.0.0.1/redoc</a> (или аналогичный URL вашего Docker-хоста).\n\nВы увидите альтернативную автоматическую документацию (на базе <a href=\"https://github.com/Rebilly/ReDoc\" class=\"external-link\" target=\"_blank\">ReDoc</a>):\n\n![ReDoc](https://fastapi.tiangolo.com/img/index/index-02-redoc-simple.png)\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 28, "header": "Альтернативная документация API", "header_level": 2, "token_count": 202}
{"id": "d632ede4be1c4cef", "text": "## Собрать Docker-образ для однофайлового FastAPI { #build-a-docker-image-with-a-single-file-fastapi }\n\nЕсли ваше приложение FastAPI — один файл, например `main.py` без директории `./app`, структура файлов может быть такой:\n\n```\n.\n├── Dockerfile\n├── main.py\n└── requirements.txt\n```\n\nТогда в `Dockerfile` нужно изменить пути копирования:\n\n```{ .dockerfile .annotate hl_lines=\"10  13\" }\nFROM python:3.9\n\nWORKDIR /code\n\nCOPY ./requirements.txt /code/requirements.txt\n\nRUN pip install --no-cache-dir --upgrade -r /code/requirements.txt\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 29, "header": "Собрать Docker-образ для однофайлового FastAPI", "header_level": 2, "token_count": 174}
{"id": "426ebe1c9aa4fee0", "text": "# (1)!\nCOPY ./main.py /code/\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 30, "header": "(1)!", "header_level": 1, "token_count": 11}
{"id": "afc1b42894dbb60d", "text": "# (2)!\nCMD [\"fastapi\", \"run\", \"main.py\", \"--port\", \"80\"]\n```\n\n1. Копируем файл `main.py` напрямую в `/code` (без директории `./app`).\n\n2. Используем `fastapi run` для запуска приложения из одного файла `main.py`.\n\nКогда вы передаёте файл в `fastapi run`, он автоматически определит, что это одиночный файл, а не часть пакета, и поймёт, как его импортировать и запустить ваше FastAPI-приложение. \n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 31, "header": "(2)!", "header_level": 1, "token_count": 158}
{"id": "4bb7cd124bf4a884", "text": "## Концепции развертывания { #deployment-concepts }\n\nЕщё раз рассмотрим [концепции развертывания](concepts.md){.internal-link target=_blank} применительно к контейнерам.\n\nКонтейнеры главным образом упрощают **сборку и развёртывание** приложения, но не навязывают конкретный подход к этим **концепциям развертывания**, и существует несколько стратегий.\n\n**Хорошая новость** в том, что при любой стратегии есть способ охватить все концепции развертывания. \n\nРассмотрим эти **концепции развертывания** в терминах контейнеров:\n\n* HTTPS\n* Запуск при старте\n* Перезапуски\n* Репликация (количество запущенных процессов)\n* Память\n* Предварительные шаги перед запуском\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 32, "header": "Концепции развертывания", "header_level": 2, "token_count": 273}
{"id": "4320495fd8b8a3df", "text": "## HTTPS { #https }\n\nЕсли мы рассматриваем только **образ контейнера** для приложения FastAPI (и далее запущенный **контейнер**), то HTTPS обычно обрабатывается **внешним** инструментом.\n\nЭто может быть другой контейнер, например с <a href=\"https://traefik.io/\" class=\"external-link\" target=\"_blank\">Traefik</a>, который берёт на себя **HTTPS** и **автоматическое** получение **сертификатов**.\n\n/// tip | Подсказка\n\nУ Traefik есть интеграции с Docker, Kubernetes и другими, поэтому очень легко настроить и сконфигурировать HTTPS для ваших контейнеров.\n\n///\n\nВ качестве альтернативы HTTPS может быть реализован как сервис облачного провайдера (при этом приложение всё равно работает в контейнере).\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 33, "header": "HTTPS", "header_level": 2, "token_count": 263}
{"id": "d120cb6ff1c0aff1", "text": "## Запуск при старте и перезапуски { #running-on-startup-and-restarts }\n\nОбычно есть другой инструмент, отвечающий за **запуск и работу** вашего контейнера.\n\nЭто может быть сам **Docker**, **Docker Compose**, **Kubernetes**, **облачный сервис** и т.п.\n\nВ большинстве (или во всех) случаев есть простая опция, чтобы включить запуск контейнера при старте системы и перезапуски при сбоях. Например, в Docker это опция командной строки `--restart`.\n\nБез контейнеров обеспечить запуск при старте и перезапуски может быть сложно. Но при **работе с контейнерами** в большинстве случаев этот функционал доступен по умолчанию. \n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 34, "header": "Запуск при старте и перезапуски", "header_level": 2, "token_count": 231}
{"id": "daab2dd16256e086", "text": "## Репликация — количество процессов { #replication-number-of-processes }\n\nЕсли у вас есть <abbr title=\"Группа машин, настроенных так, чтобы быть соединенными и работать вместе определенным образом.\">кластер</abbr> машин с **Kubernetes**, Docker Swarm Mode, Nomad или другой похожей системой для управления распределёнными контейнерами на нескольких машинах, скорее всего вы будете **управлять репликацией** на **уровне кластера**, а не использовать **менеджер процессов** (например, Uvicorn с воркерами) в каждом контейнере.\n\nОдна из таких систем управления распределёнными контейнерами, как Kubernetes, обычно имеет встроенный способ управлять **репликацией контейнеров**, поддерживая **балансировку нагрузки** для входящих запросов — всё это на **уровне кластера**.\n\nВ таких случаях вы, скорее всего, захотите собрать **Docker-образ с нуля**, как [описано выше](#dockerfile), установить зависимости и запускать **один процесс Uvicorn** вместо множества воркеров Uvicorn.\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 35, "header": "Репликация — количество процессов", "header_level": 2, "token_count": 381}
{"id": "66fda499ee71915e", "text": "### Балансировщик нагрузки { #load-balancer }\n\nПри использовании контейнеров обычно есть компонент, **слушающий главный порт**. Это может быть другой контейнер — **прокси завершения TLS** для обработки **HTTPS** или похожий инструмент.\n\nПоскольку этот компонент принимает **нагрузку** запросов и распределяет её между воркерами **сбалансированно**, его часто называют **балансировщиком нагрузки**.\n\n/// tip | Подсказка\n\nТот же компонент **прокси завершения TLS**, который обрабатывает HTTPS, скорее всего также будет **балансировщиком нагрузки**.\n\n///\n\nПри работе с контейнерами система, которую вы используете для запуска и управления ими, уже имеет внутренние средства для передачи **сетевого взаимодействия** (например, HTTP-запросов) от **балансировщика нагрузки** (который также может быть **прокси завершения TLS**) к контейнеру(-ам) с вашим приложением.\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 36, "header": "Балансировщик нагрузки", "header_level": 3, "token_count": 350}
{"id": "971eb4552b4e3c7e", "text": "### Один балансировщик — несколько контейнеров-воркеров { #one-load-balancer-multiple-worker-containers }\n\nПри работе с **Kubernetes** или похожими системами управления распределёнными контейнерами их внутренние механизмы сети позволяют одному **балансировщику нагрузки**, слушающему главный **порт**, передавать запросы в **несколько контейнеров**, где запущено ваше приложение.\n\nКаждый такой контейнер с вашим приложением обычно имеет **только один процесс** (например, процесс Uvicorn с вашим приложением FastAPI). Все они — **одинаковые контейнеры**, запускающие одно и то же, но у каждого свой процесс, память и т.п. Так вы используете **параллелизм** по **разным ядрам** CPU или даже **разным машинам**.\n\nСистема распределённых контейнеров с **балансировщиком нагрузки** будет **распределять запросы** между контейнерами с вашим приложением **по очереди**. То есть каждый запрос может обрабатываться одним из нескольких **реплицированных контейнеров**.\n\nОбычно такой **балансировщик нагрузки** может также обрабатывать запросы к *другим* приложениям в вашем кластере (например, к другому домену или под другим префиксом пути URL) и направлять их к нужным контейнерам этого *другого* приложения.\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 37, "header": "Один балансировщик — несколько контейнеров-воркеров", "header_level": 3, "token_count": 498}
{"id": "b8a528cac67fef53", "text": "### Один процесс на контейнер { #one-process-per-container }\n\nВ таком сценарии, скорее всего, вы захотите иметь **один (Uvicorn) процесс на контейнер**, так как репликация уже управляется на уровне кластера.\n\nПоэтому в контейнере **не нужно** поднимать несколько воркеров, например через опцию командной строки `--workers`. Нужен **один процесс Uvicorn** на контейнер (но, возможно, несколько контейнеров).\n\nНаличие отдельного менеджера процессов внутри контейнера (как при нескольких воркерах) только добавит **лишнюю сложность**, которую, вероятно, уже берёт на себя ваша кластерная система.\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 38, "header": "Один процесс на контейнер", "header_level": 3, "token_count": 237}
{"id": "f2c1c02d2e2e5835", "text": "### Контейнеры с несколькими процессами и особые случаи { #containers-with-multiple-processes-and-special-cases }\n\nКонечно, есть **особые случаи**, когда может понадобиться **контейнер** с несколькими **воркерами Uvicorn** внутри.\n\nВ таких случаях вы можете использовать опцию командной строки `--workers`, чтобы указать нужное количество воркеров:\n\n```{ .dockerfile .annotate }\nFROM python:3.9\n\nWORKDIR /code\n\nCOPY ./requirements.txt /code/requirements.txt\n\nRUN pip install --no-cache-dir --upgrade -r /code/requirements.txt\n\nCOPY ./app /code/app\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 39, "header": "Контейнеры с несколькими процессами и особые случаи", "header_level": 3, "token_count": 179}
{"id": "28148cbfb3751365", "text": "# (1)!\nCMD [\"fastapi\", \"run\", \"app/main.py\", \"--port\", \"80\", \"--workers\", \"4\"]\n```\n\n1. Здесь мы используем опцию `--workers`, чтобы установить число воркеров равным 4.\n\nПримеры, когда это может быть уместно:\n\n#### Простое приложение { #a-simple-app }\n\nВам может понадобиться менеджер процессов в контейнере, если приложение **достаточно простое**, чтобы запускаться на **одном сервере**, а не в кластере.\n\n#### Docker Compose { #docker-compose }\n\nВы можете развёртывать на **одном сервере** (не кластере) с **Docker Compose**, и у вас не будет простого способа управлять репликацией контейнеров (в Docker Compose), сохраняя общую сеть и **балансировку нагрузки**.\n\nТогда вы можете захотеть **один контейнер** с **менеджером процессов**, который запускает **несколько воркеров** внутри.\n\n---\n\nГлавное — **ни одно** из этих правил не является **строго обязательным**. Используйте эти идеи, чтобы **оценить свой конкретный случай** и решить, какой подход лучше для вашей системы, учитывая:\n\n* Безопасность — HTTPS\n* Запуск при старте\n* Перезапуски\n* Репликацию (количество запущенных процессов)\n* Память\n* Предварительные шаги перед запуском\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 40, "header": "(1)!", "header_level": 1, "token_count": 449}
{"id": "92e7be4ecd11b9c2", "text": "## Память { #memory }\n\nЕсли вы запускаете **один процесс на контейнер**, у каждого контейнера будет более-менее чётко определённый, стабильный и ограниченный объём потребляемой памяти (контейнеров может быть несколько при репликации).\n\nЗатем вы можете задать такие же лимиты и требования по памяти в конфигурации вашей системы управления контейнерами (например, в **Kubernetes**). Так система сможет **реплицировать контейнеры** на **доступных машинах**, учитывая объём необходимой памяти и доступной памяти в машинах кластера.\n\nЕсли приложение **простое**, это, вероятно, **не будет проблемой**, и жёсткие лимиты памяти можно не указывать. Но если вы **используете много памяти** (например, с моделями **Машинного обучения**), проверьте, сколько памяти потребляется, и отрегулируйте **число контейнеров** на **каждой машине** (и, возможно, добавьте машины в кластер).\n\nЕсли вы запускаете **несколько процессов в контейнере**, нужно убедиться, что их суммарное потребление **не превысит доступную память**.\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 41, "header": "Память", "header_level": 2, "token_count": 422}
{"id": "7138eda70db3f713", "text": "## Предварительные шаги перед запуском и контейнеры { #previous-steps-before-starting-and-containers }\n\nЕсли вы используете контейнеры (например, Docker, Kubernetes), есть два основных подхода.\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 42, "header": "Предварительные шаги перед запуском и контейнеры", "header_level": 2, "token_count": 64}
{"id": "5671ed4de035fcc4", "text": "### Несколько контейнеров { #multiple-containers }\n\nЕсли у вас **несколько контейнеров**, и, вероятно, каждый запускает **один процесс** (например, в кластере **Kubernetes**), то вы, скорее всего, захотите иметь **отдельный контейнер**, выполняющий **предварительные шаги** в одном контейнере и одном процессе **до** запуска реплицированных контейнеров-воркеров.\n\n/// info | Информация\n\nЕсли вы используете Kubernetes, это, вероятно, будет <a href=\"https://kubernetes.io/docs/concepts/workloads/pods/init-containers/\" class=\"external-link\" target=\"_blank\">Init Container</a>.\n\n///\n\nЕсли в вашем случае нет проблемы с тем, чтобы выполнять эти предварительные шаги **многократно и параллельно** (например, вы не запускаете миграции БД, а только проверяете готовность БД), вы можете просто выполнить их в каждом контейнере прямо перед стартом основного процесса.\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 43, "header": "Несколько контейнеров", "header_level": 3, "token_count": 324}
{"id": "d3e0a42015c4cd14", "text": "### Один контейнер { #single-container }\n\nЕсли у вас простая схема с **одним контейнером**, который затем запускает несколько **воркеров** (или один процесс), можно выполнить подготовительные шаги в этом же контейнере непосредственно перед запуском процесса с приложением.\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 44, "header": "Один контейнер", "header_level": 3, "token_count": 106}
{"id": "ee7893beee8591b7", "text": "### Базовый Docker-образ { #base-docker-image }\n\nРанее существовал официальный Docker-образ FastAPI: <a href=\"https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker\" class=\"external-link\" target=\"_blank\">tiangolo/uvicorn-gunicorn-fastapi</a>. Сейчас он помечен как устаревший. \n\nСкорее всего, вам **не стоит** использовать этот базовый образ (или какой-либо аналогичный).\n\nЕсли вы используете **Kubernetes** (или другое) и уже настраиваете **репликацию** на уровне кластера через несколько **контейнеров**, в этих случаях лучше **собрать образ с нуля**, как описано выше: [Создать Docker-образ для FastAPI](#build-a-docker-image-for-fastapi).\n\nА если вам нужны несколько воркеров, просто используйте опцию командной строки `--workers`.\n\n/// note | Технические подробности\n\nЭтот Docker-образ был создан в то время, когда Uvicorn не умел управлять и перезапускать «упавших» воркеров, и приходилось использовать Gunicorn вместе с Uvicorn, что добавляло заметную сложность, лишь бы Gunicorn управлял и перезапускал воркеров Uvicorn.\n\nНо теперь, когда Uvicorn (и команда `fastapi`) поддерживают `--workers`, нет причин использовать базовый Docker-образ вместо сборки своего (кода получается примерно столько же ).\n\n///\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 45, "header": "Базовый Docker-образ", "header_level": 3, "token_count": 462}
{"id": "d966d62184f8c6af", "text": "## Развёртывание образа контейнера { #deploy-the-container-image }\n\nПосле того как у вас есть образ контейнера (Docker), его можно развёртывать несколькими способами.\n\nНапример:\n\n* С **Docker Compose** на одном сервере\n* В кластере **Kubernetes**\n* В кластере Docker Swarm Mode\n* С другим инструментом, например Nomad\n* С облачным сервисом, который принимает ваш образ контейнера и разворачивает его\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 46, "header": "Развёртывание образа контейнера", "header_level": 2, "token_count": 153}
{"id": "4789a5f17b6e72dd", "text": "## Docker-образ с `uv` { #docker-image-with-uv }\n\nЕсли вы используете <a href=\"https://github.com/astral-sh/uv\" class=\"external-link\" target=\"_blank\">uv</a> для установки и управления проектом, следуйте их <a href=\"https://docs.astral.sh/uv/guides/integration/docker/\" class=\"external-link\" target=\"_blank\">руководству по Docker для uv</a>.\n\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 47, "header": "Docker-образ с `uv`", "header_level": 2, "token_count": 107}
{"id": "bd0cab5c3dea494a", "text": "## Резюме { #recap }\n\nИспользуя системы контейнеризации (например, **Docker** и **Kubernetes**), довольно просто закрыть все **концепции развертывания**:\n\n* HTTPS\n* Запуск при старте\n* Перезапуски\n* Репликация (количество запущенных процессов)\n* Память\n* Предварительные шаги перед запуском\n\nВ большинстве случаев вы, вероятно, не захотите использовать какой-либо базовый образ, а вместо этого **соберёте образ контейнера с нуля** на основе официального Docker-образа Python.\n\nЗаботясь о **порядке**  инструкций в `Dockerfile`и используя **кэш Docker**, вы можете **минимизировать время сборки**, чтобы повысить продуктивность (и не скучать).\n", "metadata": {"title": "FastAPI в контейнерах — Docker", "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "source_mtime": "2026-01-12T17:48:13.151865+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\docker.md"}, "doc_id": "8be2713891b6", "source_path": "docs\\deployment\\docker.md", "title": "FastAPI в контейнерах — Docker", "chunk_index": 48, "header": "Резюме", "header_level": 2, "token_count": 266}
{"id": "710755eafba7793e", "text": "# FastAPI Cloud { #fastapi-cloud }\n\nВы можете развернуть своё приложение FastAPI в <a href=\"https://fastapicloud.com\" class=\"external-link\" target=\"_blank\">FastAPI Cloud</a> одной командой, присоединяйтесь к списку ожидания, если ещё не сделали этого. \n\n", "metadata": {"title": "FastAPI Cloud", "doc_id": "5c8a81724154", "source_path": "docs\\deployment\\fastapicloud.md", "source_mtime": "2026-01-12T17:48:13.152800+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\fastapicloud.md"}, "doc_id": "5c8a81724154", "source_path": "docs\\deployment\\fastapicloud.md", "title": "FastAPI Cloud", "chunk_index": 0, "header": "FastAPI Cloud", "header_level": 1, "token_count": 88}
{"id": "6b1ac52e28956652", "text": "## Вход { #login }\n\nУбедитесь, что у вас уже есть аккаунт **FastAPI Cloud** (мы пригласили вас из списка ожидания ).\n\nЗатем выполните вход:\n\n<div class=\"termy\">\n\n```console\n$ fastapi login\n\nYou are logged in to FastAPI Cloud 🚀\n```\n\n</div>\n\n", "metadata": {"title": "FastAPI Cloud", "doc_id": "5c8a81724154", "source_path": "docs\\deployment\\fastapicloud.md", "source_mtime": "2026-01-12T17:48:13.152800+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\fastapicloud.md"}, "doc_id": "5c8a81724154", "source_path": "docs\\deployment\\fastapicloud.md", "title": "FastAPI Cloud", "chunk_index": 1, "header": "Вход", "header_level": 2, "token_count": 85}
{"id": "2990807679a559a5", "text": "## Деплой { #deploy }\n\nТеперь разверните приложение одной командой:\n\n<div class=\"termy\">\n\n```console\n$ fastapi deploy\n\nDeploying to FastAPI Cloud...\n\n✅ Deployment successful!\n\n🐔 Ready the chicken! Your app is ready at https://myapp.fastapicloud.dev\n```\n\n</div>\n\nВот и всё! Теперь вы можете открыть своё приложение по этому URL. \n\n", "metadata": {"title": "FastAPI Cloud", "doc_id": "5c8a81724154", "source_path": "docs\\deployment\\fastapicloud.md", "source_mtime": "2026-01-12T17:48:13.152800+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\fastapicloud.md"}, "doc_id": "5c8a81724154", "source_path": "docs\\deployment\\fastapicloud.md", "title": "FastAPI Cloud", "chunk_index": 2, "header": "Деплой", "header_level": 2, "token_count": 107}
{"id": "16f3e27650e8147e", "text": "## О FastAPI Cloud { #about-fastapi-cloud }\n\n**<a href=\"https://fastapicloud.com\" class=\"external-link\" target=\"_blank\">FastAPI Cloud</a>** создан тем же автором и командой, что и **FastAPI**.\n\nОн упрощает процесс **создания образа**, **развертывания** и **доступа** к API с минимальными усилиями.\n\nОн переносит тот же **опыт разработчика**, что вы получаете при создании приложений на FastAPI, на их **развертывание** в облаке. \n\nОн также возьмёт на себя большинство вещей, которые требуются при развертывании приложения, например:\n\n* HTTPS\n* Репликация с автоматическим масштабированием на основе запросов\n* и т.д.\n\nFastAPI Cloud — основной спонсор и источник финансирования open source‑проектов «FastAPI и друзья». \n\n", "metadata": {"title": "FastAPI Cloud", "doc_id": "5c8a81724154", "source_path": "docs\\deployment\\fastapicloud.md", "source_mtime": "2026-01-12T17:48:13.152800+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\fastapicloud.md"}, "doc_id": "5c8a81724154", "source_path": "docs\\deployment\\fastapicloud.md", "title": "FastAPI Cloud", "chunk_index": 3, "header": "О FastAPI Cloud", "header_level": 2, "token_count": 281}
{"id": "9457270e018829d1", "text": "## Развертывание у других облачных провайдеров { #deploy-to-other-cloud-providers }\n\nFastAPI — проект с открытым исходным кодом и основан на стандартах. Вы можете развернуть приложения FastAPI у любого облачного провайдера на ваш выбор.\n\nСледуйте руководствам вашего облачного провайдера, чтобы развернуть приложения FastAPI у них. \n\n", "metadata": {"title": "FastAPI Cloud", "doc_id": "5c8a81724154", "source_path": "docs\\deployment\\fastapicloud.md", "source_mtime": "2026-01-12T17:48:13.152800+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\fastapicloud.md"}, "doc_id": "5c8a81724154", "source_path": "docs\\deployment\\fastapicloud.md", "title": "FastAPI Cloud", "chunk_index": 4, "header": "Развертывание у других облачных провайдеров", "header_level": 2, "token_count": 119}
{"id": "052ba59da8c4e49a", "text": "## Развертывание на собственном сервере { #deploy-your-own-server }\n\nПозже в этом руководстве по **развертыванию** я также расскажу все детали — чтобы вы понимали, что происходит, что нужно сделать и как развернуть приложения FastAPI самостоятельно, в том числе на собственных серверах.\n", "metadata": {"title": "FastAPI Cloud", "doc_id": "5c8a81724154", "source_path": "docs\\deployment\\fastapicloud.md", "source_mtime": "2026-01-12T17:48:13.152800+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\fastapicloud.md"}, "doc_id": "5c8a81724154", "source_path": "docs\\deployment\\fastapicloud.md", "title": "FastAPI Cloud", "chunk_index": 5, "header": "Развертывание на собственном сервере", "header_level": 2, "token_count": 109}
{"id": "d53e2cc55486001c", "text": "# Об HTTPS { #about-https }\n\nЛегко предположить, что HTTPS — это что-то, что просто «включено» или нет.\n\nНо на самом деле всё гораздо сложнее.\n\n/// tip | Совет\n\nЕсли вы торопитесь или вам это не важно, переходите к следующим разделам с пошаговыми инструкциями по настройке всего разными способами.\n\n///\n\nЧтобы **изучить основы HTTPS** с точки зрения пользователя, загляните на <a href=\"https://howhttps.works/\" class=\"external-link\" target=\"_blank\">https://howhttps.works/</a>.\n\nТеперь, со стороны **разработчика**, вот несколько вещей, которые стоит держать в голове, размышляя об HTTPS:", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md", "section_header": "Об HTTPS", "section_header_level": 1}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 0, "header": "Об HTTPS", "header_level": 1, "token_count": 220}
{"id": "d36dd4c5c9756029", "text": "external-link\" target=\"_blank\">https://howhttps.works/</a>.\n\nТеперь, со стороны **разработчика**, вот несколько вещей, которые стоит держать в голове, размышляя об HTTPS:\n\n* Для HTTPS **серверу** нужно **иметь «сертификаты»**, сгенерированные  **третьей стороной**.\n    * Эти сертификаты на самом деле **приобретаются** у третьей стороны, а не «генерируются».\n* У сертификатов есть **срок действия**.\n    * Они **истекают**.\n    * После этого их нужно **обновлять**, то есть **получать заново** у третьей стороны.\n* Шифрование соединения происходит на **уровне TCP**.\n    * Это на один уровень **ниже HTTP**.\n    * Поэтому **сертификаты и шифрование** обрабатываются **до HTTP**.\n* **TCP не знает о «доменах»**. Только об IP-адресах.\n    * Информация о **конкретном домене** передаётся в **данных HTTP**.\n* **HTTPS-сертификаты** «сертифицируют» **определённый домен**, но протокол и шифрование происходят на уровне TCP, **до того как** становится известен домен, с которым идёт работа.\n* **По умолчанию** это означает, что вы можете иметь **лишь один HTTPS-сертификат на один IP-адрес**.\n    * Неважно, насколько мощный у вас сервер или насколько маленькие приложения на нём работают.\n    * Однако у этого есть **решение**.\n* Есть **расширение** протокола **TLS** (того самого, что занимается шифрованием на уровне TCP, до HTTP) под названием **<a href=\"https://en.wikipedia.org/wiki/Server_Name_Indication\" class=\"external-link\" target=\"_blank\"><abbr title=\"Server Name Indication – Указание имени сервера\">SNI</abbr></a>**.\n    * Это расширение SNI позволяет одному серверу (с **одним IP-адресом**) иметь **несколько HTTPS-сертификатов** и обслуживать **несколько HTTPS-доменов/приложений**.\n    * Чтобы это работало, **один** компонент (программа), запущенный на сервере и слушающий **публичный IP-адрес**, должен иметь **все HTTPS-сертификаты** на этом сервере.\n* **После** установления защищённого соединения, протокол обмена данными — **всё ещё HTTP**.\n    * Содержимое **зашифровано**, несмотря на то, что оно отправляется по **протоколу HTTP**.", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md", "section_header": "Об HTTPS", "section_header_level": 1}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 1, "header": "Об HTTPS", "header_level": 1, "token_count": 870}
{"id": "94eb7f7d076ac846", "text": "соединения, протокол обмена данными — **всё ещё HTTP**.\n    * Содержимое **зашифровано**, несмотря на то, что оно отправляется по **протоколу HTTP**.\n\nОбычно на сервере (машине, хосте и т.п.) запускают **одну программу/HTTP‑сервер**, которая **управляет всей частью, связанной с HTTPS**: принимает **зашифрованные HTTPS-запросы**, отправляет **расшифрованные HTTP-запросы** в само HTTP‑приложение, работающее на том же сервере (в нашем случае это приложение **FastAPI**), получает **HTTP-ответ** от приложения, **шифрует его** с использованием подходящего **HTTPS‑сертификата** и отправляет клиенту по **HTTPS**. Такой сервер часто называют **<a href=\"https://en.wikipedia.org/wiki/TLS_termination_proxy\" class=\"external-link\" target=\"_blank\">прокси‑сервером TLS-терминации</a>**.\n\nНекоторые варианты, которые вы можете использовать как прокси‑сервер TLS-терминации:\n\n* Traefik (умеет обновлять сертификаты)\n* Caddy (умеет обновлять сертификаты)\n* Nginx\n* HAProxy", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md", "section_header": "Об HTTPS", "section_header_level": 1}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 2, "header": "Об HTTPS", "header_level": 1, "token_count": 387}
{"id": "f019cb2b24516b05", "text": "## Let's Encrypt { #lets-encrypt }\n\nДо появления Let's Encrypt эти **HTTPS-сертификаты** продавались доверенными третьими сторонами.\n\nПроцесс получения таких сертификатов был неудобным, требовал бумажной волокиты, а сами сертификаты были довольно дорогими.\n\nЗатем появился **<a href=\"https://letsencrypt.org/\" class=\"external-link\" target=\"_blank\">Let's Encrypt</a>**.\n\nЭто проект Linux Foundation. Он предоставляет **HTTPS‑сертификаты бесплатно**, в автоматическом режиме. Эти сертификаты используют стандартные криптографические механизмы и имеют короткий срок действия (около 3 месяцев), поэтому **безопасность фактически выше** благодаря уменьшенному сроку жизни.\n\nДомены безопасно проверяются, а сертификаты выдаются автоматически. Это также позволяет автоматизировать процесс их продления.\n\nИдея — автоматизировать получение и продление сертификатов, чтобы у вас был **безопасный HTTPS, бесплатно и навсегда**.\n\n", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md"}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 3, "header": "Let's Encrypt", "header_level": 2, "token_count": 384}
{"id": "f191048a99288b7c", "text": "## HTTPS для разработчиков { #https-for-developers }\n\nНиже приведён пример того, как может выглядеть HTTPS‑API, шаг за шагом, с акцентом на идеях, важных для разработчиков.\n\n", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md"}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 4, "header": "HTTPS для разработчиков", "header_level": 2, "token_count": 68}
{"id": "3b567c73429c55ef", "text": "### Имя домена { #domain-name }\n\nЧаще всего всё начинается с **приобретения** **имени домена**. Затем вы настраиваете его на DNS‑сервере (возможно, у того же облачного провайдера).\n\nСкорее всего, вы получите облачный сервер (виртуальную машину) или что-то подобное, и у него будет <abbr title=\"Не изменяется\">постоянный</abbr> **публичный IP-адрес**.\n\nНа DNS‑сервере(ах) вы настроите запись («`A record`» - запись типа A), указывающую, что **ваш домен** должен указывать на публичный **IP‑адрес вашего сервера**.\n\nОбычно это делается один раз — при первоначальной настройке всего.\n\n/// tip | Совет\n\nЧасть про доменное имя относится к этапам задолго до HTTPS, но так как всё зависит от домена и IP‑адреса, здесь стоит это упомянуть.\n\n///\n\n", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md"}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 5, "header": "Имя домена", "header_level": 3, "token_count": 301}
{"id": "ca5df711a26a57fb", "text": "### DNS { #dns }\n\nТеперь сфокусируемся на собственно частях, связанных с HTTPS.\n\nСначала браузер спросит у **DNS‑серверов**, какой **IP соответствует домену**, в нашем примере `someapp.example.com`.\n\nDNS‑серверы ответят браузеру, какой **конкретный IP‑адрес** использовать. Это будет публичный IP‑адрес вашего сервера, который вы указали в настройках DNS.\n\n<img src=\"/img/deployment/https/https01.drawio.svg\">\n\n", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md"}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 6, "header": "DNS", "header_level": 3, "token_count": 159}
{"id": "218f675f10228751", "text": "### Начало TLS-рукопожатия { #tls-handshake-start }\n\nДалее браузер будет общаться с этим IP‑адресом на **порту 443** (порт HTTPS).\n\nПервая часть взаимодействия — установить соединение между клиентом и сервером и договориться о криптографических ключах и т.п.\n\n<img src=\"/img/deployment/https/https02.drawio.svg\">\n\nЭто взаимодействие клиента и сервера для установления TLS‑соединения называется **TLS‑рукопожатием**.\n\n", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md"}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 7, "header": "Начало TLS-рукопожатия", "header_level": 3, "token_count": 166}
{"id": "d53e2cc55486001c", "text": "### TLS с расширением SNI { #tls-with-sni-extension }\n\nНа сервере **только один процесс** может слушать конкретный **порт** на конкретном **IP‑адресе**. Могут быть другие процессы, слушающие другие порты на том же IP‑адресе, но не более одного процесса на каждую комбинацию IP‑адреса и порта.\n\nПо умолчанию TLS (HTTPS) использует порт `443`. Значит, он нам и нужен.\n\nТак как только один процесс может слушать этот порт, делать это будет **прокси‑сервер TLS-терминации**.\n\nУ прокси‑сервера TLS-терминации будет доступ к одному или нескольким **TLS‑сертификатам** (HTTPS‑сертификатам).\n\nИспользуя **расширение SNI**, упомянутое выше, прокси‑сервер TLS-терминации определит, какой из доступных TLS (HTTPS)‑сертификатов нужно использовать для этого соединения, выбрав тот, который соответствует домену, ожидаемому клиентом.\n\nВ нашем случае это будет сертификат для `someapp.example.com`.\n\n<img src=\"/img/deployment/https/https03.drawio.svg\">\n\nКлиент уже **доверяет** организации, выдавшей этот TLS‑сертификат (в нашем случае — Let's Encrypt, но об этом позже), поэтому может **проверить**, что сертификат действителен.", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md", "section_header": "TLS с расширением SNI", "section_header_level": 3}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 8, "header": "TLS с расширением SNI", "header_level": 3, "token_count": 452}
{"id": "d36dd4c5c9756029", "text": "рганизации, выдавшей этот TLS‑сертификат (в нашем случае — Let's Encrypt, но об этом позже), поэтому может **проверить**, что сертификат действителен.\n\nЗатем, используя сертификат, клиент и прокси‑сервер TLS-терминации **договариваются о способе шифрования** остальной **TCP‑коммуникации**. На этом **TLS‑рукопожатие** завершено.\n\nПосле этого у клиента и сервера есть **зашифрованное TCP‑соединение** — это и предоставляет TLS. И они могут использовать это соединение, чтобы начать собственно **HTTP‑обмен**.\n\nСобственно, **HTTPS** — это обычный **HTTP** внутри **защищённого TLS‑соединения**, вместо чистого (незашифрованного) TCP‑соединения.\n\n/// tip | Совет\n\nОбратите внимание, что шифрование обмена происходит на **уровне TCP**, а не на уровне HTTP.\n\n///", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md", "section_header": "TLS с расширением SNI", "section_header_level": 3}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 9, "header": "TLS с расширением SNI", "header_level": 3, "token_count": 320}
{"id": "b1cc5d1845176d58", "text": "### HTTPS‑запрос { #https-request }\n\nТеперь, когда у клиента и сервера (конкретно у браузера и прокси‑сервера TLS-терминации) есть **зашифрованное TCP‑соединение**, они могут начать **HTTP‑обмен**.\n\nКлиент отправляет **HTTPS‑запрос**. Это обычный HTTP‑запрос через зашифрованное TLS‑соединение.\n\n<img src=\"/img/deployment/https/https04.drawio.svg\">\n\n", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md"}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 10, "header": "HTTPS‑запрос", "header_level": 3, "token_count": 142}
{"id": "4a224cffc8dab615", "text": "### Расшифровка запроса { #decrypt-the-request }\n\nПрокси‑сервер TLS-терминации использует согласованное шифрование, чтобы **расшифровать запрос**, и передаёт **обычный (расшифрованный) HTTP‑запрос** процессу, запускающему приложение (например, процессу с Uvicorn, который запускает приложение FastAPI).\n\n<img src=\"/img/deployment/https/https05.drawio.svg\">\n\n", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md"}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 11, "header": "Расшифровка запроса", "header_level": 3, "token_count": 132}
{"id": "c76f815fca970786", "text": "### HTTP‑ответ { #http-response }\n\nПриложение обработает запрос и отправит **обычный (незашифрованный) HTTP‑ответ** прокси‑серверу TLS-терминации.\n\n<img src=\"/img/deployment/https/https06.drawio.svg\">\n\n", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md"}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 12, "header": "HTTP‑ответ", "header_level": 3, "token_count": 71}
{"id": "c57ae37666e3e80b", "text": "### HTTPS‑ответ { #https-response }\n\nЗатем прокси‑сервер TLS-терминации **зашифрует ответ** с использованием ранее согласованного способа шифрования (который начали использовать для сертификата для `someapp.example.com`) и отправит его обратно в браузер.\n\nДалее браузер проверит, что ответ корректен и зашифрован правильным криптографическим ключом и т.п., затем **расшифрует ответ** и обработает его.\n\n<img src=\"/img/deployment/https/https07.drawio.svg\">\n\nКлиент (браузер) узнает, что ответ пришёл от правильного сервера, потому что используется способ шифрования, о котором они договорились ранее с помощью **HTTPS‑сертификата**.\n\n", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md"}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 13, "header": "HTTPS‑ответ", "header_level": 3, "token_count": 243}
{"id": "a6b072d0a5171071", "text": "### Несколько приложений { #multiple-applications }\n\nНа одном и том же сервере (или серверах) могут работать **несколько приложений**, например другие программы с API или база данных.\n\nТолько один процесс может обрабатывать конкретную комбинацию IP и порта (в нашем примере — прокси‑сервер TLS-терминации), но остальные приложения/процессы тоже могут работать на сервере(ах), пока они не пытаются использовать ту же **комбинацию публичного IP и порта**.\n\n<img src=\"/img/deployment/https/https08.drawio.svg\">\n\nТаким образом, прокси‑сервер TLS-терминации может обрабатывать HTTPS и сертификаты для **нескольких доменов** (для нескольких приложений), а затем передавать запросы нужному приложению в каждом случае.\n\n", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md"}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 14, "header": "Несколько приложений", "header_level": 3, "token_count": 274}
{"id": "d53e2cc55486001c", "text": "### Продление сертификата { #certificate-renewal }\n\nСо временем каждый сертификат **истечёт** (примерно через 3 месяца после получения).\n\nЗатем будет другая программа (иногда это отдельная программа, иногда — тот же прокси‑сервер TLS-терминации), которая свяжется с Let's Encrypt и продлит сертификат(ы).\n\n<img src=\"/img/deployment/https/https.drawio.svg\">\n\n**TLS‑сертификаты** **связаны с именем домена**, а не с IP‑адресом.\n\nПоэтому, чтобы продлить сертификаты, программа продления должна **доказать** удостоверяющему центру (Let's Encrypt), что она действительно **«владеет» и контролирует этот домен**.\n\nДля этого, учитывая разные потребности приложений, есть несколько способов. Популярные из них:", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md", "section_header": "Продление сертификата", "section_header_level": 3}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 15, "header": "Продление сертификата", "header_level": 3, "token_count": 277}
{"id": "d36dd4c5c9756029", "text": "на действительно **«владеет» и контролирует этот домен**.\n\nДля этого, учитывая разные потребности приложений, есть несколько способов. Популярные из них:\n\n* **Изменить некоторые DNS‑записи**.\n    * Для этого программа продления должна поддерживать API DNS‑провайдера, поэтому, в зависимости от используемого провайдера DNS, этот вариант может быть доступен или нет.\n* **Запуститься как сервер** (как минимум на время получения сертификатов) на публичном IP‑адресе, связанном с доменом.\n    * Как сказано выше, только один процесс может слушать конкретный IP и порт.\n    * Это одна из причин, почему очень удобно, когда тот же прокси‑сервер TLS-терминации также занимается процессом продления сертификатов.\n    * В противном случае вам, возможно, придётся временно остановить прокси‑сервер TLS-терминации, запустить программу продления для получения сертификатов, затем настроить их в прокси‑сервере TLS-терминации и перезапустить его. Это не идеально, так как ваше приложение(я) будут недоступны, пока прокси‑сервер TLS-терминации остановлен.", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md", "section_header": "Продление сертификата", "section_header_level": 3}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 16, "header": "Продление сертификата", "header_level": 3, "token_count": 423}
{"id": "94eb7f7d076ac846", "text": "сервере TLS-терминации и перезапустить его. Это не идеально, так как ваше приложение(я) будут недоступны, пока прокси‑сервер TLS-терминации остановлен.\n\nВесь этот процесс продления, совмещённый с обслуживанием приложения, — одна из главных причин иметь **отдельную систему для работы с HTTPS** в виде прокси‑сервера TLS-терминации, вместо использования TLS‑сертификатов напрямую в сервере приложения (например, Uvicorn).", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md", "section_header": "Продление сертификата", "section_header_level": 3}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 17, "header": "Продление сертификата", "header_level": 3, "token_count": 172}
{"id": "d53e2cc55486001c", "text": "## Пересылаемые HTTP-заголовки прокси { #proxy-forwarded-headers }\n\nКогда вы используете прокси для обработки HTTPS, ваш **сервер приложения** (например, Uvicorn через FastAPI CLI) ничего не знает о процессе HTTPS, он общается обычным HTTP с **прокси‑сервером TLS-терминации**.\n\nОбычно этот **прокси** на лету добавляет некоторые HTTP‑заголовки перед тем, как переслать запрос на **сервер приложения**, чтобы тот знал, что запрос был **проксирован**.\n\n/// note | Технические детали\n\nЗаголовки прокси:\n\n* <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-For\" class=\"external-link\" target=\"_blank\">X-Forwarded-For</a>\n* <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-Proto\" class=\"external-link\" target=\"_blank\">X-Forwarded-Proto</a>\n* <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-Host\" class=\"external-link\" target=\"_blank\">X-Forwarded-Host</a>\n\n///\n\nТем не менее, так как **сервер приложения** не знает, что он находится за доверенным **прокси**, по умолчанию он не будет доверять этим заголовкам.", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md", "section_header": "Пересылаемые HTTP-заголовки прокси", "section_header_level": 2}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 18, "header": "Пересылаемые HTTP-заголовки прокси", "header_level": 2, "token_count": 399}
{"id": "d36dd4c5c9756029", "text": "</a>\n\n///\n\nТем не менее, так как **сервер приложения** не знает, что он находится за доверенным **прокси**, по умолчанию он не будет доверять этим заголовкам.\n\nНо вы можете настроить **сервер приложения**, чтобы он доверял *пересылаемым* заголовкам, отправленным **прокси**. Если вы используете FastAPI CLI, вы можете использовать *опцию CLI* `--forwarded-allow-ips`, чтобы указать, с каких IP‑адресов следует доверять этим *пересылаемым* заголовкам.\n\nНапример, если **сервер приложения** получает запросы только от доверенного **прокси**, вы можете установить `--forwarded-allow-ips=\"*\"`, чтобы доверять всем входящим IP, так как он всё равно будет получать запросы только с IP‑адреса, используемого **прокси**.\n\nТаким образом, приложение сможет знать свой публичный URL, использует ли оно HTTPS, какой домен и т.п.\n\nЭто будет полезно, например, для корректной обработки редиректов.\n\n/// tip | Совет\n\nПодробнее об этом вы можете узнать в документации: [За прокси — Включить пересылаемые заголовки прокси](../advanced/behind-a-proxy.md#enable-proxy-forwarded-headers){.internal-link target=_blank}\n\n///", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md", "section_header": "Пересылаемые HTTP-заголовки прокси", "section_header_level": 2}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 19, "header": "Пересылаемые HTTP-заголовки прокси", "header_level": 2, "token_count": 420}
{"id": "ccea7b8051a2808b", "text": "## Резюме { #recap }\n\nНаличие **HTTPS** очень важно и во многих случаях довольно **критично**. Большая часть усилий, которые вам, как разработчику, нужно приложить вокруг HTTPS, — это просто **понимание этих концепций** и того, как они работают.\n\nЗная базовую информацию о **HTTPS для разработчиков**, вы сможете легко комбинировать и настраивать разные инструменты, чтобы управлять всем этим простым способом.\n\nВ некоторых из следующих глав я покажу вам несколько конкретных примеров настройки **HTTPS** для приложений **FastAPI**.\n", "metadata": {"title": "Об HTTPS", "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "source_mtime": "2026-01-12T17:48:13.162504+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\https.md"}, "doc_id": "13261ebb4a55", "source_path": "docs\\deployment\\https.md", "title": "Об HTTPS", "chunk_index": 20, "header": "Резюме", "header_level": 2, "token_count": 217}
{"id": "753a6fa09a4cb185", "text": "# Развёртывание { #deployment }\n\nРазвернуть приложение **FastAPI** довольно просто.\n\n", "metadata": {"title": "Развёртывание", "doc_id": "6fb1a25d1414", "source_path": "docs\\deployment\\index.md", "source_mtime": "2026-01-12T17:48:13.167880+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\index.md"}, "doc_id": "6fb1a25d1414", "source_path": "docs\\deployment\\index.md", "title": "Развёртывание", "chunk_index": 0, "header": "Развёртывание", "header_level": 1, "token_count": 32}
{"id": "82375736faedcdd6", "text": "## Что означает развёртывание { #what-does-deployment-mean }\n\nТермин **развёртывание** (приложения) означает выполнение необходимых шагов, чтобы сделать приложение **доступным для пользователей**.\n\nДля **веб-API** это обычно означает размещение его на **удалённой машине** с **серверной программой**, обеспечивающей хорошую производительность, стабильность и т.д., чтобы ваши **пользователи** могли **получать доступ** к приложению эффективно и без перебоев или проблем.\n\nЭто отличается от этапов **разработки**, когда вы постоянно меняете код, ломаете его и исправляете, останавливаете и перезапускаете сервер разработки и т.д.\n\n", "metadata": {"title": "Развёртывание", "doc_id": "6fb1a25d1414", "source_path": "docs\\deployment\\index.md", "source_mtime": "2026-01-12T17:48:13.167880+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\index.md"}, "doc_id": "6fb1a25d1414", "source_path": "docs\\deployment\\index.md", "title": "Развёртывание", "chunk_index": 1, "header": "Что означает развёртывание", "header_level": 2, "token_count": 250}
{"id": "7b94501cc247dbab", "text": "## Стратегии развёртывания { #deployment-strategies }\n\nЕсть несколько способов сделать это, в зависимости от вашего конкретного случая и используемых вами инструментов.\n\nВы можете **развернуть сервер** самостоятельно, используя различные инструменты. Например, можно использовать **облачный сервис**, который выполнит часть работы за вас. Также возможны и другие варианты.\n\nНапример, мы, команда, стоящая за FastAPI, создали <a href=\"https://fastapicloud.com\" class=\"external-link\" target=\"_blank\">**FastAPI Cloud**</a>, чтобы сделать развёртывание приложений FastAPI в облаке как можно более простым и прямолинейным, с тем же удобством для разработчика, что и при работе с FastAPI.\n\nВ этом блоке я покажу вам некоторые из основных концепций, которые вы, вероятно, должны иметь в виду при развертывании приложения **FastAPI** (хотя большинство из них применимо к любому другому типу веб-приложений).\n\nВ последующих разделах вы узнаете больше деталей и методов, необходимых для этого.\n", "metadata": {"title": "Развёртывание", "doc_id": "6fb1a25d1414", "source_path": "docs\\deployment\\index.md", "source_mtime": "2026-01-12T17:48:13.167880+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\index.md"}, "doc_id": "6fb1a25d1414", "source_path": "docs\\deployment\\index.md", "title": "Развёртывание", "chunk_index": 2, "header": "Стратегии развёртывания", "header_level": 2, "token_count": 370}
{"id": "0380f0539e8de58f", "text": "# Запуск сервера вручную { #run-a-server-manually }\n\n", "metadata": {"title": "Запуск сервера вручную", "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "source_mtime": "2026-01-12T17:48:13.174557+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\manually.md"}, "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "title": "Запуск сервера вручную", "chunk_index": 0, "header": "Запуск сервера вручную", "header_level": 1, "token_count": 19}
{"id": "0380f0539e8de58f", "text": "## Используйте команду `fastapi run` { #use-the-fastapi-run-command }\n\nКоротко: используйте `fastapi run`, чтобы запустить ваше приложение FastAPI:\n\n<div class=\"termy\">\n\n```console\n$ <font color=\"#4E9A06\">fastapi</font> run <u style=\"text-decoration-style:solid\">main.py</u>\n\n  <span style=\"background-color:#009485\"><font color=\"#D3D7CF\"> FastAPI </font></span>  Starting production server 🚀\n\n             Searching for package file structure from directories\n             with <font color=\"#3465A4\">__init__.py</font> files\n             Importing from <font color=\"#75507B\">/home/user/code/</font><font color=\"#AD7FA8\">awesomeapp</font>\n\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> module </font></span>  🐍 main.py\n\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> code </font></span>  Importing the FastAPI app object from the module with\n             the following code:\n\n             <u style=\"text-decoration-style:solid\">from </u><u style=\"text-decoration-style:solid\"><b>main</b></u><u style=\"text-decoration-style:solid\"> import </u><u style=\"text-decoration-style:solid\"><b>app</b></u>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> app </font></span>  Using import string: <font color=\"#3465A4\">main:app</font>\n\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Server started at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://0.0.0.0:8000</u></font>\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Documentation at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://0.0.0.0:8000/docs</u></font>\n\n             Logs:", "metadata": {"title": "Запуск сервера вручную", "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "source_mtime": "2026-01-12T17:48:13.174557+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\manually.md", "section_header": "Используйте команду `fastapi run`", "section_header_level": 2}, "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "title": "Запуск сервера вручную", "chunk_index": 1, "header": "Используйте команду `fastapi run`", "header_level": 2, "token_count": 502}
{"id": "a733dbdd72f0ad57", "text": "style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Documentation at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://0.0.0.0:8000/docs</u></font>\n\n             Logs:\n\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started server process <b>[</b><font color=\"#34E2E2\"><b>2306215</b></font><b>]</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Waiting for application startup.\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Application startup complete.\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Uvicorn running on <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://0.0.0.0:8000</u></font> <b>(</b>Press CTRL+C\n             to quit<b>)</b>\n```\n\n</div>\n\nВ большинстве случаев этого достаточно. \n\nЭтой командой, например, можно запускать приложение **FastAPI** в контейнере, на сервере и т.д.", "metadata": {"title": "Запуск сервера вручную", "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "source_mtime": "2026-01-12T17:48:13.174557+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\manually.md", "section_header": "Используйте команду `fastapi run`", "section_header_level": 2}, "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "title": "Запуск сервера вручную", "chunk_index": 2, "header": "Используйте команду `fastapi run`", "header_level": 2, "token_count": 331}
{"id": "b3001ee9925e05ae", "text": "## ASGI‑серверы { #asgi-servers }\n\nДавайте немного углубимся в детали.\n\nFastAPI использует стандарт для построения Python‑веб‑фреймворков и серверов под названием <abbr title=\"Asynchronous Server Gateway Interface – Асинхронный шлюзовый интерфейс сервера\">ASGI</abbr>. FastAPI — ASGI-веб‑фреймворк.\n\nГлавное, что вам нужно, чтобы запустить приложение **FastAPI** (или любое другое ASGI‑приложение) на удалённой серверной машине, — это программа ASGI‑сервера, такая как **Uvicorn**; именно он используется по умолчанию в команде `fastapi`.\n\nЕсть несколько альтернатив, например:\n\n* <a href=\"https://www.uvicorn.dev/\" class=\"external-link\" target=\"_blank\">Uvicorn</a>: высокопроизводительный ASGI‑сервер.\n* <a href=\"https://hypercorn.readthedocs.io/\" class=\"external-link\" target=\"_blank\">Hypercorn</a>: ASGI‑сервер, среди прочего совместимый с HTTP/2 и Trio.\n* <a href=\"https://github.com/django/daphne\" class=\"external-link\" target=\"_blank\">Daphne</a>: ASGI‑сервер, созданный для Django Channels.\n* <a href=\"https://github.com/emmett-framework/granian\" class=\"external-link\" target=\"_blank\">Granian</a>: HTTP‑сервер на Rust для Python‑приложений.\n* <a href=\"https://unit.nginx.org/howto/fastapi/\" class=\"external-link\" target=\"_blank\">NGINX Unit</a>: NGINX Unit — лёгкая и многофункциональная среда выполнения веб‑приложений.\n\n", "metadata": {"title": "Запуск сервера вручную", "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "source_mtime": "2026-01-12T17:48:13.174557+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\manually.md"}, "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "title": "Запуск сервера вручную", "chunk_index": 3, "header": "ASGI‑серверы", "header_level": 2, "token_count": 474}
{"id": "f00ebd982e50f71b", "text": "## Сервер как машина и сервер как программа { #server-machine-and-server-program }\n\nЕсть небольшой нюанс в терминологии, о котором стоит помнить. \n\nСлово «сервер» обычно используют и для обозначения удалённого/облачного компьютера (физической или виртуальной машины), и для программы, работающей на этой машине (например, Uvicorn).\n\nИмейте в виду, что слово «сервер» в целом может означать любое из этих двух.\n\nКогда речь идёт об удалённой машине, её зачастую называют **сервер**, а также **машина**, **VM** (виртуальная машина), **нода**. Всё это — варианты названия удалённой машины, обычно под управлением Linux, на которой вы запускаете программы.\n\n", "metadata": {"title": "Запуск сервера вручную", "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "source_mtime": "2026-01-12T17:48:13.174557+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\manually.md"}, "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "title": "Запуск сервера вручную", "chunk_index": 4, "header": "Сервер как машина и сервер как программа", "header_level": 2, "token_count": 276}
{"id": "9c5a774a93125b71", "text": "## Установка серверной программы { #install-the-server-program }\n\nПри установке FastAPI он поставляется с продакшн‑сервером Uvicorn, и вы можете запустить его командой `fastapi run`.\n\nНо вы также можете установить ASGI‑сервер вручную.\n\nСоздайте [виртуальное окружение](../virtual-environments.md){.internal-link target=_blank}, активируйте его и затем установите серверное приложение.\n\nНапример, чтобы установить Uvicorn:\n\n<div class=\"termy\">\n\n```console\n$ pip install \"uvicorn[standard]\"\n\n---> 100%\n```\n\n</div>\n\nАналогично устанавливаются и другие ASGI‑серверы.\n\n/// tip | Совет\n\nС добавлением `standard` Uvicorn установит и будет использовать ряд рекомендованных дополнительных зависимостей.\n\nВ их числе `uvloop` — высокопроизводительная замена `asyncio`, дающая серьёзный прирост производительности при параллельной работе.\n\nЕсли вы устанавливаете FastAPI, например так: `pip install \"fastapi[standard]\"`, вы уже получаете и `uvicorn[standard]`.\n\n///\n\n", "metadata": {"title": "Запуск сервера вручную", "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "source_mtime": "2026-01-12T17:48:13.174557+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\manually.md"}, "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "title": "Запуск сервера вручную", "chunk_index": 5, "header": "Установка серверной программы", "header_level": 2, "token_count": 333}
{"id": "ea3b1d2c3cc88fb9", "text": "## Запуск серверной программы { #run-the-server-program }\n\nЕсли вы установили ASGI‑сервер вручную, обычно нужно передать строку импорта в специальном формате, чтобы он смог импортировать ваше приложение FastAPI:\n\n<div class=\"termy\">\n\n```console\n$ uvicorn main:app --host 0.0.0.0 --port 80\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://0.0.0.0:80 (Press CTRL+C to quit)\n```\n\n</div>\n\n/// note | Примечание\n\nКоманда `uvicorn main:app` означает:\n\n* `main`: файл `main.py` (Python‑«модуль»).\n* `app`: объект, созданный в `main.py` строкой `app = FastAPI()`.\n\nЭквивалентно:\n\n```Python\nfrom main import app\n```\n\n///\n\nУ каждого альтернативного ASGI‑сервера будет похожая команда; подробнее см. в их документации.\n\n/// warning | Предупреждение\n\nUvicorn и другие серверы поддерживают опцию `--reload`, полезную в период разработки.\n\nОпция `--reload` потребляет значительно больше ресурсов, менее стабильна и т.п.\n\nОна сильно помогает во время **разработки**, но в **продакшн** её использовать **не следует**.\n\n///\n\n", "metadata": {"title": "Запуск сервера вручную", "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "source_mtime": "2026-01-12T17:48:13.174557+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\manually.md"}, "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "title": "Запуск сервера вручную", "chunk_index": 6, "header": "Запуск серверной программы", "header_level": 2, "token_count": 386}
{"id": "fb7b6c27d98b1d3a", "text": "## Концепции развёртывания { #deployment-concepts }\n\nВ этих примерах серверная программа (например, Uvicorn) запускает **один процесс**, слушающий все IP‑адреса (`0.0.0.0`) на заранее заданном порту (например, `80`).\n\nЭто базовая идея. Но, вероятно, вам понадобится позаботиться и о некоторых дополнительных вещах, например:\n\n* Безопасность — HTTPS\n* Запуск при старте системы\n* Перезапуски\n* Репликация (количество запущенных процессов)\n* Память\n* Предварительные шаги перед запуском\n\nВ следующих главах я расскажу подробнее про каждую из этих концепций, о том, как о них думать, и приведу конкретные примеры со стратегиями, как с ними работать.\n", "metadata": {"title": "Запуск сервера вручную", "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "source_mtime": "2026-01-12T17:48:13.174557+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\manually.md"}, "doc_id": "4d06987ea65d", "source_path": "docs\\deployment\\manually.md", "title": "Запуск сервера вручную", "chunk_index": 7, "header": "Концепции развёртывания", "header_level": 2, "token_count": 283}
{"id": "b440b244f3348173", "text": "# Серверные воркеры — Uvicorn с воркерами { #server-workers-uvicorn-with-workers }\n\nДавайте снова вспомним те концепции деплоя, о которых говорили ранее:\n\n* Безопасность — HTTPS\n* Запуск при старте\n* Перезапуски\n* **Репликация (количество запущенных процессов)**\n* Память\n* Предварительные шаги перед запуском\n\nДо этого момента, следуя руководствам в документации, вы, вероятно, запускали **серверную программу**, например с помощью команды `fastapi`, которая запускает Uvicorn в **одном процессе**.\n\nПри деплое приложения вам, скорее всего, захочется использовать **репликацию процессов**, чтобы задействовать **несколько ядер** и иметь возможность обрабатывать больше запросов.\n\nКак вы видели в предыдущей главе о [Концепциях деплоя](concepts.md){.internal-link target=_blank}, существует несколько стратегий.\n\nЗдесь я покажу, как использовать **Uvicorn** с **воркер-процессами** через команду `fastapi` или напрямую через команду `uvicorn`.\n\n/// info | Информация\n\nЕсли вы используете контейнеры, например Docker или Kubernetes, я расскажу об этом подробнее в следующей главе: [FastAPI в контейнерах — Docker](docker.md){.internal-link target=_blank}.", "metadata": {"title": "Серверные воркеры — Uvicorn с воркерами", "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "source_mtime": "2026-01-12T17:48:13.179352+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\server-workers.md", "section_header": "Серверные воркеры — Uvicorn с воркерами", "section_header_level": 1}, "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "title": "Серверные воркеры — Uvicorn с воркерами", "chunk_index": 0, "header": "Серверные воркеры — Uvicorn с воркерами", "header_level": 1, "token_count": 449}
{"id": "f33dd32fda47a5ef", "text": "Если вы используете контейнеры, например Docker или Kubernetes, я расскажу об этом подробнее в следующей главе: [FastAPI в контейнерах — Docker](docker.md){.internal-link target=_blank}.\n\nВ частности, при запуске в **Kubernetes** вам, скорее всего, **не** понадобится использовать воркеры — вместо этого запускайте **один процесс Uvicorn на контейнер**, но об этом подробнее далее в той главе.\n\n///", "metadata": {"title": "Серверные воркеры — Uvicorn с воркерами", "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "source_mtime": "2026-01-12T17:48:13.179352+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\server-workers.md", "section_header": "Серверные воркеры — Uvicorn с воркерами", "section_header_level": 1}, "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "title": "Серверные воркеры — Uvicorn с воркерами", "chunk_index": 1, "header": "Серверные воркеры — Uvicorn с воркерами", "header_level": 1, "token_count": 150}
{"id": "b440b244f3348173", "text": "## Несколько воркеров { #multiple-workers }\n\nМожно запустить несколько воркеров с помощью опции командной строки `--workers`:\n\n//// tab | `fastapi`\n\nЕсли вы используете команду `fastapi`:\n\n<div class=\"termy\">\n\n```console\n$ <font color=\"#4E9A06\">fastapi</font> run --workers 4 <u style=\"text-decoration-style:solid\">main.py</u>\n\n  <span style=\"background-color:#009485\"><font color=\"#D3D7CF\"> FastAPI </font></span>  Starting production server 🚀\n\n             Searching for package file structure from directories with\n             <font color=\"#3465A4\">__init__.py</font> files\n             Importing from <font color=\"#75507B\">/home/user/code/</font><font color=\"#AD7FA8\">awesomeapp</font>\n\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> module </font></span>  🐍 main.py\n\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> code </font></span>  Importing the FastAPI app object from the module with the\n             following code:\n\n             <u style=\"text-decoration-style:solid\">from </u><u style=\"text-decoration-style:solid\"><b>main</b></u><u style=\"text-decoration-style:solid\"> import </u><u style=\"text-decoration-style:solid\"><b>app</b></u>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> app </font></span>  Using import string: <font color=\"#3465A4\">main:app</font>", "metadata": {"title": "Серверные воркеры — Uvicorn с воркерами", "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "source_mtime": "2026-01-12T17:48:13.179352+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\server-workers.md", "section_header": "Несколько воркеров", "section_header_level": 2}, "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "title": "Серверные воркеры — Uvicorn с воркерами", "chunk_index": 2, "header": "Несколько воркеров", "header_level": 2, "token_count": 392}
{"id": "f33dd32fda47a5ef", "text": "><u style=\"text-decoration-style:solid\"><b>app</b></u>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> app </font></span>  Using import string: <font color=\"#3465A4\">main:app</font>\n\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Server started at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://0.0.0.0:8000</u></font>\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Documentation at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://0.0.0.0:8000/docs</u></font>\n\n             Logs:", "metadata": {"title": "Серверные воркеры — Uvicorn с воркерами", "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "source_mtime": "2026-01-12T17:48:13.179352+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\server-workers.md", "section_header": "Несколько воркеров", "section_header_level": 2}, "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "title": "Серверные воркеры — Uvicorn с воркерами", "chunk_index": 3, "header": "Несколько воркеров", "header_level": 2, "token_count": 195}
{"id": "9163c58a30203c26", "text": "style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Documentation at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://0.0.0.0:8000/docs</u></font>\n\n             Logs:\n\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Uvicorn running on <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://0.0.0.0:8000</u></font> <b>(</b>Press CTRL+C to\n             quit<b>)</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started parent process <b>[</b><font color=\"#34E2E2\"><b>27365</b></font><b>]</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started server process <b>[</b><font color=\"#34E2E2\"><b>27368</b></font><b>]</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started server process <b>[</b><font color=\"#34E2E2\"><b>27369</b></font><b>]</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started server process <b>[</b><font color=\"#34E2E2\"><b>27370</b></font><b>]</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started server process <b>[</b><font color=\"#34E2E2\"><b>27367</b></font><b>]</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Waiting for application startup.\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Waiting for application startup.\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Waiting for application startup.\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Waiting for application startup.\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Application startup complete.\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Application startup complete.\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Application startup complete.\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Application startup complete.\n```", "metadata": {"title": "Серверные воркеры — Uvicorn с воркерами", "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "source_mtime": "2026-01-12T17:48:13.179352+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\server-workers.md", "section_header": "Несколько воркеров", "section_header_level": 2}, "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "title": "Серверные воркеры — Uvicorn с воркерами", "chunk_index": 4, "header": "Несколько воркеров", "header_level": 2, "token_count": 696}
{"id": "3d429107cccab6ac", "text": "<span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Application startup complete.\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Application startup complete.\n```\n\n</div>\n\n////\n\n//// tab | `uvicorn`\n\nЕсли вы предпочитаете использовать команду `uvicorn` напрямую:\n\n<div class=\"termy\">\n\n```console\n$ uvicorn main:app --host 0.0.0.0 --port 8080 --workers 4\n<font color=\"#A6E22E\">INFO</font>:     Uvicorn running on <b>http://0.0.0.0:8080</b> (Press CTRL+C to quit)\n<font color=\"#A6E22E\">INFO</font>:     Started parent process [<font color=\"#A1EFE4\"><b>27365</b></font>]\n<font color=\"#A6E22E\">INFO</font>:     Started server process [<font color=\"#A1EFE4\">27368</font>]\n<font color=\"#A6E22E\">INFO</font>:     Waiting for application startup.\n<font color=\"#A6E22E\">INFO</font>:     Application startup complete.\n<font color=\"#A6E22E\">INFO</font>:     Started server process [<font color=\"#A1EFE4\">27369</font>]\n<font color=\"#A6E22E\">INFO</font>:     Waiting for application startup.\n<font color=\"#A6E22E\">INFO</font>:     Application startup complete.\n<font color=\"#A6E22E\">INFO</font>:     Started server process [<font color=\"#A1EFE4\">27370</font>]\n<font color=\"#A6E22E\">INFO</font>:     Waiting for application startup.\n<font color=\"#A6E22E\">INFO</font>:     Application startup complete.\n<font color=\"#A6E22E\">INFO</font>:     Started server process [<font color=\"#A1EFE4\">27367</font>]\n<font color=\"#A6E22E\">INFO</font>:     Waiting for application startup.\n<font color=\"#A6E22E\">INFO</font>:     Application startup complete.\n```", "metadata": {"title": "Серверные воркеры — Uvicorn с воркерами", "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "source_mtime": "2026-01-12T17:48:13.179352+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\server-workers.md", "section_header": "Несколько воркеров", "section_header_level": 2}, "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "title": "Серверные воркеры — Uvicorn с воркерами", "chunk_index": 5, "header": "Несколько воркеров", "header_level": 2, "token_count": 509}
{"id": "6a62aaccb2ebedbc", "text": "</font>:     Started server process [<font color=\"#A1EFE4\">27367</font>]\n<font color=\"#A6E22E\">INFO</font>:     Waiting for application startup.\n<font color=\"#A6E22E\">INFO</font>:     Application startup complete.\n```\n\n</div>\n\n////\n\nЕдинственная новая опция здесь — `--workers`, она говорит Uvicorn запустить 4 воркер-процесса.\n\nТакже видно, что выводится **PID** каждого процесса: `27365` — для родительского процесса (это **менеджер процессов**) и по одному для каждого воркер-процесса: `27368`, `27369`, `27370` и `27367`.", "metadata": {"title": "Серверные воркеры — Uvicorn с воркерами", "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "source_mtime": "2026-01-12T17:48:13.179352+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\server-workers.md", "section_header": "Несколько воркеров", "section_header_level": 2}, "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "title": "Серверные воркеры — Uvicorn с воркерами", "chunk_index": 6, "header": "Несколько воркеров", "header_level": 2, "token_count": 196}
{"id": "346e66c8b03b84ab", "text": "## Концепции деплоя { #deployment-concepts }\n\nЗдесь вы увидели, как использовать несколько **воркеров**, чтобы **распараллелить** выполнение приложения, задействовать **несколько ядер** CPU и обслуживать **больше запросов**.\n\nИз списка концепций деплоя выше использование воркеров в основном помогает с **репликацией**, и немного — с **перезапусками**, но об остальных по-прежнему нужно позаботиться:\n\n* **Безопасность — HTTPS**\n* **Запуск при старте**\n* ***Перезапуски***\n* Репликация (количество запущенных процессов)\n* **Память**\n* **Предварительные шаги перед запуском**\n\n", "metadata": {"title": "Серверные воркеры — Uvicorn с воркерами", "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "source_mtime": "2026-01-12T17:48:13.179352+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\server-workers.md"}, "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "title": "Серверные воркеры — Uvicorn с воркерами", "chunk_index": 7, "header": "Концепции деплоя", "header_level": 2, "token_count": 229}
{"id": "b63fdedfe51fe05d", "text": "## Контейнеры и Docker { #containers-and-docker }\n\nВ следующей главе о [FastAPI в контейнерах — Docker](docker.md){.internal-link target=_blank} я объясню стратегии, которые можно использовать для решения остальных **концепций деплоя**.\n\nЯ покажу, как **собрать свой образ с нуля**, чтобы запускать один процесс Uvicorn. Это простой подход и, вероятно, именно то, что вам нужно при использовании распределённой системы управления контейнерами, такой как **Kubernetes**.\n\n", "metadata": {"title": "Серверные воркеры — Uvicorn с воркерами", "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "source_mtime": "2026-01-12T17:48:13.179352+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\server-workers.md"}, "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "title": "Серверные воркеры — Uvicorn с воркерами", "chunk_index": 8, "header": "Контейнеры и Docker", "header_level": 2, "token_count": 170}
{"id": "93b74fd474ff41ab", "text": "## Резюме { #recap }\n\nВы можете использовать несколько воркер-процессов с опцией командной строки `--workers` в командах `fastapi` или `uvicorn`, чтобы задействовать **многоядерные CPU**, запуская **несколько процессов параллельно**.\n\nВы можете использовать эти инструменты и идеи, если настраиваете **собственную систему деплоя** и самостоятельно закрываете остальные концепции деплоя.\n\nПерейдите к следующей главе, чтобы узнать о **FastAPI** в контейнерах (например, Docker и Kubernetes). Вы увидите, что эти инструменты тоже предлагают простые способы решить другие **концепции деплоя**.\n", "metadata": {"title": "Серверные воркеры — Uvicorn с воркерами", "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "source_mtime": "2026-01-12T17:48:13.179352+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\server-workers.md"}, "doc_id": "455456a7e1de", "source_path": "docs\\deployment\\server-workers.md", "title": "Серверные воркеры — Uvicorn с воркерами", "chunk_index": 9, "header": "Резюме", "header_level": 2, "token_count": 234}
{"id": "c3aeb28f18ee66cb", "text": "# О версиях FastAPI { #about-fastapi-versions }\n\n**FastAPI** уже используется в продакшене во многих приложениях и системах. Покрытие тестами поддерживается на уровне 100%. Но его разработка всё ещё движется быстрыми темпами.\n\nЧасто добавляются новые функции, регулярно исправляются баги, код продолжает постоянно совершенствоваться.\n\nПо указанным причинам текущие версии до сих пор `0.x.x`. Это говорит о том, что каждая версия может содержать обратно несовместимые изменения, следуя <a href=\"https://semver.org/\" class=\"external-link\" target=\"_blank\">Семантическому версионированию</a>.\n\nУже сейчас вы можете создавать приложения в продакшене, используя **FastAPI** (и скорее всего так и делаете), главное убедиться в том, что вы используете версию, которая корректно работает с вашим кодом.\n\n", "metadata": {"title": "О версиях FastAPI", "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "source_mtime": "2026-01-12T17:48:13.184551+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\versions.md"}, "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "title": "О версиях FastAPI", "chunk_index": 0, "header": "О версиях FastAPI", "header_level": 1, "token_count": 306}
{"id": "643af97bb7fb468f", "text": "## Закрепите вашу версию `fastapi` { #pin-your-fastapi-version }\n\nПервым делом вам следует \"закрепить\" конкретную последнюю используемую версию **FastAPI**, которая корректно работает с вашим приложением.\n\nНапример, в своём приложении вы используете версию `0.112.0`.\n\nЕсли вы используете файл `requirements.txt`, вы можете указать версию следующим способом:\n\n```txt\nfastapi[standard]==0.112.0\n```\n\nэто означает, что вы будете использовать именно версию `0.112.0`.\n\nИли вы можете закрепить версию следующим способом:\n\n```txt\nfastapi[standard]>=0.112.0,<0.113.0\n```\n\nэто значит, что вы используете версии `0.112.0` или выше, но меньше чем `0.113.0`. Например, версия `0.112.2` всё ещё будет подходить.\n\nЕсли вы используете любой другой инструмент для управления установками/зависимостями, например `uv`, Poetry, Pipenv или др., у них у всех имеется способ определения специфической версии для ваших пакетов.\n\n", "metadata": {"title": "О версиях FastAPI", "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "source_mtime": "2026-01-12T17:48:13.184551+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\versions.md"}, "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "title": "О версиях FastAPI", "chunk_index": 1, "header": "Закрепите вашу версию `fastapi`", "header_level": 2, "token_count": 363}
{"id": "7ef51884751ac88b", "text": "## Доступные версии { #available-versions }\n\nВы можете посмотреть доступные версии (например, проверить последнюю на данный момент) в [Примечаниях к выпуску](../release-notes.md){.internal-link target=_blank}.\n\n", "metadata": {"title": "О версиях FastAPI", "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "source_mtime": "2026-01-12T17:48:13.184551+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\versions.md"}, "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "title": "О версиях FastAPI", "chunk_index": 2, "header": "Доступные версии", "header_level": 2, "token_count": 71}
{"id": "97e2bec8708d8039", "text": "## О версиях { #about-versions }\n\nСледуя соглашению о Семантическом Версионировании, любые версии ниже `1.0.0` потенциально могут добавить обратно несовместимые изменения.\n\nFastAPI следует соглашению в том, что любые изменения \"ПАТЧ\"-версии предназначены для исправления багов и внесения обратно совместимых изменений.\n\n/// tip | Подсказка\n\n\"ПАТЧ\" — это последнее число. Например, в `0.2.3`, ПАТЧ-версия — это `3`.\n\n///\n\nИтак, вы можете закрепить версию следующим образом:\n\n```txt\nfastapi>=0.45.0,<0.46.0\n```\n\nОбратно несовместимые изменения и новые функции добавляются в \"МИНОРНЫЕ\" версии.\n\n/// tip | Подсказка\n\n\"МИНОРНАЯ\" версия — это число в середине. Например, в `0.2.3` МИНОРНАЯ версия — это `2`.\n\n///\n\n", "metadata": {"title": "О версиях FastAPI", "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "source_mtime": "2026-01-12T17:48:13.184551+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\versions.md"}, "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "title": "О версиях FastAPI", "chunk_index": 3, "header": "О версиях", "header_level": 2, "token_count": 327}
{"id": "4d9ed02d95e06162", "text": "## Обновление версий FastAPI { #upgrading-the-fastapi-versions }\n\nВам следует добавить тесты для вашего приложения.\n\nС помощью **FastAPI** это очень просто (благодаря Starlette), см. документацию: [Тестирование](../tutorial/testing.md){.internal-link target=_blank}\n\nПосле создания тестов вы можете обновить свою версию **FastAPI** до более новой. После этого следует убедиться, что ваш код работает корректно, запустив тесты.\n\nЕсли всё работает корректно, или после внесения необходимых изменений все ваши тесты проходят, только тогда вы можете закрепить вашу новую версию `fastapi`.\n\n", "metadata": {"title": "О версиях FastAPI", "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "source_mtime": "2026-01-12T17:48:13.184551+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\versions.md"}, "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "title": "О версиях FastAPI", "chunk_index": 4, "header": "Обновление версий FastAPI", "header_level": 2, "token_count": 206}
{"id": "52c284e23921e03f", "text": "## О Starlette { #about-starlette }\n\nНе следует закреплять версию `starlette`.\n\nРазные версии **FastAPI** будут использовать более новые версии Starlette.\n\nТак что решение об используемой версии Starlette, вы можете оставить **FastAPI**.\n\n", "metadata": {"title": "О версиях FastAPI", "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "source_mtime": "2026-01-12T17:48:13.184551+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\versions.md"}, "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "title": "О версиях FastAPI", "chunk_index": 5, "header": "О Starlette", "header_level": 2, "token_count": 79}
{"id": "fbccb2087bcb6b27", "text": "## О Pydantic { #about-pydantic }\n\nPydantic включает свои собственные тесты для **FastAPI**, так что новые версии Pydantic (выше `1.0.0`) всегда совместимы с FastAPI.\n\nВы можете закрепить любую версию Pydantic, которая вам подходит, выше `1.0.0`.\n\nНапример:\n\n```txt\npydantic>=2.7.0,<3.0.0\n```\n", "metadata": {"title": "О версиях FastAPI", "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "source_mtime": "2026-01-12T17:48:13.184551+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\deployment\\versions.md"}, "doc_id": "db5fc8b08a07", "source_path": "docs\\deployment\\versions.md", "title": "О версиях FastAPI", "chunk_index": 6, "header": "О Pydantic", "header_level": 2, "token_count": 129}
{"id": "d7608a6098c5f6cc", "text": "# Использование старых статус-кодов ошибок аутентификации 403 { #use-old-403-authentication-error-status-codes }\n\nДо версии FastAPI `0.122.0`, когда встроенные утилиты безопасности возвращали ошибку клиенту после неудачной аутентификации, они использовали HTTP статус-код `403 Forbidden`.\n\nНачиная с версии FastAPI `0.122.0`, используется более подходящий HTTP статус-код `401 Unauthorized`, и в ответе возвращается имеющий смысл HTTP-заголовок `WWW-Authenticate` в соответствии со спецификациями HTTP, <a href=\"https://datatracker.ietf.org/doc/html/rfc7235#section-3.1\" class=\"external-link\" target=\"_blank\">RFC 7235</a>, <a href=\"https://datatracker.ietf.org/doc/html/rfc9110#name-401-unauthorized\" class=\"external-link\" target=\"_blank\">RFC 9110</a>.\n\nНо если по какой-то причине ваши клиенты зависят от старого поведения, вы можете вернуть его, переопределив метод `make_not_authenticated_error` в ваших Security-классах.\n\nНапример, вы можете создать подкласс `HTTPBearer`, который будет возвращать ошибку `403 Forbidden` вместо стандартной `401 Unauthorized`:\n\n{* ../../docs_src/authentication_error_status_code/tutorial001_an_py39.py hl[9:13] *}\n\n/// tip | Совет\n\nОбратите внимание, что функция возвращает экземпляр исключения, не вызывает его. Выброс выполняется остальным внутренним кодом.\n\n///\n", "metadata": {"title": "Использование старых статус-кодов ошибок аутентификации 403", "doc_id": "455f0d6e760e", "source_path": "docs\\how-to\\authentication-error-status-code.md", "source_mtime": "2026-01-12T17:48:13.197563+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\authentication-error-status-code.md"}, "doc_id": "455f0d6e760e", "source_path": "docs\\how-to\\authentication-error-status-code.md", "title": "Использование старых статус-кодов ошибок аутентификации 403", "chunk_index": 0, "header": "Использование старых статус-кодов ошибок аутентификации 403", "header_level": 1, "token_count": 452}
{"id": "3ac92173375bcad2", "text": "# Условный OpenAPI { #conditional-openapi }\n\nПри необходимости вы можете использовать настройки и переменные окружения, чтобы условно настраивать OpenAPI в зависимости от окружения и даже полностью его отключать.\n\n", "metadata": {"title": "Условный OpenAPI", "doc_id": "3a1d43c2174e", "source_path": "docs\\how-to\\conditional-openapi.md", "source_mtime": "2026-01-12T17:48:13.198842+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\conditional-openapi.md"}, "doc_id": "3a1d43c2174e", "source_path": "docs\\how-to\\conditional-openapi.md", "title": "Условный OpenAPI", "chunk_index": 0, "header": "Условный OpenAPI", "header_level": 1, "token_count": 67}
{"id": "3ac92173375bcad2", "text": "## О безопасности, API и документации { #about-security-apis-and-docs }\n\nСкрытие пользовательских интерфейсов документации в продакшн *не должно* быть способом защиты вашего API.\n\nЭто не добавляет дополнительной безопасности вашему API, *операции пути* (обработчики пути) всё равно будут доступны по своим путям.\n\nЕсли в вашем коде есть уязвимость, она всё равно останется.\n\nСокрытие документации лишь усложняет понимание того, как взаимодействовать с вашим API, и может усложнить его отладку в продакшн. Это можно считать просто разновидностью <a href=\"https://en.wikipedia.org/wiki/Security_through_obscurity\" class=\"external-link\" target=\"_blank\">безопасности через сокрытие</a>.\n\nЕсли вы хотите обезопасить свой API, есть несколько более эффективных вещей, которые можно сделать, например:\n\n* Убедитесь, что у вас чётко определены Pydantic-модели для тел запросов и ответов.\n* Настройте необходимые разрешения и роли с помощью зависимостей.\n* Никогда не храните пароли в открытом виде, только хэши паролей.\n* Реализуйте и используйте известные криптографические инструменты, например pwdlib и JWT-токены, и т.д.\n* Добавьте более тонкое управление доступом с помощью OAuth2 scopes (областей) там, где это необходимо.\n* ...и т.п.", "metadata": {"title": "Условный OpenAPI", "doc_id": "3a1d43c2174e", "source_path": "docs\\how-to\\conditional-openapi.md", "source_mtime": "2026-01-12T17:48:13.198842+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\conditional-openapi.md", "section_header": "О безопасности, API и документации", "section_header_level": 2}, "doc_id": "3a1d43c2174e", "source_path": "docs\\how-to\\conditional-openapi.md", "title": "Условный OpenAPI", "chunk_index": 1, "header": "О безопасности, API и документации", "header_level": 2, "token_count": 472}
{"id": "96898f1e16dd9546", "text": "например pwdlib и JWT-токены, и т.д.\n* Добавьте более тонкое управление доступом с помощью OAuth2 scopes (областей) там, где это необходимо.\n* ...и т.п.\n\nТем не менее, у вас может быть очень специфичный случай использования, когда действительно нужно отключить документацию API для некоторых окружений (например, в продакшн) или в зависимости от настроек из переменных окружения.", "metadata": {"title": "Условный OpenAPI", "doc_id": "3a1d43c2174e", "source_path": "docs\\how-to\\conditional-openapi.md", "source_mtime": "2026-01-12T17:48:13.198842+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\conditional-openapi.md", "section_header": "О безопасности, API и документации", "section_header_level": 2}, "doc_id": "3a1d43c2174e", "source_path": "docs\\how-to\\conditional-openapi.md", "title": "Условный OpenAPI", "chunk_index": 2, "header": "О безопасности, API и документации", "header_level": 2, "token_count": 146}
{"id": "3b7693dc981d8646", "text": "## Условный OpenAPI из настроек и переменных окружения { #conditional-openapi-from-settings-and-env-vars }\n\nВы можете легко использовать те же настройки Pydantic, чтобы настроить сгенерированный OpenAPI и интерфейсы документации.\n\nНапример:\n\n{* ../../docs_src/conditional_openapi/tutorial001_py39.py hl[6,11] *}\n\nЗдесь мы объявляем настройку `openapi_url` с тем же значением по умолчанию — `\"/openapi.json\"`.\n\nЗатем используем её при создании приложения FastAPI.\n\nДалее вы можете отключить OpenAPI (включая интерфейсы документации), установив переменную окружения `OPENAPI_URL` в пустую строку, например:\n\n<div class=\"termy\">\n\n```console\n$ OPENAPI_URL= uvicorn main:app\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n</div>\n\nПосле этого, если перейти по адресам `/openapi.json`, `/docs` или `/redoc`, вы получите ошибку `404 Not Found`, например:\n\n```JSON\n{\n    \"detail\": \"Not Found\"\n}\n```\n", "metadata": {"title": "Условный OpenAPI", "doc_id": "3a1d43c2174e", "source_path": "docs\\how-to\\conditional-openapi.md", "source_mtime": "2026-01-12T17:48:13.198842+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\conditional-openapi.md"}, "doc_id": "3a1d43c2174e", "source_path": "docs\\how-to\\conditional-openapi.md", "title": "Условный OpenAPI", "chunk_index": 3, "header": "Условный OpenAPI из настроек и переменных окружения", "header_level": 2, "token_count": 318}
{"id": "ffd916e49a213bac", "text": "# Настройка Swagger UI { #configure-swagger-ui }\n\nВы можете настроить дополнительные <a href=\"https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/\" class=\"external-link\" target=\"_blank\">параметры Swagger UI</a>.\n\nЧтобы настроить их, передайте аргумент `swagger_ui_parameters` при создании объекта приложения `FastAPI()` или в функцию `get_swagger_ui_html()`.\n\n`swagger_ui_parameters` принимает словарь с настройками, которые передаются в Swagger UI напрямую.\n\nFastAPI преобразует эти настройки в **JSON**, чтобы они были совместимы с JavaScript, поскольку именно это требуется Swagger UI.\n\n", "metadata": {"title": "Настройка Swagger UI", "doc_id": "2261dce16c61", "source_path": "docs\\how-to\\configure-swagger-ui.md", "source_mtime": "2026-01-12T17:48:13.208490+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\configure-swagger-ui.md"}, "doc_id": "2261dce16c61", "source_path": "docs\\how-to\\configure-swagger-ui.md", "title": "Настройка Swagger UI", "chunk_index": 0, "header": "Настройка Swagger UI", "header_level": 1, "token_count": 185}
{"id": "d2fb2bf562de4550", "text": "## Отключить подсветку синтаксиса { #disable-syntax-highlighting }\n\nНапример, вы можете отключить подсветку синтаксиса в Swagger UI.\n\nБез изменения настроек подсветка синтаксиса включена по умолчанию:\n\n<img src=\"/img/tutorial/extending-openapi/image02.png\">\n\nНо вы можете отключить её, установив `syntaxHighlight` в `False`:\n\n{* ../../docs_src/configure_swagger_ui/tutorial001_py39.py hl[3] *}\n\n…и после этого Swagger UI больше не будет показывать подсветку синтаксиса:\n\n<img src=\"/img/tutorial/extending-openapi/image03.png\">\n\n", "metadata": {"title": "Настройка Swagger UI", "doc_id": "2261dce16c61", "source_path": "docs\\how-to\\configure-swagger-ui.md", "source_mtime": "2026-01-12T17:48:13.208490+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\configure-swagger-ui.md"}, "doc_id": "2261dce16c61", "source_path": "docs\\how-to\\configure-swagger-ui.md", "title": "Настройка Swagger UI", "chunk_index": 1, "header": "Отключить подсветку синтаксиса", "header_level": 2, "token_count": 170}
{"id": "7ff8908dc2cc25ce", "text": "## Изменить тему { #change-the-theme }\n\nАналогично вы можете задать тему подсветки синтаксиса с ключом \"syntaxHighlight.theme\" (обратите внимание, что посередине стоит точка):\n\n{* ../../docs_src/configure_swagger_ui/tutorial002_py39.py hl[3] *}\n\nЭта настройка изменит цветовую тему подсветки синтаксиса:\n\n<img src=\"/img/tutorial/extending-openapi/image04.png\">\n\n", "metadata": {"title": "Настройка Swagger UI", "doc_id": "2261dce16c61", "source_path": "docs\\how-to\\configure-swagger-ui.md", "source_mtime": "2026-01-12T17:48:13.208490+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\configure-swagger-ui.md"}, "doc_id": "2261dce16c61", "source_path": "docs\\how-to\\configure-swagger-ui.md", "title": "Настройка Swagger UI", "chunk_index": 2, "header": "Изменить тему", "header_level": 2, "token_count": 125}
{"id": "9b0f9a679723a27c", "text": "## Изменить параметры Swagger UI по умолчанию { #change-default-swagger-ui-parameters }\n\nFastAPI включает некоторые параметры конфигурации по умолчанию, подходящие для большинства случаев.\n\nЭто включает следующие настройки по умолчанию:\n\n{* ../../fastapi/openapi/docs.py ln[9:24] hl[18:24] *}\n\nВы можете переопределить любую из них, указав другое значение в аргументе `swagger_ui_parameters`.\n\nНапример, чтобы отключить `deepLinking`, можно передать такие настройки в `swagger_ui_parameters`:\n\n{* ../../docs_src/configure_swagger_ui/tutorial003_py39.py hl[3] *}\n\n", "metadata": {"title": "Настройка Swagger UI", "doc_id": "2261dce16c61", "source_path": "docs\\how-to\\configure-swagger-ui.md", "source_mtime": "2026-01-12T17:48:13.208490+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\configure-swagger-ui.md"}, "doc_id": "2261dce16c61", "source_path": "docs\\how-to\\configure-swagger-ui.md", "title": "Настройка Swagger UI", "chunk_index": 3, "header": "Изменить параметры Swagger UI по умолчанию", "header_level": 2, "token_count": 180}
{"id": "94dc64f7c36ecab3", "text": "## Другие параметры Swagger UI { #other-swagger-ui-parameters }\n\nЧтобы увидеть все остальные возможные настройки, прочитайте официальную <a href=\"https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/\" class=\"external-link\" target=\"_blank\">документацию по параметрам Swagger UI</a>.\n\n", "metadata": {"title": "Настройка Swagger UI", "doc_id": "2261dce16c61", "source_path": "docs\\how-to\\configure-swagger-ui.md", "source_mtime": "2026-01-12T17:48:13.208490+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\configure-swagger-ui.md"}, "doc_id": "2261dce16c61", "source_path": "docs\\how-to\\configure-swagger-ui.md", "title": "Настройка Swagger UI", "chunk_index": 4, "header": "Другие параметры Swagger UI", "header_level": 2, "token_count": 87}
{"id": "2ac461869a37f8dd", "text": "## Настройки только для JavaScript { #javascript-only-settings }\n\nSwagger UI также допускает другие настройки, которые являются **чисто JavaScript-объектами** (например, JavaScript-функциями).\n\nFastAPI также включает следующие настройки `presets` (только для JavaScript):\n\n```JavaScript\npresets: [\n    SwaggerUIBundle.presets.apis,\n    SwaggerUIBundle.SwaggerUIStandalonePreset\n]\n```\n\nЭто объекты **JavaScript**, а не строки, поэтому напрямую передать их из Python-кода нельзя.\n\nЕсли вам нужны такие настройки только для JavaScript, используйте один из методов выше. Переопределите *операцию пути* Swagger UI и вручную напишите любой необходимый JavaScript.\n", "metadata": {"title": "Настройка Swagger UI", "doc_id": "2261dce16c61", "source_path": "docs\\how-to\\configure-swagger-ui.md", "source_mtime": "2026-01-12T17:48:13.208490+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\configure-swagger-ui.md"}, "doc_id": "2261dce16c61", "source_path": "docs\\how-to\\configure-swagger-ui.md", "title": "Настройка Swagger UI", "chunk_index": 5, "header": "Настройки только для JavaScript", "header_level": 2, "token_count": 209}
{"id": "6e04c40b5038cbca", "text": "# Свои статические ресурсы UI документации (самостоятельный хостинг) { #custom-docs-ui-static-assets-self-hosting }\n\nДокументация API использует **Swagger UI** и **ReDoc**, и для каждого из них нужны некоторые файлы JavaScript и CSS.\n\nПо умолчанию эти файлы отдаются с <abbr title=\"Content Delivery Network – Сеть доставки контента: Сервис, обычно состоящий из нескольких серверов, который предоставляет статические файлы, такие как JavaScript и CSS. Обычно используется, чтобы отдавать эти файлы с сервера, расположенного ближе к клиенту, что улучшает производительность.\">CDN</abbr>.\n\nНо это можно настроить: вы можете указать конкретный CDN или отдавать файлы самостоятельно.\n\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 0, "header": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "header_level": 1, "token_count": 240}
{"id": "f784718168d36db8", "text": "## Пользовательский CDN для JavaScript и CSS { #custom-cdn-for-javascript-and-css }\n\nДопустим, вы хотите использовать другой <abbr title=\"Content Delivery Network – Сеть доставки контента\">CDN</abbr>, например `https://unpkg.com/`.\n\nЭто может быть полезно, если, например, вы живёте в стране, где некоторые URL ограничены.\n\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 1, "header": "Пользовательский CDN для JavaScript и CSS", "header_level": 2, "token_count": 106}
{"id": "2e0c193a8a707dc0", "text": "### Отключить автоматическую документацию { #disable-the-automatic-docs }\n\nПервый шаг — отключить автоматическую документацию, так как по умолчанию она использует стандартный CDN.\n\nЧтобы отключить её, установите их URL в значение `None` при создании вашего приложения `FastAPI`:\n\n{* ../../docs_src/custom_docs_ui/tutorial001_py39.py hl[8] *}\n\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 2, "header": "Отключить автоматическую документацию", "header_level": 3, "token_count": 112}
{"id": "dc08506d458ff86f", "text": "### Подключить пользовательскую документацию { #include-the-custom-docs }\n\nТеперь вы можете создать *операции пути* для пользовательской документации.\n\nВы можете переиспользовать внутренние функции FastAPI для создания HTML-страниц документации и передать им необходимые аргументы:\n\n* `openapi_url`: URL, по которому HTML-страница документации сможет получить схему OpenAPI для вашего API. Здесь можно использовать атрибут `app.openapi_url`.\n* `title`: заголовок вашего API.\n* `oauth2_redirect_url`: здесь можно использовать `app.swagger_ui_oauth2_redirect_url`, чтобы оставить значение по умолчанию.\n* `swagger_js_url`: URL, по которому HTML для документации Swagger UI сможет получить файл **JavaScript**. Это URL вашего пользовательского CDN.\n* `swagger_css_url`: URL, по которому HTML для документации Swagger UI сможет получить файл **CSS**. Это URL вашего пользовательского CDN.\n\nАналогично и для ReDoc...\n\n{* ../../docs_src/custom_docs_ui/tutorial001_py39.py hl[2:6,11:19,22:24,27:33] *}\n\n/// tip | Совет\n\n*Операция пути* для `swagger_ui_redirect` — это вспомогательный эндпоинт на случай, когда вы используете OAuth2.\n\nЕсли вы интегрируете свой API с провайдером OAuth2, вы сможете аутентифицироваться и вернуться к документации API с полученными учётными данными, а затем взаимодействовать с ним, используя реальную аутентификацию OAuth2.\n\nSwagger UI сделает это за вас «за кулисами», но для этого ему нужен этот вспомогательный «redirect» эндпоинт.\n\n///\n\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 3, "header": "Подключить пользовательскую документацию", "header_level": 3, "token_count": 495}
{"id": "2bdcf59148b10dad", "text": "### Создайте *операцию пути*, чтобы проверить { #create-a-path-operation-to-test-it }\n\nЧтобы убедиться, что всё работает, создайте *операцию пути*:\n\n{* ../../docs_src/custom_docs_ui/tutorial001_py39.py hl[36:38] *}\n\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 4, "header": "Создайте *операцию пути*, чтобы проверить", "header_level": 3, "token_count": 73}
{"id": "354dc21111c5af76", "text": "### Тестирование { #test-it }\n\nТеперь вы должны иметь возможность открыть свою документацию по адресу <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a> и перезагрузить страницу — «ассеты» (статические файлы) будут загружаться с нового CDN.\n\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 5, "header": "Тестирование", "header_level": 3, "token_count": 113}
{"id": "34efd3845bb82741", "text": "## Самостоятельный хостинг JavaScript и CSS для документации { #self-hosting-javascript-and-css-for-docs }\n\nСамостоятельный хостинг JavaScript и CSS может быть полезен, если, например, вам нужно, чтобы приложение продолжало работать в офлайне, без доступа к открытому Интернету, или в локальной сети.\n\nЗдесь вы увидите, как отдавать эти файлы самостоятельно, в том же приложении FastAPI, и настроить документацию на их использование.\n\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 6, "header": "Самостоятельный хостинг JavaScript и CSS для документации", "header_level": 2, "token_count": 156}
{"id": "330bacec3b75a471", "text": "### Структура файлов проекта { #project-file-structure }\n\nДопустим, структура файлов вашего проекта выглядит так:\n\n```\n.\n├── app\n│   ├── __init__.py\n│   ├── main.py\n```\n\nТеперь создайте директорию для хранения этих статических файлов.\n\nНовая структура файлов может выглядеть так:\n\n```\n.\n├── app\n│   ├── __init__.py\n│   ├── main.py\n└── static/\n```\n\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 7, "header": "Структура файлов проекта", "header_level": 3, "token_count": 140}
{"id": "3db568ee0023f1a4", "text": "### Скачайте файлы { #download-the-files }\n\nСкачайте статические файлы, необходимые для документации, и поместите их в директорию `static/`.\n\nСкорее всего, вы можете кликнуть правой кнопкой на каждой ссылке и выбрать что-то вроде «Сохранить ссылку как...».\n\n**Swagger UI** использует файлы:\n\n* <a href=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js\" class=\"external-link\" target=\"_blank\">`swagger-ui-bundle.js`</a>\n* <a href=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css\" class=\"external-link\" target=\"_blank\">`swagger-ui.css`</a>\n\nА **ReDoc** использует файл:\n\n* <a href=\"https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js\" class=\"external-link\" target=\"_blank\">`redoc.standalone.js`</a>\n\nПосле этого структура файлов может выглядеть так:\n\n```\n.\n├── app\n│   ├── __init__.py\n│   ├── main.py\n└── static\n    ├── redoc.standalone.js\n    ├── swagger-ui-bundle.js\n    └── swagger-ui.css\n```\n\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 8, "header": "Скачайте файлы", "header_level": 3, "token_count": 310}
{"id": "ce7a679337972617", "text": "### Предоставьте доступ к статическим файлам { #serve-the-static-files }\n\n* Импортируйте `StaticFiles`.\n* Смонтируйте экземпляр `StaticFiles()` в определённый путь.\n\n{* ../../docs_src/custom_docs_ui/tutorial002_py39.py hl[7,11] *}\n\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 9, "header": "Предоставьте доступ к статическим файлам", "header_level": 3, "token_count": 82}
{"id": "7cd7883df4f1407d", "text": "### Протестируйте статические файлы { #test-the-static-files }\n\nЗапустите своё приложение и откройте <a href=\"http://127.0.0.1:8000/static/redoc.standalone.js\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/static/redoc.standalone.js</a>.\n\nВы должны увидеть очень длинный JavaScript-файл для **ReDoc**.\n\nОн может начинаться примерно так:\n\n```JavaScript\n/*! For license information please see redoc.standalone.js.LICENSE.txt */\n!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t(require(\"null\")):\n...\n```\n\nЭто подтверждает, что ваше приложение умеет отдавать статические файлы и что вы поместили файлы документации в нужное место.\n\nТеперь можно настроить приложение так, чтобы документация использовала эти статические файлы.\n\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 10, "header": "Протестируйте статические файлы", "header_level": 3, "token_count": 252}
{"id": "7599e11528311444", "text": "### Отключить автоматическую документацию для статических файлов { #disable-the-automatic-docs-for-static-files }\n\nТак же, как и при использовании пользовательского CDN, первым шагом будет отключение автоматической документации, так как по умолчанию она использует CDN.\n\nЧтобы отключить её, установите их URL в значение `None` при создании вашего приложения `FastAPI`:\n\n{* ../../docs_src/custom_docs_ui/tutorial002_py39.py hl[9] *}\n\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 11, "header": "Отключить автоматическую документацию для статических файлов", "header_level": 3, "token_count": 136}
{"id": "6e04c40b5038cbca", "text": "### Подключить пользовательскую документацию со статическими файлами { #include-the-custom-docs-for-static-files }\n\nАналогично пользовательскому CDN, теперь вы можете создать *операции пути* для собственной документации.\n\nСнова можно переиспользовать внутренние функции FastAPI для создания HTML-страниц документации и передать им необходимые аргументы:\n\n* `openapi_url`: URL, по которому HTML-страница документации сможет получить схему OpenAPI для вашего API. Здесь можно использовать атрибут `app.openapi_url`.\n* `title`: заголовок вашего API.\n* `oauth2_redirect_url`: здесь можно использовать `app.swagger_ui_oauth2_redirect_url`, чтобы оставить значение по умолчанию.\n* `swagger_js_url`: URL, по которому HTML для документации Swagger UI сможет получить файл **JavaScript**. **Это тот файл, который теперь отдаёт ваше собственное приложение**.\n* `swagger_css_url`: URL, по которому HTML для документации Swagger UI сможет получить файл **CSS**. **Это тот файл, который теперь отдаёт ваше собственное приложение**.\n\nАналогично и для ReDoc...\n\n{* ../../docs_src/custom_docs_ui/tutorial002_py39.py hl[2:6,14:22,25:27,30:36] *}\n\n/// tip | Совет\n\n*Операция пути* для `swagger_ui_redirect` — это вспомогательный эндпоинт на случай, когда вы используете OAuth2.\n\nЕсли вы интегрируете свой API с провайдером OAuth2, вы сможете аутентифицироваться и вернуться к документации API с полученными учётными данными, а затем взаимодействовать с ним, используя реальную аутентификацию OAuth2.", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md", "section_header": "Подключить пользовательскую документацию со статическими файлами", "section_header_level": 3}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 12, "header": "Подключить пользовательскую документацию со статическими файлами", "header_level": 3, "token_count": 507}
{"id": "f784718168d36db8", "text": "утентифицироваться и вернуться к документации API с полученными учётными данными, а затем взаимодействовать с ним, используя реальную аутентификацию OAuth2.\n\nSwagger UI сделает это за вас «за кулисами», но для этого ему нужен этот вспомогательный «redirect» эндпоинт.\n\n///", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md", "section_header": "Подключить пользовательскую документацию со статическими файлами", "section_header_level": 3}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 13, "header": "Подключить пользовательскую документацию со статическими файлами", "header_level": 3, "token_count": 112}
{"id": "723ae5a9a7a3e349", "text": "### Создайте *операцию пути* для теста статических файлов { #create-a-path-operation-to-test-static-files }\n\nЧтобы убедиться, что всё работает, создайте *операцию пути*:\n\n{* ../../docs_src/custom_docs_ui/tutorial002_py39.py hl[39:41] *}\n\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 14, "header": "Создайте *операцию пути* для теста статических файлов", "header_level": 3, "token_count": 82}
{"id": "9c81f3223d3bb5a1", "text": "### Тестирование UI со статическими файлами { #test-static-files-ui }\n\nТеперь вы можете отключить Wi‑Fi, открыть свою документацию по адресу <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a> и перезагрузить страницу.\n\nДаже без Интернета вы сможете видеть документацию к своему API и взаимодействовать с ним.\n", "metadata": {"title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "source_mtime": "2026-01-12T17:48:13.213552+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-docs-ui-assets.md"}, "doc_id": "5bdaf6728af7", "source_path": "docs\\how-to\\custom-docs-ui-assets.md", "title": "Свои статические ресурсы UI документации (самостоятельный хостинг)", "chunk_index": 15, "header": "Тестирование UI со статическими файлами", "header_level": 3, "token_count": 142}
{"id": "0af13efa86d09466", "text": "# Пользовательские классы Request и APIRoute { #custom-request-and-apiroute-class }\n\nВ некоторых случаях может понадобиться переопределить логику, используемую классами `Request` и `APIRoute`.\n\nВ частности, это может быть хорошей альтернативой логике в middleware.\n\nНапример, если вы хотите прочитать или изменить тело запроса до того, как оно будет обработано вашим приложением.\n\n/// danger | Опасность\n\nЭто «продвинутая» возможность.\n\nЕсли вы только начинаете работать с **FastAPI**, возможно, стоит пропустить этот раздел.\n\n///\n\n", "metadata": {"title": "Пользовательские классы Request и APIRoute", "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "source_mtime": "2026-01-12T17:48:13.218799+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-request-and-route.md"}, "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "title": "Пользовательские классы Request и APIRoute", "chunk_index": 0, "header": "Пользовательские классы Request и APIRoute", "header_level": 1, "token_count": 184}
{"id": "7abf76aab0642015", "text": "## Сценарии использования { #use-cases }\n\nНекоторые сценарии:\n\n* Преобразование тел запросов, не в формате JSON, в JSON (например, <a href=\"https://msgpack.org/index.html\" class=\"external-link\" target=\"_blank\">`msgpack`</a>).\n* Распаковка тел запросов, сжатых с помощью gzip.\n* Автоматическое логирование всех тел запросов.\n\n", "metadata": {"title": "Пользовательские классы Request и APIRoute", "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "source_mtime": "2026-01-12T17:48:13.218799+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-request-and-route.md"}, "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "title": "Пользовательские классы Request и APIRoute", "chunk_index": 1, "header": "Сценарии использования", "header_level": 2, "token_count": 120}
{"id": "4140197d04c545f4", "text": "## Обработка пользовательского кодирования тела запроса { #handling-custom-request-body-encodings }\n\nПосмотрим как использовать пользовательский подкласс `Request` для распаковки gzip-запросов.\n\nИ подкласс `APIRoute`, чтобы использовать этот пользовательский класс запроса.\n\n", "metadata": {"title": "Пользовательские классы Request и APIRoute", "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "source_mtime": "2026-01-12T17:48:13.218799+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-request-and-route.md"}, "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "title": "Пользовательские классы Request и APIRoute", "chunk_index": 2, "header": "Обработка пользовательского кодирования тела запроса", "header_level": 2, "token_count": 79}
{"id": "ca249aeabfcf908d", "text": "### Создать пользовательский класс `GzipRequest` { #create-a-custom-gziprequest-class }\n\n/// tip | Совет\n\nЭто учебный пример, демонстрирующий принцип работы. Если вам нужна поддержка Gzip, вы можете использовать готовый [`GzipMiddleware`](../advanced/middleware.md#gzipmiddleware){.internal-link target=_blank}.\n\n///\n\nСначала создадим класс `GzipRequest`, который переопределит метод `Request.body()` и распакует тело запроса при наличии соответствующего HTTP-заголовка.\n\nЕсли в заголовке нет `gzip`, он не будет пытаться распаковывать тело.\n\nТаким образом, один и тот же класс маршрута сможет обрабатывать как gzip-сжатые, так и несжатые запросы.\n\n{* ../../docs_src/custom_request_and_route/tutorial001_an_py310.py hl[9:16] *}\n\n", "metadata": {"title": "Пользовательские классы Request и APIRoute", "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "source_mtime": "2026-01-12T17:48:13.218799+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-request-and-route.md"}, "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "title": "Пользовательские классы Request и APIRoute", "chunk_index": 3, "header": "Создать пользовательский класс `GzipRequest`", "header_level": 3, "token_count": 242}
{"id": "0af13efa86d09466", "text": "### Создать пользовательский класс `GzipRoute` { #create-a-custom-gziproute-class }\n\nДалее создадим пользовательский подкласс `fastapi.routing.APIRoute`, который будет использовать `GzipRequest`.\n\nНа этот раз он переопределит метод `APIRoute.get_route_handler()`.\n\nЭтот метод возвращает функцию. Именно эта функция получает HTTP-запрос и возвращает HTTP-ответ.\n\nЗдесь мы используем её, чтобы создать `GzipRequest` из исходного HTTP-запроса.\n\n{* ../../docs_src/custom_request_and_route/tutorial001_an_py310.py hl[19:27] *}\n\n/// note | Технические детали\n\nУ `Request` есть атрибут `request.scope` — это просто Python-`dict`, содержащий метаданные, связанные с HTTP-запросом.\n\nУ `Request` также есть `request.receive` — функция для «получения» тела запроса.\n\nИ `dict` `scope`, и функция `receive` являются частью спецификации ASGI.\n\nИменно этих двух компонентов — `scope` и `receive` — достаточно, чтобы создать новый экземпляр `Request`.\n\nЧтобы узнать больше о `Request`, см. <a href=\"https://www.starlette.dev/requests/\" class=\"external-link\" target=\"_blank\">документацию Starlette о запросах</a>.\n\n///\n\nЕдинственное, что делает по-другому функция, возвращённая `GzipRequest.get_route_handler`, — преобразует `Request` в `GzipRequest`.\n\nБлагодаря этому наш `GzipRequest` позаботится о распаковке данных (при необходимости) до передачи их в наши *операции пути*.\n\nДальше вся логика обработки остаётся прежней.", "metadata": {"title": "Пользовательские классы Request и APIRoute", "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "source_mtime": "2026-01-12T17:48:13.218799+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-request-and-route.md", "section_header": "Создать пользовательский класс `GzipRoute`", "section_header_level": 3}, "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "title": "Пользовательские классы Request и APIRoute", "chunk_index": 4, "header": "Создать пользовательский класс `GzipRoute`", "header_level": 3, "token_count": 483}
{"id": "7abf76aab0642015", "text": "`GzipRequest` позаботится о распаковке данных (при необходимости) до передачи их в наши *операции пути*.\n\nДальше вся логика обработки остаётся прежней.\n\nНо благодаря изменениям в `GzipRequest.body` тело запроса будет автоматически распаковано при необходимости, когда оно будет загружено **FastAPI**.", "metadata": {"title": "Пользовательские классы Request и APIRoute", "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "source_mtime": "2026-01-12T17:48:13.218799+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-request-and-route.md", "section_header": "Создать пользовательский класс `GzipRoute`", "section_header_level": 3}, "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "title": "Пользовательские классы Request и APIRoute", "chunk_index": 5, "header": "Создать пользовательский класс `GzipRoute`", "header_level": 3, "token_count": 118}
{"id": "dd746c6831e8a038", "text": "## Доступ к телу запроса в обработчике исключений { #accessing-the-request-body-in-an-exception-handler }\n\n/// tip | Совет\n\nДля решения этой задачи, вероятно, намного проще использовать `body` в пользовательском обработчике `RequestValidationError` ([Обработка ошибок](../tutorial/handling-errors.md#use-the-requestvalidationerror-body){.internal-link target=_blank}).\n\nНо этот пример всё равно актуален и показывает, как взаимодействовать с внутренними компонентами.\n\n///\n\nТем же подходом можно воспользоваться, чтобы получить доступ к телу запроса в обработчике исключений.\n\nНужно лишь обработать запрос внутри блока `try`/`except`:\n\n{* ../../docs_src/custom_request_and_route/tutorial002_an_py310.py hl[14,16] *}\n\nЕсли произойдёт исключение, экземпляр `Request` всё ещё будет в области видимости, поэтому мы сможем прочитать тело запроса и использовать его при обработке ошибки:\n\n{* ../../docs_src/custom_request_and_route/tutorial002_an_py310.py hl[17:19] *}\n\n", "metadata": {"title": "Пользовательские классы Request и APIRoute", "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "source_mtime": "2026-01-12T17:48:13.218799+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-request-and-route.md"}, "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "title": "Пользовательские классы Request и APIRoute", "chunk_index": 6, "header": "Доступ к телу запроса в обработчике исключений", "header_level": 2, "token_count": 321}
{"id": "0e58ed976c7733e4", "text": "## Пользовательский класс `APIRoute` в роутере { #custom-apiroute-class-in-a-router }\n\nВы также можете задать параметр `route_class` у `APIRouter`:\n\n{* ../../docs_src/custom_request_and_route/tutorial003_py310.py hl[26] *}\n\nВ этом примере *операции пути*, объявленные в `router`, будут использовать пользовательский класс `TimedRoute` и получат дополнительный HTTP-заголовок `X-Response-Time` в ответе с временем, затраченным на формирование ответа:\n\n{* ../../docs_src/custom_request_and_route/tutorial003_py310.py hl[13:20] *}\n", "metadata": {"title": "Пользовательские классы Request и APIRoute", "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "source_mtime": "2026-01-12T17:48:13.218799+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\custom-request-and-route.md"}, "doc_id": "8ed5e0d62d37", "source_path": "docs\\how-to\\custom-request-and-route.md", "title": "Пользовательские классы Request и APIRoute", "chunk_index": 7, "header": "Пользовательский класс `APIRoute` в роутере", "header_level": 2, "token_count": 165}
{"id": "6606c2905a786429", "text": "# Расширение OpenAPI { #extending-openapi }\n\nИногда может понадобиться изменить сгенерированную схему OpenAPI.\n\nВ этом разделе показано, как это сделать.\n\n", "metadata": {"title": "Расширение OpenAPI", "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "source_mtime": "2026-01-12T17:48:13.223790+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\extending-openapi.md"}, "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "title": "Расширение OpenAPI", "chunk_index": 0, "header": "Расширение OpenAPI", "header_level": 1, "token_count": 59}
{"id": "81b6aaa763c1ad28", "text": "## Обычный процесс { #the-normal-process }\n\nОбычный (по умолчанию) процесс выглядит так.\n\nПриложение `FastAPI` (экземпляр) имеет метод `.openapi()`, который должен возвращать схему OpenAPI.\n\nВ процессе создания объекта приложения регистрируется *операция пути* (обработчик пути) для `/openapi.json` (или для того, что указано в вашем `openapi_url`).\n\nОна просто возвращает JSON-ответ с результатом вызова метода приложения `.openapi()`.\n\nПо умолчанию метод `.openapi()` проверяет свойство `.openapi_schema`: если в нём уже есть данные, возвращает их.\n\nЕсли нет — генерирует схему с помощью вспомогательной функции `fastapi.openapi.utils.get_openapi`.\n\nФункция `get_openapi()` принимает параметры:\n\n* `title`: Заголовок OpenAPI, отображается в документации.\n* `version`: Версия вашего API, например `2.5.0`.\n* `openapi_version`: Версия используемой спецификации OpenAPI. По умолчанию — последняя: `3.1.0`.\n* `summary`: Краткое описание API.\n* `description`: Описание вашего API; может включать Markdown и будет отображается в документации.\n* `routes`: Список маршрутов — это каждая зарегистрированная *операция пути*. Берутся из `app.routes`.\n\n/// info | Информация\n\nПараметр `summary` доступен в OpenAPI 3.1.0 и выше, поддерживается FastAPI версии 0.99.0 и выше.\n\n///\n\n", "metadata": {"title": "Расширение OpenAPI", "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "source_mtime": "2026-01-12T17:48:13.223790+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\extending-openapi.md"}, "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "title": "Расширение OpenAPI", "chunk_index": 1, "header": "Обычный процесс", "header_level": 2, "token_count": 462}
{"id": "62c0ae642158d141", "text": "## Переопределение значений по умолчанию { #overriding-the-defaults }\n\nИспользуя информацию выше, вы можете той же вспомогательной функцией сгенерировать схему OpenAPI и переопределить любые нужные части.\n\nНапример, добавим <a href=\"https://github.com/Rebilly/ReDoc/blob/master/docs/redoc-vendor-extensions.md#x-logo\" class=\"external-link\" target=\"_blank\">расширение OpenAPI ReDoc для включения собственного логотипа</a>.\n\n", "metadata": {"title": "Расширение OpenAPI", "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "source_mtime": "2026-01-12T17:48:13.223790+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\extending-openapi.md"}, "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "title": "Расширение OpenAPI", "chunk_index": 2, "header": "Переопределение значений по умолчанию", "header_level": 2, "token_count": 147}
{"id": "38bb3a4538397a31", "text": "### Обычный **FastAPI** { #normal-fastapi }\n\nСначала напишите приложение **FastAPI** как обычно:\n\n{* ../../docs_src/extending_openapi/tutorial001_py39.py hl[1,4,7:9] *}\n\n", "metadata": {"title": "Расширение OpenAPI", "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "source_mtime": "2026-01-12T17:48:13.223790+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\extending-openapi.md"}, "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "title": "Расширение OpenAPI", "chunk_index": 3, "header": "Обычный **FastAPI**", "header_level": 3, "token_count": 59}
{"id": "33ce278386b0dc65", "text": "### Сгенерируйте схему OpenAPI { #generate-the-openapi-schema }\n\nЗатем используйте ту же вспомогательную функцию для генерации схемы OpenAPI внутри функции `custom_openapi()`:\n\n{* ../../docs_src/extending_openapi/tutorial001_py39.py hl[2,15:21] *}\n\n", "metadata": {"title": "Расширение OpenAPI", "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "source_mtime": "2026-01-12T17:48:13.223790+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\extending-openapi.md"}, "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "title": "Расширение OpenAPI", "chunk_index": 4, "header": "Сгенерируйте схему OpenAPI", "header_level": 3, "token_count": 86}
{"id": "b17e7be55df5357d", "text": "### Измените схему OpenAPI { #modify-the-openapi-schema }\n\nТеперь можно добавить расширение ReDoc, добавив кастомный `x-logo` в «объект» `info` в схеме OpenAPI:\n\n{* ../../docs_src/extending_openapi/tutorial001_py39.py hl[22:24] *}\n\n", "metadata": {"title": "Расширение OpenAPI", "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "source_mtime": "2026-01-12T17:48:13.223790+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\extending-openapi.md"}, "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "title": "Расширение OpenAPI", "chunk_index": 5, "header": "Измените схему OpenAPI", "header_level": 3, "token_count": 80}
{"id": "3657a07fadd863f1", "text": "### Кэшируйте схему OpenAPI { #cache-the-openapi-schema }\n\nВы можете использовать свойство `.openapi_schema` как «кэш» для хранения сгенерированной схемы.\n\nТак приложению не придётся генерировать схему каждый раз, когда пользователь открывает документацию API.\n\nОна будет создана один раз, а затем тот же кэшированный вариант будет использоваться для последующих запросов.\n\n{* ../../docs_src/extending_openapi/tutorial001_py39.py hl[13:14,25:26] *}\n\n", "metadata": {"title": "Расширение OpenAPI", "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "source_mtime": "2026-01-12T17:48:13.223790+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\extending-openapi.md"}, "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "title": "Расширение OpenAPI", "chunk_index": 6, "header": "Кэшируйте схему OpenAPI", "header_level": 3, "token_count": 161}
{"id": "f3b036d9868ae382", "text": "### Переопределите метод { #override-the-method }\n\nТеперь вы можете заменить метод `.openapi()` на вашу новую функцию.\n\n{* ../../docs_src/extending_openapi/tutorial001_py39.py hl[29] *}\n\n", "metadata": {"title": "Расширение OpenAPI", "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "source_mtime": "2026-01-12T17:48:13.223790+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\extending-openapi.md"}, "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "title": "Расширение OpenAPI", "chunk_index": 7, "header": "Переопределите метод", "header_level": 3, "token_count": 56}
{"id": "ac419e24a6db45f9", "text": "### Проверьте { #check-it }\n\nПерейдите на <a href=\"http://127.0.0.1:8000/redoc\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/redoc</a> — вы увидите, что используется ваш кастомный логотип (в этом примере — логотип **FastAPI**):\n\n<img src=\"/img/tutorial/extending-openapi/image01.png\">\n", "metadata": {"title": "Расширение OpenAPI", "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "source_mtime": "2026-01-12T17:48:13.223790+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\extending-openapi.md"}, "doc_id": "a50eb39d7a76", "source_path": "docs\\how-to\\extending-openapi.md", "title": "Расширение OpenAPI", "chunk_index": 8, "header": "Проверьте", "header_level": 3, "token_count": 110}
{"id": "fda2c68e21eb7dcd", "text": "# Общее — Как сделать — Рецепты { #general-how-to-recipes }\n\nЗдесь несколько указателей на другие места в документации для общих или частых вопросов.\n\n", "metadata": {"title": "Общее — Как сделать — Рецепты", "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "source_mtime": "2026-01-12T17:48:13.228020+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\general.md"}, "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "title": "Общее — Как сделать — Рецепты", "chunk_index": 0, "header": "Общее — Как сделать — Рецепты", "header_level": 1, "token_count": 57}
{"id": "7209f00f63917062", "text": "## Фильтрация данных — Безопасность { #filter-data-security }\n\nЧтобы убедиться, что вы не возвращаете больше данных, чем следует, прочитайте документацию: [Руководство — Модель ответа — Возвращаемый тип](../tutorial/response-model.md){.internal-link target=_blank}.\n\n", "metadata": {"title": "Общее — Как сделать — Рецепты", "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "source_mtime": "2026-01-12T17:48:13.228020+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\general.md"}, "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "title": "Общее — Как сделать — Рецепты", "chunk_index": 1, "header": "Фильтрация данных — Безопасность", "header_level": 2, "token_count": 87}
{"id": "13cb84eef8c43724", "text": "## Теги в документации — OpenAPI { #documentation-tags-openapi }\n\nЧтобы добавить теги к вашим *операциям пути* и группировать их в интерфейсе документации, прочитайте документацию: [Руководство — Конфигурации операций пути — Теги](../tutorial/path-operation-configuration.md#tags){.internal-link target=_blank}.\n\n", "metadata": {"title": "Общее — Как сделать — Рецепты", "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "source_mtime": "2026-01-12T17:48:13.228020+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\general.md"}, "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "title": "Общее — Как сделать — Рецепты", "chunk_index": 2, "header": "Теги в документации — OpenAPI", "header_level": 2, "token_count": 109}
{"id": "24cfa6232adeb57d", "text": "## Краткое описание и описание в документации — OpenAPI { #documentation-summary-and-description-openapi }\n\nЧтобы добавить краткое описание и описание к вашим *операциям пути* и отобразить их в интерфейсе документации, прочитайте документацию: [Руководство — Конфигурации операций пути — Краткое описание и описание](../tutorial/path-operation-configuration.md#summary-and-description){.internal-link target=_blank}.\n\n", "metadata": {"title": "Общее — Как сделать — Рецепты", "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "source_mtime": "2026-01-12T17:48:13.228020+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\general.md"}, "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "title": "Общее — Как сделать — Рецепты", "chunk_index": 3, "header": "Краткое описание и описание в документации — OpenAPI", "header_level": 2, "token_count": 131}
{"id": "86cded8fec6dfb25", "text": "## Описание ответа в документации — OpenAPI { #documentation-response-description-openapi }\n\nЧтобы задать описание ответа, отображаемое в интерфейсе документации, прочитайте документацию: [Руководство — Конфигурации операций пути — Описание ответа](../tutorial/path-operation-configuration.md#response-description){.internal-link target=_blank}.\n\n", "metadata": {"title": "Общее — Как сделать — Рецепты", "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "source_mtime": "2026-01-12T17:48:13.228020+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\general.md"}, "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "title": "Общее — Как сделать — Рецепты", "chunk_index": 4, "header": "Описание ответа в документации — OpenAPI", "header_level": 2, "token_count": 100}
{"id": "b633505c1ee8b115", "text": "## Документация — пометить операцию пути устаревшей — OpenAPI { #documentation-deprecate-a-path-operation-openapi }\n\nЧтобы пометить *операцию пути* как устаревшую и показать это в интерфейсе документации, прочитайте документацию: [Руководство — Конфигурации операций пути — Пометить операцию пути устаревшей](../tutorial/path-operation-configuration.md#deprecate-a-path-operation){.internal-link target=_blank}.\n\n", "metadata": {"title": "Общее — Как сделать — Рецепты", "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "source_mtime": "2026-01-12T17:48:13.228020+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\general.md"}, "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "title": "Общее — Как сделать — Рецепты", "chunk_index": 5, "header": "Документация — пометить операцию пути устаревшей — OpenAPI", "header_level": 2, "token_count": 144}
{"id": "b1597134c419c01b", "text": "## Преобразование любых данных к формату, совместимому с JSON { #convert-any-data-to-json-compatible }\n\nЧтобы преобразовать любые данные к формату, совместимому с JSON, прочитайте документацию: [Руководство — JSON-совместимый кодировщик](../tutorial/encoder.md){.internal-link target=_blank}.\n\n", "metadata": {"title": "Общее — Как сделать — Рецепты", "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "source_mtime": "2026-01-12T17:48:13.228020+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\general.md"}, "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "title": "Общее — Как сделать — Рецепты", "chunk_index": 6, "header": "Преобразование любых данных к формату, совместимому с JSON", "header_level": 2, "token_count": 105}
{"id": "e82316abefa54e5a", "text": "## Метаданные OpenAPI — Документация { #openapi-metadata-docs }\n\nЧтобы добавить метаданные в вашу схему OpenAPI, включая лицензию, версию, контакты и т.д., прочитайте документацию: [Руководство — Метаданные и URL документации](../tutorial/metadata.md){.internal-link target=_blank}.\n\n", "metadata": {"title": "Общее — Как сделать — Рецепты", "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "source_mtime": "2026-01-12T17:48:13.228020+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\general.md"}, "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "title": "Общее — Как сделать — Рецепты", "chunk_index": 7, "header": "Метаданные OpenAPI — Документация", "header_level": 2, "token_count": 106}
{"id": "14deda58171bf5dd", "text": "## Пользовательский URL OpenAPI { #openapi-custom-url }\n\nЧтобы настроить URL OpenAPI (или удалить его), прочитайте документацию: [Руководство — Метаданные и URL документации](../tutorial/metadata.md#openapi-url){.internal-link target=_blank}.\n\n", "metadata": {"title": "Общее — Как сделать — Рецепты", "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "source_mtime": "2026-01-12T17:48:13.228020+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\general.md"}, "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "title": "Общее — Как сделать — Рецепты", "chunk_index": 8, "header": "Пользовательский URL OpenAPI", "header_level": 2, "token_count": 80}
{"id": "3519efea017a25dc", "text": "## URL документации OpenAPI { #openapi-docs-urls }\n\nЧтобы изменить URL, используемые для автоматически сгенерированных пользовательских интерфейсов документации, прочитайте документацию: [Руководство — Метаданные и URL документации](../tutorial/metadata.md#docs-urls){.internal-link target=_blank}.\n", "metadata": {"title": "Общее — Как сделать — Рецепты", "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "source_mtime": "2026-01-12T17:48:13.228020+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\general.md"}, "doc_id": "e7a7bd952f1b", "source_path": "docs\\how-to\\general.md", "title": "Общее — Как сделать — Рецепты", "chunk_index": 9, "header": "URL документации OpenAPI", "header_level": 2, "token_count": 99}
{"id": "2d9f85dc956ae993", "text": "# GraphQL { #graphql }\n\nТак как **FastAPI** основан на стандарте **ASGI**, очень легко интегрировать любую библиотеку **GraphQL**, также совместимую с ASGI.\n\nВы можете комбинировать обычные *операции пути* FastAPI с GraphQL в одном приложении.\n\n/// tip | Совет\n\n**GraphQL** решает некоторые очень специфические задачи.\n\nУ него есть как **преимущества**, так и **недостатки** по сравнению с обычными **веб-API**.\n\nУбедитесь, что **выгоды** для вашего случая использования перевешивают **недостатки**. \n\n///\n\n", "metadata": {"title": "GraphQL", "doc_id": "248e7e054c49", "source_path": "docs\\how-to\\graphql.md", "source_mtime": "2026-01-12T17:48:13.233172+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\graphql.md"}, "doc_id": "248e7e054c49", "source_path": "docs\\how-to\\graphql.md", "title": "GraphQL", "chunk_index": 0, "header": "GraphQL", "header_level": 1, "token_count": 199}
{"id": "715accd7daa3b1b2", "text": "## Библиотеки GraphQL { #graphql-libraries }\n\nНиже приведены некоторые библиотеки **GraphQL** с поддержкой **ASGI**. Их можно использовать с **FastAPI**:\n\n* <a href=\"https://strawberry.rocks/\" class=\"external-link\" target=\"_blank\">Strawberry</a> \n    * С <a href=\"https://strawberry.rocks/docs/integrations/fastapi\" class=\"external-link\" target=\"_blank\">документацией для FastAPI</a>\n* <a href=\"https://ariadnegraphql.org/\" class=\"external-link\" target=\"_blank\">Ariadne</a>\n    * С <a href=\"https://ariadnegraphql.org/docs/fastapi-integration\" class=\"external-link\" target=\"_blank\">документацией для FastAPI</a>\n* <a href=\"https://tartiflette.io/\" class=\"external-link\" target=\"_blank\">Tartiflette</a>\n    * С <a href=\"https://tartiflette.github.io/tartiflette-asgi/\" class=\"external-link\" target=\"_blank\">Tartiflette ASGI</a> для интеграции с ASGI\n* <a href=\"https://graphene-python.org/\" class=\"external-link\" target=\"_blank\">Graphene</a>\n    * С <a href=\"https://github.com/ciscorn/starlette-graphene3\" class=\"external-link\" target=\"_blank\">starlette-graphene3</a>\n\n", "metadata": {"title": "GraphQL", "doc_id": "248e7e054c49", "source_path": "docs\\how-to\\graphql.md", "source_mtime": "2026-01-12T17:48:13.233172+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\graphql.md"}, "doc_id": "248e7e054c49", "source_path": "docs\\how-to\\graphql.md", "title": "GraphQL", "chunk_index": 1, "header": "Библиотеки GraphQL", "header_level": 2, "token_count": 338}
{"id": "d073561888a95695", "text": "## GraphQL со Strawberry { #graphql-with-strawberry }\n\nЕсли вам нужно или хочется работать с **GraphQL**, <a href=\"https://strawberry.rocks/\" class=\"external-link\" target=\"_blank\">**Strawberry**</a> — **рекомендуемая** библиотека, так как её дизайн ближе всего к дизайну **FastAPI**, всё основано на **аннотациях типов**.\n\nВ зависимости от вашего сценария использования вы можете предпочесть другую библиотеку, но если бы вы спросили меня, я, скорее всего, предложил бы попробовать **Strawberry**.\n\nВот небольшой пример того, как можно интегрировать Strawberry с FastAPI:\n\n{* ../../docs_src/graphql_/tutorial001_py39.py hl[3,22,25] *}\n\nПодробнее о Strawberry можно узнать в <a href=\"https://strawberry.rocks/\" class=\"external-link\" target=\"_blank\">документации Strawberry</a>.\n\nА также в документации по <a href=\"https://strawberry.rocks/docs/integrations/fastapi\" class=\"external-link\" target=\"_blank\">интеграции Strawberry с FastAPI</a>.\n\n", "metadata": {"title": "GraphQL", "doc_id": "248e7e054c49", "source_path": "docs\\how-to\\graphql.md", "source_mtime": "2026-01-12T17:48:13.233172+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\graphql.md"}, "doc_id": "248e7e054c49", "source_path": "docs\\how-to\\graphql.md", "title": "GraphQL", "chunk_index": 2, "header": "GraphQL со Strawberry", "header_level": 2, "token_count": 319}
{"id": "9c2df921806f05ba", "text": "## Устаревший `GraphQLApp` из Starlette { #older-graphqlapp-from-starlette }\n\nВ предыдущих версиях Starlette был класс `GraphQLApp` для интеграции с <a href=\"https://graphene-python.org/\" class=\"external-link\" target=\"_blank\">Graphene</a>.\n\nОн был объявлен устаревшим в Starlette, но если у вас есть код, который его использовал, вы можете легко **мигрировать** на <a href=\"https://github.com/ciscorn/starlette-graphene3\" class=\"external-link\" target=\"_blank\">starlette-graphene3</a>, который решает ту же задачу и имеет **почти идентичный интерфейс**.\n\n/// tip | Совет\n\nЕсли вам нужен GraphQL, я всё же рекомендую посмотреть <a href=\"https://strawberry.rocks/\" class=\"external-link\" target=\"_blank\">Strawberry</a>, так как он основан на аннотациях типов, а не на пользовательских классах и типах.\n\n///\n\n", "metadata": {"title": "GraphQL", "doc_id": "248e7e054c49", "source_path": "docs\\how-to\\graphql.md", "source_mtime": "2026-01-12T17:48:13.233172+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\graphql.md"}, "doc_id": "248e7e054c49", "source_path": "docs\\how-to\\graphql.md", "title": "GraphQL", "chunk_index": 3, "header": "Устаревший `GraphQLApp` из Starlette", "header_level": 2, "token_count": 275}
{"id": "46eb6397ac52214b", "text": "## Подробнее { #learn-more }\n\nПодробнее о **GraphQL** вы можете узнать в <a href=\"https://graphql.org/\" class=\"external-link\" target=\"_blank\">официальной документации GraphQL</a>.\n\nТакже можно почитать больше о каждой из указанных выше библиотек по приведённым ссылкам.\n", "metadata": {"title": "GraphQL", "doc_id": "248e7e054c49", "source_path": "docs\\how-to\\graphql.md", "source_mtime": "2026-01-12T17:48:13.233172+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\graphql.md"}, "doc_id": "248e7e054c49", "source_path": "docs\\how-to\\graphql.md", "title": "GraphQL", "chunk_index": 4, "header": "Подробнее", "header_level": 2, "token_count": 97}
{"id": "e802416a105fb0ae", "text": "# Как сделать — Рецепты { #how-to-recipes }\n\nЗдесь вы найдете разные рецепты и руководства «как сделать» по различным темам.\n\nБольшинство из этих идей более-менее независимы, и в большинстве случаев вам стоит изучать их только если они напрямую относятся к вашему проекту.\n\nЕсли что-то кажется интересным и полезным для вашего проекта, смело изучайте; в противном случае, вероятно, можно просто пропустить.\n\n/// tip | Совет\n\nЕсли вы хотите изучить FastAPI структурированно (рекомендуется), вместо этого читайте [Учебник — Руководство пользователя](../tutorial/index.md){.internal-link target=_blank} по главам.\n\n///\n", "metadata": {"title": "Как сделать — Рецепты", "doc_id": "e4baa457443b", "source_path": "docs\\how-to\\index.md", "source_mtime": "2026-01-12T17:48:13.233172+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\index.md"}, "doc_id": "e4baa457443b", "source_path": "docs\\how-to\\index.md", "title": "Как сделать — Рецепты", "chunk_index": 0, "header": "Как сделать — Рецепты", "header_level": 1, "token_count": 255}
{"id": "3f56fb4fee27ec07", "text": "# Миграция с Pydantic v1 на Pydantic v2 { #migrate-from-pydantic-v1-to-pydantic-v2 }\n\nЕсли у вас старое приложение FastAPI, возможно, вы используете Pydantic версии 1.\n\nFastAPI поддерживает и Pydantic v1, и v2 начиная с версии 0.100.0.\n\nЕсли у вас был установлен Pydantic v2, использовался он. Если вместо этого был установлен Pydantic v1 — использовался он.\n\nСейчас Pydantic v1 объявлен устаревшим, и поддержка его будет удалена в следующих версиях FastAPI, поэтому вам следует **перейти на Pydantic v2**. Так вы получите последние возможности, улучшения и исправления.\n\n/// warning | Предупреждение\n\nКроме того, команда Pydantic прекратила поддержку Pydantic v1 для последних версий Python, начиная с **Python 3.14**.\n\nЕсли вы хотите использовать последние возможности Python, вам нужно убедиться, что вы используете Pydantic v2.\n\n///\n\nЕсли у вас старое приложение FastAPI с Pydantic v1, здесь я покажу, как мигрировать на Pydantic v2, и **новые возможности в FastAPI 0.119.0**, которые помогут выполнить постепенную миграцию.\n\n", "metadata": {"title": "Миграция с Pydantic v1 на Pydantic v2", "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "source_mtime": "2026-01-12T17:48:13.242273+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md"}, "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "title": "Миграция с Pydantic v1 на Pydantic v2", "chunk_index": 0, "header": "Миграция с Pydantic v1 на Pydantic v2", "header_level": 1, "token_count": 397}
{"id": "d7d0a0728a6244ae", "text": "## Официальное руководство { #official-guide }\n\nУ Pydantic есть официальное <a href=\"https://docs.pydantic.dev/latest/migration/\" class=\"external-link\" target=\"_blank\">руководство по миграции</a> с v1 на v2.\n\nТам также описано, что изменилось, как валидации стали более корректными и строгими, возможные нюансы и т.д.\n\nПрочитайте его, чтобы лучше понять, что изменилось.\n\n", "metadata": {"title": "Миграция с Pydantic v1 на Pydantic v2", "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "source_mtime": "2026-01-12T17:48:13.242273+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md"}, "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "title": "Миграция с Pydantic v1 на Pydantic v2", "chunk_index": 1, "header": "Официальное руководство", "header_level": 2, "token_count": 144}
{"id": "088ccb5c12c7b112", "text": "## Тесты { #tests }\n\nУбедитесь, что у вас есть [тесты](../tutorial/testing.md){.internal-link target=_blank} для вашего приложения и что вы запускаете их в системе непрерывной интеграции (CI).\n\nТак вы сможете выполнить обновление и убедиться, что всё работает как ожидается.\n\n", "metadata": {"title": "Миграция с Pydantic v1 на Pydantic v2", "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "source_mtime": "2026-01-12T17:48:13.242273+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md"}, "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "title": "Миграция с Pydantic v1 на Pydantic v2", "chunk_index": 2, "header": "Тесты", "header_level": 2, "token_count": 99}
{"id": "a05792509c76b184", "text": "## `bump-pydantic` { #bump-pydantic }\n\nВо многих случаях, когда вы используете обычные Pydantic‑модели без пользовательских настроек, вы сможете автоматизировать большую часть процесса миграции с Pydantic v1 на Pydantic v2.\n\nВы можете использовать <a href=\"https://github.com/pydantic/bump-pydantic\" class=\"external-link\" target=\"_blank\">`bump-pydantic`</a> от той же команды Pydantic.\n\nЭтот инструмент поможет автоматически внести большую часть необходимых изменений в код.\n\nПосле этого запустите тесты и проверьте, что всё работает. Если да — на этом всё. \n\n", "metadata": {"title": "Миграция с Pydantic v1 на Pydantic v2", "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "source_mtime": "2026-01-12T17:48:13.242273+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md"}, "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "title": "Миграция с Pydantic v1 на Pydantic v2", "chunk_index": 3, "header": "`bump-pydantic`", "header_level": 2, "token_count": 210}
{"id": "ac9098095767e52c", "text": "## Pydantic v1 в v2 { #pydantic-v1-in-v2 }\n\nPydantic v2 включает всё из Pydantic v1 как подмодуль `pydantic.v1`.\n\nЭто означает, что вы можете установить последнюю версию Pydantic v2 и импортировать и использовать старые компоненты Pydantic v1 из этого подмодуля так, как если бы у вас был установлен старый Pydantic v1.\n\n{* ../../docs_src/pydantic_v1_in_v2/tutorial001_an_py310.py hl[1,4] *}\n\n", "metadata": {"title": "Миграция с Pydantic v1 на Pydantic v2", "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "source_mtime": "2026-01-12T17:48:13.242273+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md"}, "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "title": "Миграция с Pydantic v1 на Pydantic v2", "chunk_index": 4, "header": "Pydantic v1 в v2", "header_level": 2, "token_count": 152}
{"id": "04e824b9ae962cf3", "text": "### Поддержка FastAPI для Pydantic v1 внутри v2 { #fastapi-support-for-pydantic-v1-in-v2 }\n\nНачиная с FastAPI 0.119.0, есть также частичная поддержка Pydantic v1 в составе Pydantic v2, чтобы упростить миграцию на v2.\n\nТаким образом, вы можете обновить Pydantic до последней версии 2 и сменить импорты на подмодуль `pydantic.v1` — во многих случаях всё просто заработает.\n\n{* ../../docs_src/pydantic_v1_in_v2/tutorial002_an_py310.py hl[2,5,15] *}\n\n/// warning | Предупреждение\n\nИмейте в виду, что так как команда Pydantic больше не поддерживает Pydantic v1 в последних версиях Python, начиная с Python 3.14, использование `pydantic.v1` также не поддерживается в Python 3.14 и выше.\n\n///\n\n", "metadata": {"title": "Миграция с Pydantic v1 на Pydantic v2", "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "source_mtime": "2026-01-12T17:48:13.242273+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md"}, "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "title": "Миграция с Pydantic v1 на Pydantic v2", "chunk_index": 5, "header": "Поддержка FastAPI для Pydantic v1 внутри v2", "header_level": 3, "token_count": 271}
{"id": "3f56fb4fee27ec07", "text": "### Pydantic v1 и v2 в одном приложении { #pydantic-v1-and-v2-on-the-same-app }\n\nВ Pydantic **не поддерживается** ситуация, когда в одной модели Pydantic v2 используются поля, определённые как модели Pydantic v1, и наоборот.\n\n```mermaid\ngraph TB\n    subgraph \"❌ Not Supported\"\n        direction TB\n        subgraph V2[\"Pydantic v2 Model\"]\n            V1Field[\"Pydantic v1 Model\"]\n        end\n        subgraph V1[\"Pydantic v1 Model\"]\n            V2Field[\"Pydantic v2 Model\"]\n        end\n    end\n\n    style V2 fill:#f9fff3\n    style V1 fill:#fff6f0\n    style V1Field fill:#fff6f0\n    style V2Field fill:#f9fff3\n```\n\n…но в одном и том же приложении вы можете иметь отдельные модели на Pydantic v1 и v2.\n\n```mermaid\ngraph TB\n    subgraph \"✅ Supported\"\n        direction TB\n        subgraph V2[\"Pydantic v2 Model\"]\n            V2Field[\"Pydantic v2 Model\"]\n        end\n        subgraph V1[\"Pydantic v1 Model\"]\n            V1Field[\"Pydantic v1 Model\"]\n        end\n    end\n\n    style V2 fill:#f9fff3\n    style V1 fill:#fff6f0\n    style V1Field fill:#fff6f0\n    style V2Field fill:#f9fff3\n```\n\nВ некоторых случаях можно использовать и модели Pydantic v1, и v2 в одной и той же операции пути (обработчике пути) вашего приложения FastAPI:\n\n{* ../../docs_src/pydantic_v1_in_v2/tutorial003_an_py310.py hl[2:3,6,12,21:22] *}", "metadata": {"title": "Миграция с Pydantic v1 на Pydantic v2", "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "source_mtime": "2026-01-12T17:48:13.242273+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "section_header": "Pydantic v1 и v2 в одном приложении", "section_header_level": 3}, "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "title": "Миграция с Pydantic v1 на Pydantic v2", "chunk_index": 6, "header": "Pydantic v1 и v2 в одном приложении", "header_level": 3, "token_count": 462}
{"id": "d7d0a0728a6244ae", "text": "в одной и той же операции пути (обработчике пути) вашего приложения FastAPI:\n\n{* ../../docs_src/pydantic_v1_in_v2/tutorial003_an_py310.py hl[2:3,6,12,21:22] *}\n\nВ примере выше модель входных данных — это модель Pydantic v1, а модель выходных данных (указанная в `response_model=ItemV2`) — это модель Pydantic v2.", "metadata": {"title": "Миграция с Pydantic v1 на Pydantic v2", "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "source_mtime": "2026-01-12T17:48:13.242273+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "section_header": "Pydantic v1 и v2 в одном приложении", "section_header_level": 3}, "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "title": "Миграция с Pydantic v1 на Pydantic v2", "chunk_index": 7, "header": "Pydantic v1 и v2 в одном приложении", "header_level": 3, "token_count": 117}
{"id": "16d846a3b6dfd4d4", "text": "### Параметры Pydantic v1 { #pydantic-v1-parameters }\n\nЕсли вам нужно использовать некоторые специфичные для FastAPI инструменты для параметров, такие как `Body`, `Query`, `Form` и т.п., с моделями Pydantic v1, вы можете импортировать их из `fastapi.temp_pydantic_v1_params`, пока завершаете миграцию на Pydantic v2:\n\n{* ../../docs_src/pydantic_v1_in_v2/tutorial004_an_py310.py hl[4,18] *}\n\n", "metadata": {"title": "Миграция с Pydantic v1 на Pydantic v2", "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "source_mtime": "2026-01-12T17:48:13.242273+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md"}, "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "title": "Миграция с Pydantic v1 на Pydantic v2", "chunk_index": 8, "header": "Параметры Pydantic v1", "header_level": 3, "token_count": 142}
{"id": "2379fa5782ea5ff7", "text": "### Мигрируйте по шагам { #migrate-in-steps }\n\n/// tip | Совет\n\nСначала попробуйте `bump-pydantic`. Если тесты проходят и всё работает, вы справились одной командой. \n\n///\n\nЕсли `bump-pydantic` не подходит для вашего случая, вы можете использовать поддержку одновременной работы моделей Pydantic v1 и v2 в одном приложении, чтобы мигрировать на Pydantic v2 постепенно.\n\nСначала обновите Pydantic до последней 2-й версии и измените импорты так, чтобы все ваши модели использовали `pydantic.v1`.\n\nЗатем начните мигрировать ваши модели с Pydantic v1 на v2 группами, поэтапно.\n", "metadata": {"title": "Миграция с Pydantic v1 на Pydantic v2", "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "source_mtime": "2026-01-12T17:48:13.242273+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md"}, "doc_id": "67430d8af136", "source_path": "docs\\how-to\\migrate-from-pydantic-v1-to-pydantic-v2.md", "title": "Миграция с Pydantic v1 на Pydantic v2", "chunk_index": 9, "header": "Мигрируйте по шагам", "header_level": 3, "token_count": 220}
{"id": "814bccb5af8bcf88", "text": "# Разделять схемы OpenAPI для входа и выхода или нет { #separate-openapi-schemas-for-input-and-output-or-not }\n\nПри использовании **Pydantic v2** сгенерированный OpenAPI становится чуть более точным и **корректным**, чем раньше. \n\nНа самом деле, в некоторых случаях в OpenAPI будет даже **две JSON схемы** для одной и той же Pydantic‑модели: для входа и для выхода — в зависимости от наличия **значений по умолчанию**.\n\nПосмотрим, как это работает, и как это изменить при необходимости.\n\n", "metadata": {"title": "Разделять схемы OpenAPI для входа и выхода или нет", "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "source_mtime": "2026-01-12T17:48:13.247189+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\separate-openapi-schemas.md"}, "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "title": "Разделять схемы OpenAPI для входа и выхода или нет", "chunk_index": 0, "header": "Разделять схемы OpenAPI для входа и выхода или нет", "header_level": 1, "token_count": 185}
{"id": "fdfa309ea9774809", "text": "## Pydantic‑модели для входа и выхода { #pydantic-models-for-input-and-output }\n\nПредположим, у вас есть Pydantic‑модель со значениями по умолчанию, как здесь:\n\n{* ../../docs_src/separate_openapi_schemas/tutorial001_py310.py ln[1:7] hl[7] *}\n\n", "metadata": {"title": "Разделять схемы OpenAPI для входа и выхода или нет", "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "source_mtime": "2026-01-12T17:48:13.247189+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\separate-openapi-schemas.md"}, "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "title": "Разделять схемы OpenAPI для входа и выхода или нет", "chunk_index": 1, "header": "Pydantic‑модели для входа и выхода", "header_level": 2, "token_count": 87}
{"id": "8b37715524a21a60", "text": "### Модель для входа { #model-for-input }\n\nЕсли использовать эту модель как входную, как здесь:\n\n{* ../../docs_src/separate_openapi_schemas/tutorial001_py310.py ln[1:15] hl[14] *}\n\n…то поле `description` **не будет обязательным**, потому что у него значение по умолчанию `None`.\n\n", "metadata": {"title": "Разделять схемы OpenAPI для входа и выхода или нет", "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "source_mtime": "2026-01-12T17:48:13.247189+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\separate-openapi-schemas.md"}, "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "title": "Разделять схемы OpenAPI для входа и выхода или нет", "chunk_index": 2, "header": "Модель для входа", "header_level": 3, "token_count": 90}
{"id": "9052edee77f67273", "text": "### Входная модель в документации { #input-model-in-docs }\n\nВ документации это видно: у поля `description` нет **красной звёздочки** — оно не отмечено как обязательное:\n\n<div class=\"screenshot\">\n<img src=\"/img/tutorial/separate-openapi-schemas/image01.png\">\n</div>\n\n", "metadata": {"title": "Разделять схемы OpenAPI для входа и выхода или нет", "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "source_mtime": "2026-01-12T17:48:13.247189+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\separate-openapi-schemas.md"}, "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "title": "Разделять схемы OpenAPI для входа и выхода или нет", "chunk_index": 3, "header": "Входная модель в документации", "header_level": 3, "token_count": 83}
{"id": "bfcc49480f873d68", "text": "### Модель для выхода { #model-for-output }\n\nНо если использовать ту же модель как выходную, как здесь:\n\n{* ../../docs_src/separate_openapi_schemas/tutorial001_py310.py hl[19] *}\n\n…то, поскольку у `description` есть значение по умолчанию, даже если вы **ничего не вернёте** для этого поля, оно всё равно будет иметь это **значение по умолчанию**.\n\n", "metadata": {"title": "Разделять схемы OpenAPI для входа и выхода или нет", "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "source_mtime": "2026-01-12T17:48:13.247189+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\separate-openapi-schemas.md"}, "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "title": "Разделять схемы OpenAPI для входа и выхода или нет", "chunk_index": 4, "header": "Модель для выхода", "header_level": 3, "token_count": 119}
{"id": "b6a0d983cd37c985", "text": "### Модель для данных ответа { #model-for-output-response-data }\n\nЕсли поработать с интерактивной документацией и посмотреть ответ, то, хотя код ничего не добавил в одно из полей `description`, JSON‑ответ содержит значение по умолчанию (`null`):\n\n<div class=\"screenshot\">\n<img src=\"/img/tutorial/separate-openapi-schemas/image02.png\">\n</div>\n\nЭто означает, что у него **всегда будет какое‑то значение**, просто иногда это значение может быть `None` (или `null` в JSON).\n\nСледовательно, клиентам, использующим ваш API, не нужно проверять наличие этого значения: они могут **исходить из того, что поле всегда присутствует**, а в некоторых случаях имеет значение по умолчанию `None`.\n\nВ OpenAPI это описывается тем, что поле помечается как **обязательное**, поскольку оно всегда присутствует.\n\nИз‑за этого JSON Schema для модели может отличаться в зависимости от использования для **входа** или **выхода**:\n\n* для **входа** `description` не будет обязательным\n* для **выхода** оно будет **обязательным** (и при этом может быть `None`, или, в терминах JSON, `null`)\n\n", "metadata": {"title": "Разделять схемы OpenAPI для входа и выхода или нет", "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "source_mtime": "2026-01-12T17:48:13.247189+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\separate-openapi-schemas.md"}, "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "title": "Разделять схемы OpenAPI для входа и выхода или нет", "chunk_index": 5, "header": "Модель для данных ответа", "header_level": 3, "token_count": 359}
{"id": "2c73e8f7e5c4c86d", "text": "### Выходная модель в документации { #model-for-output-in-docs }\n\nВ документации это тоже видно, что **оба**: `name` и `description`, помечены **красной звёздочкой** как **обязательные**:\n\n<div class=\"screenshot\">\n<img src=\"/img/tutorial/separate-openapi-schemas/image03.png\">\n</div>\n\n", "metadata": {"title": "Разделять схемы OpenAPI для входа и выхода или нет", "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "source_mtime": "2026-01-12T17:48:13.247189+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\separate-openapi-schemas.md"}, "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "title": "Разделять схемы OpenAPI для входа и выхода или нет", "chunk_index": 6, "header": "Выходная модель в документации", "header_level": 3, "token_count": 91}
{"id": "756b43199cdd9660", "text": "### Модели для входа и выхода в документации { #model-for-input-and-output-in-docs }\n\nЕсли посмотреть все доступные схемы (JSON Schema) в OpenAPI, вы увидите две: `Item-Input` и `Item-Output`.\n\nДля `Item-Input` поле `description` **не является обязательным** — красной звёздочки нет.\n\nА для `Item-Output` `description` **обязательно** — красная звёздочка есть.\n\n<div class=\"screenshot\">\n<img src=\"/img/tutorial/separate-openapi-schemas/image04.png\">\n</div>\n\nБлагодаря этой возможности **Pydantic v2** документация вашего API становится более **точной**; если у вас есть сгенерированные клиенты и SDK, они тоже будут точнее, с лучшим **удобством для разработчиков** и большей консистентностью. \n\n", "metadata": {"title": "Разделять схемы OpenAPI для входа и выхода или нет", "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "source_mtime": "2026-01-12T17:48:13.247189+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\separate-openapi-schemas.md"}, "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "title": "Разделять схемы OpenAPI для входа и выхода или нет", "chunk_index": 7, "header": "Модели для входа и выхода в документации", "header_level": 3, "token_count": 255}
{"id": "c66bb4576507ac00", "text": "## Не разделять схемы { #do-not-separate-schemas }\n\nОднако бывают случаи, когда вы хотите иметь **одну и ту же схему для входа и выхода**.\n\nГлавный сценарий — когда у вас уже есть сгенерированный клиентский код/SDK, и вы пока не хотите обновлять весь этот автогенерируемый код/SDK (рано или поздно вы это сделаете, но не сейчас).\n\nВ таком случае вы можете отключить эту функциональность в FastAPI с помощью параметра `separate_input_output_schemas=False`.\n\n/// info | Информация\n\nПоддержка `separate_input_output_schemas` появилась в FastAPI `0.102.0`. \n\n///\n\n{* ../../docs_src/separate_openapi_schemas/tutorial002_py310.py hl[10] *}\n\n", "metadata": {"title": "Разделять схемы OpenAPI для входа и выхода или нет", "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "source_mtime": "2026-01-12T17:48:13.247189+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\separate-openapi-schemas.md"}, "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "title": "Разделять схемы OpenAPI для входа и выхода или нет", "chunk_index": 8, "header": "Не разделять схемы", "header_level": 2, "token_count": 243}
{"id": "222775eefa8e1ab2", "text": "### Одна и та же схема для входной и выходной моделей в документации { #same-schema-for-input-and-output-models-in-docs }\n\nТеперь для этой модели будет одна общая схема и для входа, и для выхода — только `Item`, и в ней `description` будет **не обязательным**:\n\n<div class=\"screenshot\">\n<img src=\"/img/tutorial/separate-openapi-schemas/image05.png\">\n</div>\n\nЭто то же поведение, что и в Pydantic v1.\n", "metadata": {"title": "Разделять схемы OpenAPI для входа и выхода или нет", "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "source_mtime": "2026-01-12T17:48:13.247189+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\separate-openapi-schemas.md"}, "doc_id": "d8bc02319707", "source_path": "docs\\how-to\\separate-openapi-schemas.md", "title": "Разделять схемы OpenAPI для входа и выхода или нет", "chunk_index": 9, "header": "Одна и та же схема для входной и выходной моделей в документации", "header_level": 3, "token_count": 136}
{"id": "304662c024eeb5fa", "text": "# Тестирование базы данных { #testing-a-database }\n\nВы можете изучить базы данных, SQL и SQLModel в <a href=\"https://sqlmodel.tiangolo.com/\" class=\"external-link\" target=\"_blank\">документации SQLModel</a>. \n\nЕсть мини-<a href=\"https://sqlmodel.tiangolo.com/tutorial/fastapi/\" class=\"external-link\" target=\"_blank\">руководство по использованию SQLModel с FastAPI</a>. \n\nВ этом руководстве есть раздел о <a href=\"https://sqlmodel.tiangolo.com/tutorial/fastapi/tests/\" class=\"external-link\" target=\"_blank\">тестировании SQL-баз данных</a>.\n", "metadata": {"title": "Тестирование базы данных", "doc_id": "04439a723fd6", "source_path": "docs\\how-to\\testing-database.md", "source_mtime": "2026-01-12T17:48:13.251445+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\how-to\\testing-database.md"}, "doc_id": "04439a723fd6", "source_path": "docs\\how-to\\testing-database.md", "title": "Тестирование базы данных", "chunk_index": 0, "header": "Тестирование базы данных", "header_level": 1, "token_count": 160}
{"id": "3f3d210c4bde42f9", "text": "# Обучение { #learn }\n\nЗдесь представлены вводные разделы и учебные пособия для изучения **FastAPI**.\n\nВы можете считать это **книгой**, **курсом**, **официальным** и рекомендуемым способом изучения FastAPI.\n", "metadata": {"title": "Обучение", "doc_id": "dd4b91a203e9", "source_path": "docs\\learn\\index.md", "source_mtime": "2026-01-12T17:48:13.266775+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\learn\\index.md"}, "doc_id": "dd4b91a203e9", "source_path": "docs\\learn\\index.md", "title": "Обучение", "chunk_index": 0, "header": "Обучение", "header_level": 1, "token_count": 87}
{"id": "5f85298fd57dcd57", "text": "# Ресурсы { #resources }\n\nДополнительные ресурсы, внешние ссылки и многое другое.\n", "metadata": {"title": "Ресурсы", "doc_id": "cb04add0cbab", "source_path": "docs\\resources\\index.md", "source_mtime": "2026-01-12T17:48:13.284189+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\resources\\index.md"}, "doc_id": "cb04add0cbab", "source_path": "docs\\resources\\index.md", "title": "Ресурсы", "chunk_index": 0, "header": "Ресурсы", "header_level": 1, "token_count": 33}
{"id": "1e047c48df2e1992", "text": "# Фоновые задачи { #background-tasks }\n\nВы можете создавать фоновые задачи, которые будут выполняться после возврата ответа.\n\nЭто полезно для операций, которые должны произойти после HTTP-запроса, но клиенту не обязательно ждать их завершения, чтобы получить ответ.\n\nНапример:\n\n* Уведомления по электронной почте, отправляемые после выполнения действия:\n    * Так как подключение к почтовому серверу и отправка письма обычно «медленные» (несколько секунд), вы можете сразу вернуть ответ, а отправку уведомления выполнить в фоне.\n* Обработка данных:\n    * Например, если вы получаете файл, который должен пройти через медленный процесс, вы можете вернуть ответ «Accepted» (HTTP 202) и обработать файл в фоне.\n\n", "metadata": {"title": "Фоновые задачи", "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "source_mtime": "2026-01-12T17:48:13.296577+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\background-tasks.md"}, "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "title": "Фоновые задачи", "chunk_index": 0, "header": "Фоновые задачи", "header_level": 1, "token_count": 259}
{"id": "1faa2bcd817b94ac", "text": "## Использование `BackgroundTasks` { #using-backgroundtasks }\n\nСначала импортируйте `BackgroundTasks` и объявите параметр в вашей функции‑обработчике пути с типом `BackgroundTasks`:\n\n{* ../../docs_src/background_tasks/tutorial001_py39.py hl[1,13] *}\n\n**FastAPI** создаст объект типа `BackgroundTasks` для вас и передаст его через этот параметр.\n\n", "metadata": {"title": "Фоновые задачи", "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "source_mtime": "2026-01-12T17:48:13.296577+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\background-tasks.md"}, "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "title": "Фоновые задачи", "chunk_index": 1, "header": "Использование `BackgroundTasks`", "header_level": 2, "token_count": 103}
{"id": "97659cb3603b0159", "text": "## Создание функции для фоновой задачи { #create-a-task-function }\n\nСоздайте функцию, которую нужно запустить как фоновую задачу.\n\nЭто обычная функция, которая может принимать параметры.\n\nЭто может быть как `async def`, так и обычная функция `def`, **FastAPI** знает, как корректно её выполнить.\n\nВ этом случае функция задачи будет записывать данные в файл (имитируя отправку письма).\n\nТак как операция записи не использует `async` и `await`, мы определим функцию как обычную `def`:\n\n{* ../../docs_src/background_tasks/tutorial001_py39.py hl[6:9] *}\n\n", "metadata": {"title": "Фоновые задачи", "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "source_mtime": "2026-01-12T17:48:13.296577+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\background-tasks.md"}, "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "title": "Фоновые задачи", "chunk_index": 2, "header": "Создание функции для фоновой задачи", "header_level": 2, "token_count": 182}
{"id": "1e9989ceff1a5649", "text": "## Добавление фоновой задачи { #add-the-background-task }\n\nВнутри вашей функции‑обработчика пути передайте функцию задачи объекту фоновых задач методом `.add_task()`:\n\n{* ../../docs_src/background_tasks/tutorial001_py39.py hl[14] *}\n\n`.add_task()` принимает следующие аргументы:\n\n* Функцию задачи, которую нужно выполнить в фоне (`write_notification`).\n* Последовательность позиционных аргументов, которые должны быть переданы функции задачи, в порядке (`email`).\n* Любые именованные аргументы, которые должны быть переданы функции задачи (`message=\"some notification\"`).\n\n", "metadata": {"title": "Фоновые задачи", "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "source_mtime": "2026-01-12T17:48:13.296577+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\background-tasks.md"}, "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "title": "Фоновые задачи", "chunk_index": 3, "header": "Добавление фоновой задачи", "header_level": 2, "token_count": 189}
{"id": "f4ec74ff2c8df262", "text": "## Встраивание зависимостей { #dependency-injection }\n\nИспользование `BackgroundTasks` также работает с системой встраивания зависимостей, вы можете объявить параметр типа `BackgroundTasks` на нескольких уровнях: в функции‑обработчике пути, в зависимости (dependable), в подзависимости и т. д.\n\n**FastAPI** знает, что делать в каждом случае и как переиспользовать один и тот же объект, так чтобы все фоновые задачи были объединены и затем выполнены в фоне:\n\n{* ../../docs_src/background_tasks/tutorial002_an_py310.py hl[13,15,22,25] *}\n\nВ этом примере сообщения будут записаны в файл `log.txt` после отправки ответа.\n\nЕсли в запросе была строка запроса (query), она будет записана в лог фоновой задачей.\n\nЗатем другая фоновая задача, созданная в функции‑обработчике пути, запишет сообщение, используя path‑параметр `email`.\n\n", "metadata": {"title": "Фоновые задачи", "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "source_mtime": "2026-01-12T17:48:13.296577+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\background-tasks.md"}, "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "title": "Фоновые задачи", "chunk_index": 4, "header": "Встраивание зависимостей", "header_level": 2, "token_count": 291}
{"id": "d0a3981784b4d475", "text": "## Технические детали { #technical-details }\n\nКласс `BackgroundTasks` приходит напрямую из <a href=\"https://www.starlette.dev/background/\" class=\"external-link\" target=\"_blank\">`starlette.background`</a>.\n\nОн импортируется/включается прямо в FastAPI, чтобы вы могли импортировать его из `fastapi` и избежать случайного импорта альтернативного `BackgroundTask` (без `s` на конце) из `starlette.background`.\n\nИспользуя только `BackgroundTasks` (а не `BackgroundTask`), его можно применять как параметр функции‑обработчика пути, и **FastAPI** сделает остальное за вас, как при использовании объекта `Request` напрямую.\n\nПо‑прежнему можно использовать один `BackgroundTask` в FastAPI, но тогда вам нужно создать объект в своём коде и вернуть Starlette `Response`, включающий его.\n\nПодробнее см. в <a href=\"https://www.starlette.dev/background/\" class=\"external-link\" target=\"_blank\">официальной документации Starlette по фоновым задачам</a>.\n\n", "metadata": {"title": "Фоновые задачи", "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "source_mtime": "2026-01-12T17:48:13.296577+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\background-tasks.md"}, "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "title": "Фоновые задачи", "chunk_index": 5, "header": "Технические детали", "header_level": 2, "token_count": 318}
{"id": "abcf66b0b32fc4cb", "text": "## Предостережение { #caveat }\n\nЕсли вам нужно выполнять тяжелые вычисления в фоне, и при этом они не обязательно должны запускаться тем же процессом (например, вам не нужно делиться памятью, переменными и т. п.), вам могут подойти более мощные инструменты, такие как <a href=\"https://docs.celeryq.dev\" class=\"external-link\" target=\"_blank\">Celery</a>.\n\nОни обычно требуют более сложной конфигурации, менеджера очереди сообщений/заданий (например, RabbitMQ или Redis), но позволяют запускать фоновые задачи в нескольких процессах и, что особенно важно, на нескольких серверах.\n\nНо если вам нужен доступ к переменным и объектам из того же приложения **FastAPI**, или нужно выполнять небольшие фоновые задачи (например, отправку email‑уведомления), вы можете просто использовать `BackgroundTasks`.\n\n", "metadata": {"title": "Фоновые задачи", "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "source_mtime": "2026-01-12T17:48:13.296577+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\background-tasks.md"}, "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "title": "Фоновые задачи", "chunk_index": 6, "header": "Предостережение", "header_level": 2, "token_count": 310}
{"id": "f086158faec86189", "text": "## Резюме { #recap }\n\nИмпортируйте и используйте `BackgroundTasks` с параметрами в функциях‑обработчиках пути и зависимостях, чтобы добавлять фоновые задачи.\n", "metadata": {"title": "Фоновые задачи", "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "source_mtime": "2026-01-12T17:48:13.296577+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\background-tasks.md"}, "doc_id": "4c4d4dc031ec", "source_path": "docs\\tutorial\\background-tasks.md", "title": "Фоновые задачи", "chunk_index": 7, "header": "Резюме", "header_level": 2, "token_count": 64}
{"id": "464f6c0f83fc5d4d", "text": "# Большие приложения, в которых много файлов { #bigger-applications-multiple-files }\n\nПри построении приложения или веб-API нам редко удается поместить всё в один файл.\n\n**FastAPI** предоставляет удобный инструментарий, который позволяет нам структурировать приложение, сохраняя при этом всю необходимую гибкость.\n\n/// info | Примечание\n\nЕсли вы раньше использовали Flask, то это аналог шаблонов Flask (Flask's Blueprints).\n\n///\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 0, "header": "Большие приложения, в которых много файлов", "header_level": 1, "token_count": 150}
{"id": "464f6c0f83fc5d4d", "text": "## Пример структуры приложения { #an-example-file-structure }\n\nДавайте предположим, что наше приложение имеет следующую структуру:\n\n```\n.\n├── app\n│   ├── __init__.py\n│   ├── main.py\n│   ├── dependencies.py\n│   └── routers\n│   │   ├── __init__.py\n│   │   ├── items.py\n│   │   └── users.py\n│   └── internal\n│       ├── __init__.py\n│       └── admin.py\n```\n\n/// tip | Подсказка\n\nОбратите внимание, что в каждом каталоге и подкаталоге имеется файл `__init__.py`\n\nЭто как раз то, что позволяет импортировать код из одного файла в другой.\n\nНапример, в файле `app/main.py` может быть следующая строка:\n\n```\nfrom app.routers import items\n```\n\n///", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md", "section_header": "Пример структуры приложения", "section_header_level": 2}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 1, "header": "Пример структуры приложения", "header_level": 2, "token_count": 236}
{"id": "e3b8771d012799ff", "text": "`__init__.py`\n\nЭто как раз то, что позволяет импортировать код из одного файла в другой.\n\nНапример, в файле `app/main.py` может быть следующая строка:\n\n```\nfrom app.routers import items\n```\n\n///\n\n* Всё помещается в каталоге `app`. В нём также находится пустой файл `app/__init__.py`. Таким образом, `app` является \"Python-пакетом\" (коллекцией модулей Python).\n* Он содержит файл `app/main.py`. Данный файл является частью пакета (т.е. находится внутри каталога, содержащего файл `__init__.py`), и, соответственно, он является модулем пакета: `app.main`.\n* Он также содержит файл `app/dependencies.py`, который также, как и `app/main.py`, является модулем: `app.dependencies`.\n* Здесь также находится подкаталог `app/routers/`, содержащий `__init__.py`.  Он является суб-пакетом: `app.routers`.\n* Файл `app/routers/items.py` находится внутри пакета `app/routers/`. Таким образом, он является суб-модулем: `app.routers.items`.\n* Точно также `app/routers/users.py` является ещё одним суб-модулем: `app.routers.users`.\n* Подкаталог `app/internal/`, содержащий файл `__init__.py`, является ещё одним суб-пакетом: `app.internal`.\n* А файл `app/internal/admin.py` является ещё одним суб-модулем: `app.internal.admin`.\n\n<img src=\"/img/tutorial/bigger-applications/package.drawio.svg\">", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md", "section_header": "Пример структуры приложения", "section_header_level": 2}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 2, "header": "Пример структуры приложения", "header_level": 2, "token_count": 487}
{"id": "45b111ab5e3aa784", "text": "ещё одним суб-пакетом: `app.internal`.\n* А файл `app/internal/admin.py` является ещё одним суб-модулем: `app.internal.admin`.\n\n<img src=\"/img/tutorial/bigger-applications/package.drawio.svg\">\n\nТа же самая файловая структура приложения, но с комментариями:\n\n```\n.\n├── app                  # \"app\" пакет\n│   ├── __init__.py      # этот файл превращает \"app\" в \"Python-пакет\"\n│   ├── main.py          # модуль \"main\", напр.: import app.main\n│   ├── dependencies.py  # модуль \"dependencies\", напр.: import app.dependencies\n│   └── routers          # суб-пакет \"routers\"\n│   │   ├── __init__.py  # превращает \"routers\" в суб-пакет\n│   │   ├── items.py     # суб-модуль \"items\", напр.: import app.routers.items\n│   │   └── users.py     # суб-модуль \"users\", напр.: import app.routers.users\n│   └── internal         # суб-пакет \"internal\"\n│       ├── __init__.py  # превращает \"internal\" в суб-пакет\n│       └── admin.py     # суб-модуль \"admin\", напр.: import app.internal.admin\n```", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md", "section_header": "Пример структуры приложения", "section_header_level": 2}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 3, "header": "Пример структуры приложения", "header_level": 2, "token_count": 346}
{"id": "bc805ce73dbc9a19", "text": "## `APIRouter` { #apirouter }\n\nДавайте предположим, что для работы с пользователями используется отдельный файл (суб-модуль) `/app/routers/users.py`.\n\nДля лучшей организации приложения, вы хотите отделить операции пути, связанные с пользователями, от остального кода.\n\nНо так, чтобы эти операции по-прежнему оставались частью **FastAPI** приложения/веб-API (частью одного пакета)\n\nС помощью  `APIRouter` вы можете создать *операции пути* (*эндпоинты*) для данного модуля.\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 4, "header": "`APIRouter`", "header_level": 2, "token_count": 182}
{"id": "e19c63ef67328356", "text": "### Импорт `APIRouter` { #import-apirouter }\n\nТочно также, как и в случае с классом `FastAPI`, вам нужно импортировать и создать объект класса `APIRouter`.\n\n{* ../../docs_src/bigger_applications/app_an_py39/routers/users.py hl[1,3] title[\"app/routers/users.py\"] *}\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 5, "header": "Импорт `APIRouter`", "header_level": 3, "token_count": 86}
{"id": "67b0dff84d69e6a3", "text": "### Создание *эндпоинтов* с помощью `APIRouter` { #path-operations-with-apirouter }\n\nВ дальнейшем используйте `APIRouter` для объявления *эндпоинтов*, точно также, как вы используете класс `FastAPI`:\n\n{* ../../docs_src/bigger_applications/app_an_py39/routers/users.py hl[6,11,16] title[\"app/routers/users.py\"] *}\n\nВы можете думать об `APIRouter` как об \"уменьшенной версии\" класса FastAPI`.\n\n`APIRouter` поддерживает все те же самые опции.\n\n`APIRouter` поддерживает все те же самые параметры, такие как `parameters`, `responses`, `dependencies`, `tags`, и т. д.\n\n/// tip | Подсказка\n\nВ данном примере, в качестве названия переменной используется `router`, но вы можете использовать любое другое имя.\n\n///\n\nМы собираемся подключить данный `APIRouter` к нашему основному приложению на `FastAPI`, но сначала давайте проверим зависимости и создадим ещё один модуль с `APIRouter`.\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 6, "header": "Создание *эндпоинтов* с помощью `APIRouter`", "header_level": 3, "token_count": 310}
{"id": "6d3060345e3870dc", "text": "## Зависимости { #dependencies }\n\nНам понадобятся некоторые зависимости, которые мы будем использовать в разных местах нашего приложения.\n\nМы поместим их в отдельный модуль `dependencies` (`app/dependencies.py`).\n\nТеперь мы воспользуемся простой зависимостью, чтобы прочитать кастомизированный `X-Token` из заголовка:\n\n{* ../../docs_src/bigger_applications/app_an_py39/dependencies.py hl[3,6:8] title[\"app/dependencies.py\"] *}\n\n/// tip | Подсказка\n\nДля простоты мы воспользовались неким воображаемым заголовоком.\n\nВ реальных случаях для получения наилучших результатов используйте интегрированные [утилиты безопасности](security/index.md){.internal-link target=_blank}.\n\n///\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 7, "header": "Зависимости", "header_level": 2, "token_count": 235}
{"id": "464f6c0f83fc5d4d", "text": "## Ещё один модуль с `APIRouter` { #another-module-with-apirouter }\n\nДавайте также предположим, что у вас есть *эндпоинты*, отвечающие за обработку \"items\", и они находятся в модуле `app/routers/items.py`.\n\nУ вас определены следующие *операции пути* (*эндпоинты*):\n\n* `/items/`\n* `/items/{item_id}`\n\nТут всё точно также, как и в ситуации с `app/routers/users.py`.\n\nНо теперь мы хотим поступить немного умнее и слегка упростить код.\n\nМы знаем, что все *эндпоинты* данного модуля имеют некоторые общие свойства:\n\n* Префикс пути: `/items`.\n* Теги: (один единственный тег: `items`).\n* Дополнительные ответы (responses)\n* Зависимости: использование созданной нами зависимости `X-token`\n\nТаким образом, вместо того чтобы добавлять все эти свойства в функцию каждого отдельного *эндпоинта*,\nмы добавим их в `APIRouter`.\n\n{* ../../docs_src/bigger_applications/app_an_py39/routers/items.py hl[5:10,16,21] title[\"app/routers/items.py\"] *}\n\nТак как каждый *эндпоинт* начинается с символа `/`:\n\n```Python hl_lines=\"1\"\n@router.get(\"/{item_id}\")\nasync def read_item(item_id: str):\n    ...\n```\n\n...то префикс не должен заканчиваться символом `/`.\n\nВ нашем случае префиксом является `/items`.", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md", "section_header": "Ещё один модуль с `APIRouter`", "section_header_level": 2}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 8, "header": "Ещё один модуль с `APIRouter`", "header_level": 2, "token_count": 458}
{"id": "e3b8771d012799ff", "text": "_lines=\"1\"\n@router.get(\"/{item_id}\")\nasync def read_item(item_id: str):\n    ...\n```\n\n...то префикс не должен заканчиваться символом `/`.\n\nВ нашем случае префиксом является `/items`.\n\nМы также можем добавить в наш маршрутизатор (router) список `тегов` (`tags`) и дополнительных `ответов` (`responses`), которые являются общими для каждого *эндпоинта*.\n\nИ ещё мы можем добавить в наш маршрутизатор список `зависимостей`, которые должны вызываться при каждом обращении к *эндпоинтам*.\n\n/// tip | Подсказка\n\nОбратите внимание, что также, как и в случае с зависимостями в декораторах *эндпоинтов* ([зависимости в декораторах операций пути](dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank}), никакого значения в *функцию эндпоинта* передано не будет.\n\n///\n\nВ результате мы получим следующие эндпоинты:\n\n* `/items/`\n* `/items/{item_id}`\n\n...как мы и планировали.", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md", "section_header": "Ещё один модуль с `APIRouter`", "section_header_level": 2}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 9, "header": "Ещё один модуль с `APIRouter`", "header_level": 2, "token_count": 341}
{"id": "45b111ab5e3aa784", "text": "акого значения в *функцию эндпоинта* передано не будет.\n\n///\n\nВ результате мы получим следующие эндпоинты:\n\n* `/items/`\n* `/items/{item_id}`\n\n...как мы и планировали.\n\n* Они будут помечены тегами из заданного списка, в нашем случае это `\"items\"`.\n    * Эти теги особенно полезны для системы автоматической интерактивной документации (с использованием OpenAPI).\n* Каждый из них будет включать предопределенные ответы `responses`.\n* Каждый *эндпоинт* будет иметь список зависимостей (`dependencies`), исполняемых перед вызовом *эндпоинта*.\n    * Если вы определили зависимости в самой операции пути, **то она также будет выполнена**.\n    * Сначала выполняются зависимости маршрутизатора, затем вызываются [зависимости в декораторе](dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank}, и, наконец, обычные параметрические зависимости.\n    * Вы также можете добавить [зависимости `Security` с `scopes`](../advanced/security/oauth2-scopes.md){.internal-link target=_blank}.\n\n/// tip | Подсказка\n\nНапример, с помощью зависимостей в `APIRouter` мы можем потребовать аутентификации для доступа ко всей группе *эндпоинтов*, не указывая зависимости для каждой отдельной функции *эндпоинта*.\n\n///\n\n/// check | Заметка\n\nПараметры `prefix`, `tags`, `responses` и `dependencies` относятся к функционалу **FastAPI**, помогающему избежать дублирования кода.\n\n///", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md", "section_header": "Ещё один модуль с `APIRouter`", "section_header_level": 2}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 10, "header": "Ещё один модуль с `APIRouter`", "header_level": 2, "token_count": 500}
{"id": "464f6c0f83fc5d4d", "text": "### Импорт зависимостей { #import-the-dependencies }\n\nНаш код находится в модуле `app.routers.items` (файл `app/routers/items.py`).\n\nИ нам нужно вызвать функцию зависимости из модуля `app.dependencies` (файл `app/dependencies.py`).\n\nМы используем операцию относительного импорта `..` для импорта зависимости:\n\n{* ../../docs_src/bigger_applications/app_an_py39/routers/items.py hl[3] title[\"app/routers/items.py\"] *}\n\n#### Как работает относительный импорт? { #how-relative-imports-work }\n\n/// tip | Подсказка\n\nЕсли вы прекрасно знаете, как работает импорт в Python, то переходите к следующему разделу.\n\n///\n\nОдна точка `.`, как в данном примере:\n\n```Python\nfrom .dependencies import get_token_header\n```\nозначает:\n\n* Начните с пакета, в котором находится данный модуль (файл `app/routers/items.py` расположен в каталоге `app/routers/`)...\n* ... найдите модуль `dependencies` (файл `app/routers/dependencies.py`)...\n* ... и импортируйте из него функцию `get_token_header`.\n\nК сожалению, такого файла не существует, и наши зависимости находятся в файле `app/dependencies.py`.\n\nВспомните, как выглядит файловая структура нашего приложения:\n\n<img src=\"/img/tutorial/bigger-applications/package.drawio.svg\">\n\n---\n\nДве точки `..`, как в данном примере:\n\n```Python\nfrom ..dependencies import get_token_header\n```\n\nозначают:", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md", "section_header": "Импорт зависимостей", "section_header_level": 3}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 11, "header": "Импорт зависимостей", "header_level": 3, "token_count": 445}
{"id": "e3b8771d012799ff", "text": "ит файловая структура нашего приложения:\n\n<img src=\"/img/tutorial/bigger-applications/package.drawio.svg\">\n\n---\n\nДве точки `..`, как в данном примере:\n\n```Python\nfrom ..dependencies import get_token_header\n```\n\nозначают:\n\n* Начните с пакета, в котором находится данный модуль (файл `app/routers/items.py` находится в каталоге `app/routers/`)...\n* ... перейдите в родительский пакет (каталог `app/`)...\n* ... найдите в нём модуль `dependencies` (файл `app/dependencies.py`)...\n* ... и импортируйте из него функцию `get_token_header`.\n\nЭто работает верно! \n\n---\n\nАналогично, если бы мы использовали три точки `...`, как здесь:\n\n```Python\nfrom ...dependencies import get_token_header\n```\n\nто это бы означало:\n\n* Начните с пакета, в котором находится данный модуль (файл `app/routers/items.py` находится в каталоге `app/routers/`)...\n* ... перейдите в родительский пакет (каталог `app/`)...\n* ... затем перейдите в родительский пакет текущего пакета (такого пакета не существует, `app` находится на самом верхнем уровне )...\n* ... найдите в нём модуль `dependencies` (файл `app/dependencies.py`)...\n* ... и импортируйте из него функцию `get_token_header`.\n\nЭто будет относиться к некоторому пакету, находящемуся на один уровень выше чем `app/` и содержащему свой собственный файл `__init__.py`. Но ничего такого у нас нет. Поэтому это приведет к ошибке в нашем примере.", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md", "section_header": "Импорт зависимостей", "section_header_level": 3}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 12, "header": "Импорт зависимостей", "header_level": 3, "token_count": 504}
{"id": "45b111ab5e3aa784", "text": "ровень выше чем `app/` и содержащему свой собственный файл `__init__.py`. Но ничего такого у нас нет. Поэтому это приведет к ошибке в нашем примере. \n\nТеперь вы знаете, как работает импорт в Python, и сможете использовать относительное импортирование в своих собственных приложениях любого уровня сложности.", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md", "section_header": "Импорт зависимостей", "section_header_level": 3}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 13, "header": "Импорт зависимостей", "header_level": 3, "token_count": 124}
{"id": "6568f573f34cb9e9", "text": "### Добавление пользовательских тегов (`tags`), ответов (`responses`) и зависимостей (`dependencies`) { #add-some-custom-tags-responses-and-dependencies }\n\nМы не будем добавлять префикс `/items` и список тегов `tags=[\"items\"]` для каждого *эндпоинта*, т.к. мы уже их добавили с помощью `APIRouter`.\n\nНо помимо этого мы можем добавить новые теги для каждого отдельного *эндпоинта*, а также некоторые дополнительные ответы (`responses`), характерные для данного *эндпоинта*:\n\n{* ../../docs_src/bigger_applications/app_an_py39/routers/items.py hl[30:31] title[\"app/routers/items.py\"] *}\n\n/// tip | Подсказка\n\nПоследний *эндпоинт* будет иметь следующую комбинацию тегов: `[\"items\", \"custom\"]`.\n\nА также в его документации будут содержаться оба ответа: один для `404` и другой для `403`.\n\n///\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 14, "header": "Добавление пользовательских тегов (`tags`), ответов (`responses`) и зависимостей (`dependencies`)", "header_level": 3, "token_count": 280}
{"id": "1475c612a616c85d", "text": "## Модуль main в `FastAPI` { #the-main-fastapi }\n\nТеперь давайте посмотрим на модуль `app/main.py`.\n\nИменно сюда вы импортируете и именно здесь вы используете класс `FastAPI`.\n\nЭто основной файл вашего приложения, который объединяет всё в одно целое.\n\nИ теперь, когда большая часть логики приложения разделена на отдельные модули, основной файл `app/main.py` будет достаточно простым.\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 15, "header": "Модуль main в `FastAPI`", "header_level": 2, "token_count": 149}
{"id": "8ce479e8738c8765", "text": "### Импорт `FastAPI` { #import-fastapi }\n\nВы импортируете и создаете класс `FastAPI` как обычно.\n\nМы даже можем объявить [глобальные зависимости](dependencies/global-dependencies.md){.internal-link target=_blank}, которые будут объединены с зависимостями для каждого отдельного маршрутизатора:\n\n{* ../../docs_src/bigger_applications/app_an_py39/main.py hl[1,3,7] title[\"app/main.py\"] *}\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 16, "header": "Импорт `FastAPI`", "header_level": 3, "token_count": 134}
{"id": "fd9bcfb853b1fc85", "text": "### Импорт `APIRouter` { #import-the-apirouter }\n\nТеперь мы импортируем другие суб-модули, содержащие `APIRouter`:\n\n{* ../../docs_src/bigger_applications/app_an_py39/main.py hl[4:5] title[\"app/main.py\"] *}\n\nТак как файлы `app/routers/users.py` и `app/routers/items.py` являются суб-модулями одного и того же Python-пакета `app`, то мы сможем их импортировать, воспользовавшись операцией относительного импорта `.`.\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 17, "header": "Импорт `APIRouter`", "header_level": 3, "token_count": 160}
{"id": "a252d4474e690fac", "text": "### Как работает импорт? { #how-the-importing-works }\n\nДанная строка кода:\n\n```Python\nfrom .routers import items, users\n```\n\nозначает:\n\n* Начните с пакета, в котором содержится данный модуль (файл `app/main.py` содержится в каталоге `app/`)...\n* ... найдите суб-пакет `routers` (каталог `app/routers/`)...\n* ... и из него импортируйте суб-модули `items` (файл `app/routers/items.py`) и `users` (файл `app/routers/users.py`)...\n\nВ модуле `items` содержится переменная `router` (`items.router`), та самая, которую мы создали в файле `app/routers/items.py`, она является объектом класса `APIRouter`.\n\nИ затем мы сделаем то же самое для модуля `users`.\n\nМы также могли бы импортировать и другим методом:\n\n```Python\nfrom app.routers import items, users\n```\n\n/// info | Примечание\n\nПервая версия является примером относительного импорта:\n\n```Python\nfrom .routers import items, users\n```\n\nВторая версия является примером абсолютного импорта:\n\n```Python\nfrom app.routers import items, users\n```\n\nУзнать больше о пакетах и модулях в Python вы можете из <a href=\"https://docs.python.org/3/tutorial/modules.html\" class=\"external-link\" target=\"_blank\">официальной документации Python о модулях</a>\n\n///\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 18, "header": "Как работает импорт?", "header_level": 3, "token_count": 420}
{"id": "dc178e895fb1fc5c", "text": "### Избегайте конфликтов имен { #avoid-name-collisions }\n\nВместо того чтобы импортировать только переменную `router`, мы импортируем непосредственно суб-модуль `items`.\n\nМы делаем это потому, что у нас есть ещё одна переменная `router` в суб-модуле `users`.\n\nЕсли бы мы импортировали их одну за другой, как показано в примере:\n\n```Python\nfrom .routers.items import router\nfrom .routers.users import router\n```\n\nто переменная `router` из `users` переписал бы переменную `router` из `items`, и у нас не было бы возможности использовать их одновременно.\n\nПоэтому, для того чтобы использовать обе эти переменные в одном файле, мы импортировали соответствующие суб-модули:\n\n{* ../../docs_src/bigger_applications/app_an_py39/main.py hl[5] title[\"app/main.py\"] *}\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 19, "header": "Избегайте конфликтов имен", "header_level": 3, "token_count": 263}
{"id": "3efc062262246380", "text": "### Подключение маршрутизаторов (`APIRouter`) для `users` и для `items` { #include-the-apirouters-for-users-and-items }\n\nДавайте подключим маршрутизаторы (`router`) из суб-модулей `users` и `items`:\n\n{* ../../docs_src/bigger_applications/app_an_py39/main.py hl[10:11] title[\"app/main.py\"] *}\n\n/// info | Примечание\n\n`users.router` содержит `APIRouter` из файла `app/routers/users.py`.\n\nА `items.router` содержит `APIRouter` из файла `app/routers/items.py`.\n\n///\n\nС помощью `app.include_router()` мы можем добавить каждый из маршрутизаторов (`APIRouter`) в основное приложение `FastAPI`.\n\nОн подключит все маршруты заданного маршрутизатора к нашему приложению.\n\n/// note | Технические детали\n\nФактически, внутри он создаст все *операции пути* для каждой операции пути объявленной в `APIRouter`.\n\nИ под капотом всё будет работать так, как будто бы мы имеем дело с одним файлом приложения.\n\n///\n\n/// check | Заметка\n\nПри подключении маршрутизаторов не стоит беспокоиться о производительности.\n\nОперация подключения займёт микросекунды и понадобится только при запуске приложения.\n\nТаким образом, это не повлияет на производительность. \n\n///\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 20, "header": "Подключение маршрутизаторов (`APIRouter`) для `users` и для `items`", "header_level": 3, "token_count": 404}
{"id": "464f6c0f83fc5d4d", "text": "### Подключение `APIRouter` с пользовательскими префиксом (`prefix`), тегами (`tags`), ответами (`responses`), и зависимостями (`dependencies`) { #include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies }\n\nТеперь давайте представим, что ваша организация передала вам файл `app/internal/admin.py`.\n\nОн содержит `APIRouter` с некоторыми *эндпоитами* администрирования, которые ваша организация использует для нескольких проектов.\n\nВ данном примере это сделать очень просто. Но давайте предположим, что поскольку файл используется для нескольких проектов,\nто мы не можем модифицировать его, добавляя префиксы (`prefix`), зависимости (`dependencies`), теги (`tags`), и т.д. непосредственно в `APIRouter`:\n\n{* ../../docs_src/bigger_applications/app_an_py39/internal/admin.py hl[3] title[\"app/internal/admin.py\"] *}\n\nНо, несмотря на это, мы хотим использовать кастомный префикс (`prefix`) для подключенного маршрутизатора (`APIRouter`), в результате чего, каждая *операция пути* будет начинаться с `/admin`. Также мы хотим защитить наш маршрутизатор с помощью зависимостей, созданных для нашего проекта. И ещё мы хотим включить теги (`tags`) и ответы (`responses`).\n\nМы можем применить все вышеперечисленные настройки, не изменяя начальный `APIRouter`. Нам всего лишь нужно передать нужные параметры в `app.include_router()`.\n\n{* ../../docs_src/bigger_applications/app_an_py39/main.py hl[14:17] title[\"app/main.py\"] *}", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md", "section_header": "Подключение `APIRouter` с пользовательскими префиксом (`prefix`), тегами (`tags`), ответами (`responses`), и зависимостями (`dependencies`)", "section_header_level": 3}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 21, "header": "Подключение `APIRouter` с пользовательскими префиксом (`prefix`), тегами (`tags`), ответами (`responses`), и зависимостями (`dependencies`)", "header_level": 3, "token_count": 498}
{"id": "e3b8771d012799ff", "text": "настройки, не изменяя начальный `APIRouter`. Нам всего лишь нужно передать нужные параметры в `app.include_router()`.\n\n{* ../../docs_src/bigger_applications/app_an_py39/main.py hl[14:17] title[\"app/main.py\"] *}\n\nТаким образом, оригинальный `APIRouter` не будет модифицирован, и мы сможем использовать файл `app/internal/admin.py` сразу в нескольких проектах организации.\n\nВ результате, в нашем приложении каждый *эндпоинт* модуля `admin` будет иметь:\n\n* Префикс `/admin`.\n* Тег `admin`.\n* Зависимость `get_token_header`.\n* Ответ `418`. \n\nЭто будет иметь место исключительно для `APIRouter` в нашем приложении, и не затронет любой другой код, использующий его.\n\nНапример, другие проекты, могут использовать тот же самый `APIRouter` с другими методами аутентификации.", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md", "section_header": "Подключение `APIRouter` с пользовательскими префиксом (`prefix`), тегами (`tags`), ответами (`responses`), и зависимостями (`dependencies`)", "section_header_level": 3}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 22, "header": "Подключение `APIRouter` с пользовательскими префиксом (`prefix`), тегами (`tags`), ответами (`responses`), и зависимостями (`dependencies`)", "header_level": 3, "token_count": 275}
{"id": "9b2c7b80fff04e8d", "text": "### Подключение отдельного *эндпоинта* { #include-a-path-operation }\n\nМы также можем добавить *эндпоинт* непосредственно в основное приложение `FastAPI`.\n\nЗдесь мы это делаем ... просто, чтобы показать, что это возможно :\n\n{* ../../docs_src/bigger_applications/app_an_py39/main.py hl[21:23] title[\"app/main.py\"] *}\n\nи это будет работать корректно вместе с другими *эндпоинтами*, добавленными с помощью `app.include_router()`.\n\n/// info | Сложные технические детали\n\n**Примечание**: это сложная техническая деталь, которую, скорее всего, **вы можете пропустить**.\n\n---\n\nМаршрутизаторы (`APIRouter`) не \"монтируются\" по-отдельности и не изолируются от остального приложения.\n\nЭто происходит потому, что нужно включить их *эндпоинты* в OpenAPI схему и в интерфейс пользователя.\n\nВ силу того, что мы не можем их изолировать и \"примонтировать\" независимо от остальных, *эндпоинты* клонируются (пересоздаются) и не подключаются напрямую.\n\n///\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 23, "header": "Подключение отдельного *эндпоинта*", "header_level": 3, "token_count": 372}
{"id": "9a4b41930e447a2b", "text": "## Проверка автоматической документации API { #check-the-automatic-api-docs }\n\nТеперь запустите приложение:\n\n<div class=\"termy\">\n\n```console\n$ fastapi dev app/main.py\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n</div>\n\nОткройте документацию по адресу <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a>.\n\nВы увидите автоматическую API документацию. Она включает в себя маршруты из суб-модулей, используя верные маршруты, префиксы и теги:\n\n<img src=\"/img/tutorial/bigger-applications/image01.png\">\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 24, "header": "Проверка автоматической документации API", "header_level": 2, "token_count": 222}
{"id": "c94bb923f3e883e9", "text": "## Подключение существующего маршрута через новый префикс (`prefix`) { #include-the-same-router-multiple-times-with-different-prefix }\n\nВы можете использовать `.include_router()` несколько раз с одним и тем же маршрутом, применив различные префиксы.\n\nЭто может быть полезным, если нужно предоставить доступ к одному и тому же API через различные префиксы, например, `/api/v1` и `/api/latest`.\n\nЭто продвинутый способ, который вам может и не пригодится. Мы приводим его на случай, если вдруг вам это понадобится.\n\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 25, "header": "Подключение существующего маршрута через новый префикс (`prefix`)", "header_level": 2, "token_count": 180}
{"id": "fc2740fe70b11135", "text": "## Включение одного маршрутизатора (`APIRouter`) в другой { #include-an-apirouter-in-another }\n\nТочно так же, как вы включаете `APIRouter` в приложение `FastAPI`, вы можете включить `APIRouter` в другой `APIRouter`:\n\n```Python\nrouter.include_router(other_router)\n```\n\nУдостоверьтесь, что вы сделали это до того, как подключить маршрутизатор  (`router`) к вашему `FastAPI` приложению, и *эндпоинты* маршрутизатора `other_router` были также подключены.\n", "metadata": {"title": "Большие приложения, в которых много файлов", "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "source_mtime": "2026-01-12T17:48:13.307184+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\bigger-applications.md"}, "doc_id": "794900f2ce29", "source_path": "docs\\tutorial\\bigger-applications.md", "title": "Большие приложения, в которых много файлов", "chunk_index": 26, "header": "Включение одного маршрутизатора (`APIRouter`) в другой", "header_level": 2, "token_count": 163}
{"id": "f442fe260a8e265a", "text": "# Body - Поля { #body-fields }\n\nТаким же способом, как вы объявляете дополнительную валидацию и метаданные в параметрах *функции обработки пути* с помощью функций `Query`, `Path` и `Body`, вы можете объявлять валидацию и метаданные внутри Pydantic моделей, используя функцию `Field` из Pydantic.\n\n", "metadata": {"title": "Body - Поля", "doc_id": "ec9188fc5d2c", "source_path": "docs\\tutorial\\body-fields.md", "source_mtime": "2026-01-12T17:48:13.310948+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-fields.md"}, "doc_id": "ec9188fc5d2c", "source_path": "docs\\tutorial\\body-fields.md", "title": "Body - Поля", "chunk_index": 0, "header": "Body - Поля", "header_level": 1, "token_count": 118}
{"id": "096642abd5e64d4f", "text": "## Импорт `Field` { #import-field }\n\nСначала вы должны импортировать его:\n\n{* ../../docs_src/body_fields/tutorial001_an_py310.py hl[4] *}\n\n/// warning | Внимание\n\nОбратите внимание, что функция `Field` импортируется непосредственно из `pydantic`, а не из `fastapi`, как все остальные функции (`Query`, `Path`, `Body` и т.д.).\n\n///\n\n", "metadata": {"title": "Body - Поля", "doc_id": "ec9188fc5d2c", "source_path": "docs\\tutorial\\body-fields.md", "source_mtime": "2026-01-12T17:48:13.310948+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-fields.md"}, "doc_id": "ec9188fc5d2c", "source_path": "docs\\tutorial\\body-fields.md", "title": "Body - Поля", "chunk_index": 1, "header": "Импорт `Field`", "header_level": 2, "token_count": 115}
{"id": "86d8f315a5f24958", "text": "## Объявление атрибутов модели { #declare-model-attributes }\n\nВы можете использовать функцию `Field` с атрибутами модели:\n\n{* ../../docs_src/body_fields/tutorial001_an_py310.py hl[11:14] *}\n\nФункция `Field` работает так же, как `Query`, `Path` и `Body`, у неё такие же параметры и т.д.\n\n/// note | Технические детали\n\nНа самом деле, `Query`, `Path` и другие функции, которые вы увидите в дальнейшем, создают объекты подклассов общего класса `Param`, который сам по себе является подклассом `FieldInfo` из Pydantic.\n\nИ `Field` (из Pydantic) также возвращает экземпляр `FieldInfo`.\n\n`Body` также напрямую возвращает объекты подкласса `FieldInfo`. И есть и другие, с которыми вы познакомитесь позже, которые являются подклассами класса `Body`.\n\nПомните, что когда вы импортируете `Query`, `Path` и другое из `fastapi`, это фактически функции, которые возвращают специальные классы.\n\n///\n\n/// tip | Подсказка\n\nОбратите внимание, что каждый атрибут модели с типом, значением по умолчанию и `Field` имеет ту же структуру, что и параметр *функции обработки пути* с `Field` вместо `Path`, `Query` и `Body`.\n\n///\n\n", "metadata": {"title": "Body - Поля", "doc_id": "ec9188fc5d2c", "source_path": "docs\\tutorial\\body-fields.md", "source_mtime": "2026-01-12T17:48:13.310948+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-fields.md"}, "doc_id": "ec9188fc5d2c", "source_path": "docs\\tutorial\\body-fields.md", "title": "Body - Поля", "chunk_index": 2, "header": "Объявление атрибутов модели", "header_level": 2, "token_count": 418}
{"id": "2165e06101767c63", "text": "## Добавление дополнительной информации { #add-extra-information }\n\nВы можете объявлять дополнительную информацию в `Field`, `Query`, `Body` и т.п. Она будет включена в сгенерированную JSON схему.\n\nВы узнаете больше о добавлении дополнительной информации позже в документации, когда будете изучать, как задавать примеры.\n\n/// warning | Внимание\n\nДополнительные ключи, переданные в функцию `Field`, также будут присутствовать в сгенерированной OpenAPI схеме вашего приложения.\nПоскольку эти ключи не являются обязательной частью спецификации OpenAPI, некоторые инструменты OpenAPI, например, [валидатор OpenAPI](https://validator.swagger.io/), могут не работать с вашей сгенерированной схемой.\n\n///\n\n", "metadata": {"title": "Body - Поля", "doc_id": "ec9188fc5d2c", "source_path": "docs\\tutorial\\body-fields.md", "source_mtime": "2026-01-12T17:48:13.310948+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-fields.md"}, "doc_id": "ec9188fc5d2c", "source_path": "docs\\tutorial\\body-fields.md", "title": "Body - Поля", "chunk_index": 3, "header": "Добавление дополнительной информации", "header_level": 2, "token_count": 252}
{"id": "24a7f3817c09435e", "text": "## Резюме { #recap }\n\nВы можете использовать функцию `Field` из Pydantic, чтобы задавать дополнительную валидацию и метаданные для атрибутов модели.\n\nВы также можете использовать дополнительные ключевые аргументы, чтобы добавить метаданные JSON схемы.\n", "metadata": {"title": "Body - Поля", "doc_id": "ec9188fc5d2c", "source_path": "docs\\tutorial\\body-fields.md", "source_mtime": "2026-01-12T17:48:13.310948+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-fields.md"}, "doc_id": "ec9188fc5d2c", "source_path": "docs\\tutorial\\body-fields.md", "title": "Body - Поля", "chunk_index": 4, "header": "Резюме", "header_level": 2, "token_count": 90}
{"id": "64d8815ae2b58a13", "text": "# Body - Множество параметров { #body-multiple-parameters }\n\nТеперь, когда мы увидели, как использовать `Path` и `Query` параметры, давайте рассмотрим более продвинутые примеры объявления тела запроса.\n\n", "metadata": {"title": "Body - Множество параметров", "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "source_mtime": "2026-01-12T17:48:13.316853+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-multiple-params.md"}, "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "title": "Body - Множество параметров", "chunk_index": 0, "header": "Body - Множество параметров", "header_level": 1, "token_count": 73}
{"id": "9b87d64542e2716a", "text": "## Объединение `Path`, `Query` и параметров тела запроса { #mix-path-query-and-body-parameters }\n\nВо-первых, конечно, вы можете объединять параметры `Path`, `Query` и объявления тела запроса в своих функциях обработки, **FastAPI** автоматически определит, что с ними нужно делать.\n\nВы также можете объявить параметры тела запроса как необязательные, установив значение по умолчанию, равное `None`:\n\n{* ../../docs_src/body_multiple_params/tutorial001_an_py310.py hl[18:20] *}\n\n/// note | Заметка\n\nЗаметьте, что в данном случае параметр `item`, который будет взят из тела запроса, необязателен. Так как было установлено значение `None` по умолчанию.\n\n///\n\n", "metadata": {"title": "Body - Множество параметров", "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "source_mtime": "2026-01-12T17:48:13.316853+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-multiple-params.md"}, "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "title": "Body - Множество параметров", "chunk_index": 1, "header": "Объединение `Path`, `Query` и параметров тела запроса", "header_level": 2, "token_count": 228}
{"id": "64d8815ae2b58a13", "text": "## Несколько параметров тела запроса { #multiple-body-parameters }\n\nВ предыдущем примере, *операции пути* ожидали тело запроса в формате JSON, с параметрами, соответствующими атрибутам `Item`, например:\n\n```JSON\n{\n    \"name\": \"Foo\",\n    \"description\": \"The pretender\",\n    \"price\": 42.0,\n    \"tax\": 3.2\n}\n```\n\nНо вы также можете объявить множество параметров тела запроса, например `item` и `user`:\n\n{* ../../docs_src/body_multiple_params/tutorial002_py310.py hl[20] *}\n\nВ этом случае **FastAPI** заметит, что в функции есть более одного параметра тела (два параметра, которые являются Pydantic-моделями).\n\nТаким образом, имена параметров будут использоваться в качестве ключей (имён полей) в теле запроса, и будет ожидаться запрос следующего формата:\n\n```JSON\n{\n    \"item\": {\n        \"name\": \"Foo\",\n        \"description\": \"The pretender\",\n        \"price\": 42.0,\n        \"tax\": 3.2\n    },\n    \"user\": {\n        \"username\": \"dave\",\n        \"full_name\": \"Dave Grohl\"\n    }\n}\n```\n\n/// note | Внимание\n\nОбратите внимание, что хотя параметр `item` был объявлен таким же способом, как и раньше, теперь предполагается, что он находится внутри тела с ключом `item`.\n\n///\n\n**FastAPI** сделает автоматическое преобразование из запроса, так что параметр `item` получит своё конкретное содержимое, и то же самое происходит с пользователем `user`.", "metadata": {"title": "Body - Множество параметров", "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "source_mtime": "2026-01-12T17:48:13.316853+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-multiple-params.md", "section_header": "Несколько параметров тела запроса", "section_header_level": 2}, "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "title": "Body - Множество параметров", "chunk_index": 2, "header": "Несколько параметров тела запроса", "header_level": 2, "token_count": 481}
{"id": "9b87d64542e2716a", "text": "item`.\n\n///\n\n**FastAPI** сделает автоматическое преобразование из запроса, так что параметр `item` получит своё конкретное содержимое, и то же самое происходит с пользователем `user`.\n\nПроизойдёт проверка составных данных, и создание документации в схеме OpenAPI и автоматических документах.", "metadata": {"title": "Body - Множество параметров", "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "source_mtime": "2026-01-12T17:48:13.316853+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-multiple-params.md", "section_header": "Несколько параметров тела запроса", "section_header_level": 2}, "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "title": "Body - Множество параметров", "chunk_index": 3, "header": "Несколько параметров тела запроса", "header_level": 2, "token_count": 103}
{"id": "28b927f6edf4f56a", "text": "## Отдельные значения в теле запроса { #singular-values-in-body }\n\nТочно так же, как `Query` и `Path` используются для определения дополнительных данных для query и path параметров, **FastAPI** предоставляет аналогичный инструмент - `Body`.\n\nНапример, расширяя предыдущую модель, вы можете решить, что вам нужен еще один ключ `importance` в том же теле запроса, помимо параметров `item` и `user`.\n\nЕсли вы объявите его без указания, какой именно объект (Path, Query, Body и т.п.) ожидаете, то, поскольку это является простым типом данных, **FastAPI** будет считать, что это query-параметр.\n\nНо вы можете указать **FastAPI** обрабатывать его, как ещё один ключ тела запроса, используя `Body`:\n\n{* ../../docs_src/body_multiple_params/tutorial003_an_py310.py hl[23] *}\n\nВ этом случае, **FastAPI** будет ожидать тело запроса в формате:\n\n```JSON\n{\n    \"item\": {\n        \"name\": \"Foo\",\n        \"description\": \"The pretender\",\n        \"price\": 42.0,\n        \"tax\": 3.2\n    },\n    \"user\": {\n        \"username\": \"dave\",\n        \"full_name\": \"Dave Grohl\"\n    },\n    \"importance\": 5\n}\n```\n\nИ всё будет работать так же - преобразование типов данных, валидация, документирование и т.д.\n\n", "metadata": {"title": "Body - Множество параметров", "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "source_mtime": "2026-01-12T17:48:13.316853+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-multiple-params.md"}, "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "title": "Body - Множество параметров", "chunk_index": 4, "header": "Отдельные значения в теле запроса", "header_level": 2, "token_count": 409}
{"id": "2bedcca84f07eff2", "text": "## Множество body и query параметров { #multiple-body-params-and-query }\n\nКонечно, вы также можете объявлять query-параметры в любое время, дополнительно к любым body-параметрам.\n\nПоскольку по умолчанию, отдельные значения интерпретируются как query-параметры, вам не нужно явно добавлять `Query`, вы можете просто сделать так:\n\n```Python\nq: Union[str, None] = None\n```\n\nИли в Python 3.10 и выше:\n\n```Python\nq: str | None = None\n```\n\nНапример:\n\n{* ../../docs_src/body_multiple_params/tutorial004_an_py310.py hl[28] *}\n\n/// info | Информация\n\n`Body` также имеет все те же дополнительные параметры валидации и метаданных, как у `Query`,`Path` и других, которые вы увидите позже.\n\n///\n\n", "metadata": {"title": "Body - Множество параметров", "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "source_mtime": "2026-01-12T17:48:13.316853+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-multiple-params.md"}, "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "title": "Body - Множество параметров", "chunk_index": 5, "header": "Множество body и query параметров", "header_level": 2, "token_count": 243}
{"id": "06e5a971d0b2533f", "text": "## Вложить один body-параметр { #embed-a-single-body-parameter }\n\nПредположим, у вас есть только один body-параметр `item` из Pydantic-модели `Item`.\n\nПо умолчанию, **FastAPI** ожидает получить тело запроса напрямую.\n\nНо если вы хотите чтобы он ожидал JSON с ключом `item` с содержимым модели внутри, также как это происходит при объявлении дополнительных body-параметров, вы можете использовать специальный параметр `embed` у типа `Body`:\n\n```Python\nitem: Item = Body(embed=True)\n```\n\nтак же, как в этом примере:\n\n{* ../../docs_src/body_multiple_params/tutorial005_an_py310.py hl[17] *}\n\nВ этом случае **FastAPI** будет ожидать тело запроса в формате:\n\n```JSON hl_lines=\"2\"\n{\n    \"item\": {\n        \"name\": \"Foo\",\n        \"description\": \"The pretender\",\n        \"price\": 42.0,\n        \"tax\": 3.2\n    }\n}\n```\n\nвместо этого:\n\n```JSON\n{\n    \"name\": \"Foo\",\n    \"description\": \"The pretender\",\n    \"price\": 42.0,\n    \"tax\": 3.2\n}\n```\n\n", "metadata": {"title": "Body - Множество параметров", "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "source_mtime": "2026-01-12T17:48:13.316853+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-multiple-params.md"}, "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "title": "Body - Множество параметров", "chunk_index": 6, "header": "Вложить один body-параметр", "header_level": 2, "token_count": 329}
{"id": "fe3bdcf3e4b07cc9", "text": "## Резюме { #recap }\n\nВы можете добавлять несколько body-параметров вашей *функции-обработчика пути*, несмотря даже на то, что запрос может содержать только одно тело.\n\nНо **FastAPI** справится с этим, предоставит правильные данные в вашей функции, а также сделает валидацию и документацию правильной схемы *операции пути*.\n\nВы также можете объявить отдельные значения для получения в рамках тела запроса.\n\nИ вы можете настроить **FastAPI** таким образом, чтобы включить тело запроса в ключ, даже если объявлен только один параметр.\n", "metadata": {"title": "Body - Множество параметров", "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "source_mtime": "2026-01-12T17:48:13.316853+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-multiple-params.md"}, "doc_id": "8a60a04f18f0", "source_path": "docs\\tutorial\\body-multiple-params.md", "title": "Body - Множество параметров", "chunk_index": 7, "header": "Резюме", "header_level": 2, "token_count": 193}
{"id": "a2b2983c2546faa3", "text": "# Body - Вложенные модели { #body-nested-models }\n\nС помощью **FastAPI** вы можете определять, валидировать, документировать и использовать модели произвольной глубины вложенности (благодаря Pydantic).\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 0, "header": "Body - Вложенные модели", "header_level": 1, "token_count": 73}
{"id": "7f76f2cbac00b10f", "text": "## Поля-списки { #list-fields }\n\nВы можете определить атрибут как подтип. Например, Python-тип `list`:\n\n{* ../../docs_src/body_nested_models/tutorial001_py310.py hl[12] *}\n\nЭто приведёт к тому, что `tags` будет списком, несмотря на то, что тип его элементов не объявлен.\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 1, "header": "Поля-списки", "header_level": 2, "token_count": 96}
{"id": "b89cb77618936866", "text": "## Поля-списки с параметром типа { #list-fields-with-type-parameter }\n\nВ Python есть специальный способ объявлять списки с внутренними типами, или «параметрами типа»:\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 2, "header": "Поля-списки с параметром типа", "header_level": 2, "token_count": 61}
{"id": "7b0bde9547839846", "text": "### Объявите `list` с параметром типа { #declare-a-list-with-a-type-parameter }\n\nДля объявления типов, у которых есть параметры типа (внутренние типы), таких как `list`, `dict`, `tuple`, передайте внутренний(ие) тип(ы) как «параметры типа», используя квадратные скобки: `[` и `]`\n\n```Python\nmy_list: list[str]\n```\n\nЭто всё стандартный синтаксис Python для объявления типов.\n\nИспользуйте этот же стандартный синтаксис для атрибутов модели с внутренними типами.\n\nТаким образом, в нашем примере мы можем явно указать тип данных для поля `tags` как «список строк»:\n\n{* ../../docs_src/body_nested_models/tutorial002_py310.py hl[12] *}\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 3, "header": "Объявите `list` с параметром типа", "header_level": 3, "token_count": 234}
{"id": "71e461f5b684f406", "text": "## Типы множеств { #set-types }\n\nНо затем мы подумали и поняли, что теги не должны повторяться, вероятно, это должны быть уникальные строки.\n\nИ в Python есть специальный тип данных для множеств уникальных элементов — `set`.\n\nТогда мы можем объявить поле `tags` как множество строк:\n\n{* ../../docs_src/body_nested_models/tutorial003_py310.py hl[12] *}\n\nС помощью этого, даже если вы получите запрос с повторяющимися данными, они будут преобразованы в множество уникальных элементов.\n\nИ когда вы выводите эти данные, даже если исходный набор содержал дубликаты, они будут выведены в виде множества уникальных элементов.\n\nИ они также будут соответствующим образом аннотированы / задокументированы.\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 4, "header": "Типы множеств", "header_level": 2, "token_count": 252}
{"id": "e482ac3c26908d1a", "text": "## Вложенные модели { #nested-models }\n\nУ каждого атрибута Pydantic-модели есть тип.\n\nНо этот тип сам может быть другой моделью Pydantic.\n\nТаким образом, вы можете объявлять глубоко вложенные JSON «объекты» с определёнными именами атрибутов, типами и валидацией.\n\nВсё это может быть произвольно вложенным.\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 5, "header": "Вложенные модели", "header_level": 2, "token_count": 123}
{"id": "d0c12b5ba92505ea", "text": "### Определение подмодели { #define-a-submodel }\n\nНапример, мы можем определить модель `Image`:\n\n{* ../../docs_src/body_nested_models/tutorial004_py310.py hl[7:9] *}\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 6, "header": "Определение подмодели", "header_level": 3, "token_count": 52}
{"id": "c4077f9dbad88f78", "text": "### Использование подмодели как типа { #use-the-submodel-as-a-type }\n\nТакже мы можем использовать эту модель как тип атрибута:\n\n{* ../../docs_src/body_nested_models/tutorial004_py310.py hl[18] *}\n\nЭто означает, что **FastAPI** будет ожидать тело запроса, аналогичное этому:\n\n```JSON\n{\n    \"name\": \"Foo\",\n    \"description\": \"The pretender\",\n    \"price\": 42.0,\n    \"tax\": 3.2,\n    \"tags\": [\"rock\", \"metal\", \"bar\"],\n    \"image\": {\n        \"url\": \"http://example.com/baz.jpg\",\n        \"name\": \"The Foo live\"\n    }\n}\n```\n\nЕщё раз: сделав такое объявление, с помощью **FastAPI** вы получите:\n\n* Поддержку редактора кода (автозавершение и т.д.), даже для вложенных моделей\n* Преобразование данных\n* Валидацию данных\n* Автоматическую документацию\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 7, "header": "Использование подмодели как типа", "header_level": 3, "token_count": 269}
{"id": "54d0238471d7f78b", "text": "## Особые типы и валидация { #special-types-and-validation }\n\nПомимо обычных простых типов, таких как `str`, `int`, `float` и т.д., вы можете использовать более сложные простые типы, которые наследуются от `str`.\n\nЧтобы увидеть все варианты, которые у вас есть, ознакомьтесь с <a href=\"https://docs.pydantic.dev/latest/concepts/types/\" class=\"external-link\" target=\"_blank\">обзором типов Pydantic</a>. Вы увидите некоторые примеры в следующей главе.\n\nНапример, так как в модели `Image` у нас есть поле `url`, то мы можем объявить его как тип `HttpUrl` из Pydantic вместо типа `str`:\n\n{* ../../docs_src/body_nested_models/tutorial005_py310.py hl[2,8] *}\n\nСтрока будет проверена на соответствие допустимому URL-адресу и задокументирована в JSON Schema / OpenAPI как таковая.\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 8, "header": "Особые типы и валидация", "header_level": 2, "token_count": 277}
{"id": "0e6cbe719d6511aa", "text": "## Атрибуты, содержащие списки подмоделей { #attributes-with-lists-of-submodels }\n\nВы также можете использовать модели Pydantic в качестве подтипов для `list`, `set` и т.д.:\n\n{* ../../docs_src/body_nested_models/tutorial006_py310.py hl[18] *}\n\nТакая реализация будет ожидать (конвертировать, валидировать, документировать и т.д.) JSON-содержимое в следующем формате:\n\n```JSON hl_lines=\"11\"\n{\n    \"name\": \"Foo\",\n    \"description\": \"The pretender\",\n    \"price\": 42.0,\n    \"tax\": 3.2,\n    \"tags\": [\n        \"rock\",\n        \"metal\",\n        \"bar\"\n    ],\n    \"images\": [\n        {\n            \"url\": \"http://example.com/baz.jpg\",\n            \"name\": \"The Foo live\"\n        },\n        {\n            \"url\": \"http://example.com/dave.jpg\",\n            \"name\": \"The Baz\"\n        }\n    ]\n}\n```\n\n/// info | Информация\n\nЗаметьте, что теперь у ключа `images` есть список объектов изображений.\n\n///\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 9, "header": "Атрибуты, содержащие списки подмоделей", "header_level": 2, "token_count": 284}
{"id": "7bfaad74f6255c41", "text": "## Глубоко вложенные модели { #deeply-nested-models }\n\nВы можете определять модели с произвольным уровнем вложенности:\n\n{* ../../docs_src/body_nested_models/tutorial007_py310.py hl[7,12,18,21,25] *}\n\n/// info | Информация\n\nЗаметьте, что у объекта `Offer` есть список объектов `Item`, которые, в свою очередь, могут содержать необязательный список объектов `Image`\n\n///\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 10, "header": "Глубоко вложенные модели", "header_level": 2, "token_count": 128}
{"id": "5ad7d6633733d47c", "text": "## Тела с чистыми списками элементов { #bodies-of-pure-lists }\n\nЕсли верхний уровень значения тела JSON-объекта представляет собой JSON `array` (в Python — `list`), вы можете объявить тип в параметре функции, так же как в моделях Pydantic:\n\n```Python\nimages: list[Image]\n```\n\nнапример так:\n\n{* ../../docs_src/body_nested_models/tutorial008_py39.py hl[13] *}\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 11, "header": "Тела с чистыми списками элементов", "header_level": 2, "token_count": 123}
{"id": "e6c4936ffd352c41", "text": "## Поддержка редактора кода везде { #editor-support-everywhere }\n\nИ вы получаете поддержку редактора кода везде.\n\nДаже для элементов внутри списков:\n\n<img src=\"/img/tutorial/body-nested-models/image01.png\">\n\nВы не могли бы получить такую поддержку редактора кода, если бы работали напрямую с `dict`, а не с моделями Pydantic.\n\nНо вы также не должны беспокоиться об этом, входящие словари автоматически конвертируются, а ваш вывод также автоматически преобразуется в формат JSON.\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 12, "header": "Поддержка редактора кода везде", "header_level": 2, "token_count": 173}
{"id": "7374925aa831ffe3", "text": "## Тела запросов с произвольными словарями (`dict`) { #bodies-of-arbitrary-dicts }\n\nВы также можете объявить тело запроса как `dict` с ключами определённого типа и значениями другого типа.\n\nБез необходимости знать заранее, какие значения являются допустимыми для имён полей/атрибутов (как это было бы в случае с моделями Pydantic).\n\nЭто было бы полезно, если вы хотите получить ключи, которые вы ещё не знаете.\n\n---\n\nДругой полезный случай — когда вы хотите, чтобы ключи были другого типа данных, например, `int`.\n\nИменно это мы сейчас и увидим здесь.\n\nВ этом случае вы принимаете любой `dict`, пока у него есть ключи типа `int` со значениями типа `float`:\n\n{* ../../docs_src/body_nested_models/tutorial009_py39.py hl[7] *}\n\n/// tip | Совет\n\nИмейте в виду, что JSON поддерживает только ключи типа `str`.\n\nНо Pydantic обеспечивает автоматическое преобразование данных.\n\nЭто значит, что даже если клиенты вашего API могут отправлять только строки в качестве ключей, при условии, что эти строки содержат целые числа, Pydantic автоматически преобразует и валидирует эти данные.\n\nА `dict`, который вы получите как `weights`, действительно будет иметь ключи типа `int` и значения типа `float`.\n\n///\n\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 13, "header": "Тела запросов с произвольными словарями (`dict`)", "header_level": 2, "token_count": 429}
{"id": "9a611ff7c3818bf2", "text": "## Резюме { #recap }\n\nС помощью **FastAPI** вы получаете максимальную гибкость, предоставляемую моделями Pydantic, сохраняя при этом простоту, краткость и элегантность вашего кода.\n\nИ дополнительно вы получаете:\n\n* Поддержку редактора кода (автозавершение доступно везде!)\n* Преобразование данных (также известно как парсинг / сериализация)\n* Валидацию данных\n* Документацию схемы данных\n* Автоматическую генерацию документации\n", "metadata": {"title": "Body - Вложенные модели", "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "source_mtime": "2026-01-12T17:48:13.320875+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-nested-models.md"}, "doc_id": "bff70e86edea", "source_path": "docs\\tutorial\\body-nested-models.md", "title": "Body - Вложенные модели", "chunk_index": 14, "header": "Резюме", "header_level": 2, "token_count": 172}
{"id": "da2ca79459b958f0", "text": "# Body - Обновления { #body-updates }\n\n", "metadata": {"title": "Body - Обновления", "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "source_mtime": "2026-01-12T17:48:13.330801+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-updates.md"}, "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "title": "Body - Обновления", "chunk_index": 0, "header": "Body - Обновления", "header_level": 1, "token_count": 12}
{"id": "73e326c5e52a431c", "text": "## Обновление с заменой при помощи `PUT` { #update-replacing-with-put }\n\nДля полного обновления элемента можно воспользоваться операцией <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT\" class=\"external-link\" target=\"_blank\">HTTP `PUT`</a>.\n\nВы можете использовать `jsonable_encoder`, чтобы преобразовать входные данные в данные, которые можно сохранить как JSON (например, в NoSQL-базе данных). Например, преобразование `datetime` в `str`.\n\n{* ../../docs_src/body_updates/tutorial001_py310.py hl[28:33] *}\n\n`PUT` используется для получения данных, которые должны полностью заменить существующие данные.\n\n", "metadata": {"title": "Body - Обновления", "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "source_mtime": "2026-01-12T17:48:13.330801+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-updates.md"}, "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "title": "Body - Обновления", "chunk_index": 1, "header": "Обновление с заменой при помощи `PUT`", "header_level": 2, "token_count": 189}
{"id": "8cd8427cc95373ed", "text": "### Предупреждение о замене { #warning-about-replacing }\n\nЭто означает, что если вы хотите обновить элемент `bar`, используя `PUT` с телом, содержащим:\n\n```Python\n{\n    \"name\": \"Barz\",\n    \"price\": 3,\n    \"description\": None,\n}\n```\n\nпоскольку оно не включает уже сохраненный атрибут `\"tax\": 20.2`, входная модель примет значение по умолчанию `\"tax\": 10.5`.\n\nИ данные будут сохранены с этим \"новым\" `tax`, равным `10,5`.\n\n", "metadata": {"title": "Body - Обновления", "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "source_mtime": "2026-01-12T17:48:13.330801+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-updates.md"}, "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "title": "Body - Обновления", "chunk_index": 2, "header": "Предупреждение о замене", "header_level": 3, "token_count": 161}
{"id": "0da72e36423aed86", "text": "## Частичное обновление с помощью `PATCH` { #partial-updates-with-patch }\n\nТакже можно использовать <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH\" class=\"external-link\" target=\"_blank\">HTTP `PATCH`</a> операцию для *частичного* обновления данных.\n\nЭто означает, что можно передавать только те данные, которые необходимо обновить, оставляя остальные нетронутыми.\n\n/// note | Технические детали\n\n`PATCH` менее распространен и известен, чем `PUT`.\n\nА многие команды используют только `PUT`, даже для частичного обновления.\n\nВы можете **свободно** использовать их как угодно, **FastAPI** не накладывает никаких ограничений.\n\nНо в данном руководстве более или менее понятно, как они должны использоваться.\n\n///\n\n", "metadata": {"title": "Body - Обновления", "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "source_mtime": "2026-01-12T17:48:13.330801+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-updates.md"}, "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "title": "Body - Обновления", "chunk_index": 3, "header": "Частичное обновление с помощью `PATCH`", "header_level": 2, "token_count": 258}
{"id": "4b7c9bea5ac300bc", "text": "### Использование параметра `exclude_unset` в Pydantic { #using-pydantics-exclude-unset-parameter }\n\nЕсли необходимо выполнить частичное обновление, то очень полезно использовать параметр `exclude_unset` в методе `.model_dump()` модели Pydantic.\n\nНапример, `item.model_dump(exclude_unset=True)`.\n\n/// info | Информация\n\nВ Pydantic v1 метод назывался `.dict()`, в Pydantic v2 он помечен как устаревший (но все еще поддерживается) и переименован в `.model_dump()`.\n\nПримеры здесь используют `.dict()` для совместимости с Pydantic v1, но если вы можете использовать Pydantic v2, лучше используйте `.model_dump()`.\n\n///\n\nВ результате будет сгенерирован словарь, содержащий только те данные, которые были заданы при создании модели `item`, без учета значений по умолчанию. Затем вы можете использовать это для создания словаря только с теми данными, которые были установлены (отправлены в запросе), опуская значения по умолчанию:\n\n{* ../../docs_src/body_updates/tutorial002_py310.py hl[32] *}\n\n", "metadata": {"title": "Body - Обновления", "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "source_mtime": "2026-01-12T17:48:13.330801+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-updates.md"}, "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "title": "Body - Обновления", "chunk_index": 4, "header": "Использование параметра `exclude_unset` в Pydantic", "header_level": 3, "token_count": 322}
{"id": "5e213f1485e74857", "text": "### Использование параметра `update` в Pydantic { #using-pydantics-update-parameter }\n\nТеперь можно создать копию существующей модели, используя `.model_copy()`, и передать параметр `update` с `dict`, содержащим данные для обновления.\n\n/// info | Информация\n\nВ Pydantic v1 метод назывался `.copy()`, в Pydantic v2 он помечен как устаревший (но все еще поддерживается) и переименован в `.model_copy()`.\n\nПримеры здесь используют `.copy()` для совместимости с Pydantic v1, но если вы можете использовать Pydantic v2, лучше используйте `.model_copy()`.\n\n///\n\nНапример, `stored_item_model.model_copy(update=update_data)`:\n\n{* ../../docs_src/body_updates/tutorial002_py310.py hl[33] *}\n\n", "metadata": {"title": "Body - Обновления", "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "source_mtime": "2026-01-12T17:48:13.330801+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-updates.md"}, "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "title": "Body - Обновления", "chunk_index": 5, "header": "Использование параметра `update` в Pydantic", "header_level": 3, "token_count": 222}
{"id": "da2ca79459b958f0", "text": "### Кратко о частичном обновлении { #partial-updates-recap }\n\nВ целом, для применения частичных обновлений необходимо:\n\n* (Опционально) использовать `PATCH` вместо `PUT`.\n* Извлечь сохранённые данные.\n* Поместить эти данные в Pydantic модель.\n* Сгенерировать `dict` без значений по умолчанию из входной модели (с использованием `exclude_unset`).\n    * Таким образом, можно обновлять только те значения, которые действительно установлены пользователем, вместо того чтобы переопределять значения, уже сохраненные в модели по умолчанию.\n* Создать копию хранимой модели, обновив ее атрибуты полученными частичными обновлениями (с помощью параметра `update`).\n* Преобразовать скопированную модель в то, что может быть сохранено в вашей БД (например, с помощью `jsonable_encoder`).\n    * Это сравнимо с повторным использованием метода модели `.model_dump()`, но при этом происходит проверка (и преобразование) значений в типы данных, которые могут быть преобразованы в JSON, например, `datetime` в `str`.\n* Сохранить данные в своей БД.\n* Вернуть обновленную модель.\n\n{* ../../docs_src/body_updates/tutorial002_py310.py hl[28:35] *}\n\n/// tip | Подсказка\n\nЭту же технику можно использовать и для операции HTTP `PUT`.\n\nНо в приведенном примере используется `PATCH`, поскольку он был создан именно для таких случаев использования.\n\n///\n\n/// note | Технические детали", "metadata": {"title": "Body - Обновления", "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "source_mtime": "2026-01-12T17:48:13.330801+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-updates.md", "section_header": "Кратко о частичном обновлении", "section_header_level": 3}, "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "title": "Body - Обновления", "chunk_index": 6, "header": "Кратко о частичном обновлении", "header_level": 3, "token_count": 485}
{"id": "73e326c5e52a431c", "text": "можно использовать и для операции HTTP `PUT`.\n\nНо в приведенном примере используется `PATCH`, поскольку он был создан именно для таких случаев использования.\n\n///\n\n/// note | Технические детали\n\nОбратите внимание, что входная модель по-прежнему валидируется.\n\nТаким образом, если вы хотите получать частичные обновления, в которых могут быть опущены все атрибуты, вам необходимо иметь модель, в которой все атрибуты помечены как необязательные (со значениями по умолчанию или `None`).\n\nЧтобы отличить модели со всеми необязательными значениями для **обновления** от моделей с обязательными значениями для **создания**, можно воспользоваться идеями, описанными в [Дополнительные модели](extra-models.md){.internal-link target=_blank}.\n\n///", "metadata": {"title": "Body - Обновления", "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "source_mtime": "2026-01-12T17:48:13.330801+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body-updates.md", "section_header": "Кратко о частичном обновлении", "section_header_level": 3}, "doc_id": "1e2162f1c0dc", "source_path": "docs\\tutorial\\body-updates.md", "title": "Body - Обновления", "chunk_index": 7, "header": "Кратко о частичном обновлении", "header_level": 3, "token_count": 263}
{"id": "aac6185d122b2f2e", "text": "# Тело запроса { #request-body }\n\nКогда вам необходимо отправить данные из клиента (например, браузера) в ваш API, вы отправляете их как **тело запроса**.\n\nТело **запроса** — это данные, отправляемые клиентом в ваш API. Тело **ответа** — это данные, которые ваш API отправляет клиенту.\n\nВаш API почти всегда должен отправлять тело **ответа**. Но клиентам не обязательно всегда отправлять **тело запроса**: иногда они запрашивают только путь, возможно с некоторыми параметрами запроса, но без тела.\n\nЧтобы объявить тело **запроса**, используйте модели <a href=\"https://docs.pydantic.dev/\" class=\"external-link\" target=\"_blank\">Pydantic</a>, со всей их мощью и преимуществами.\n\n/// info | Информация\n\nЧтобы отправить данные, используйте один из методов: `POST` (чаще всего), `PUT`, `DELETE` или `PATCH`.\n\nОтправка тела с запросом `GET` имеет неопределённое поведение в спецификациях, тем не менее это поддерживается FastAPI, но только для очень сложных/крайних случаев использования.\n\nПоскольку это не рекомендуется, интерактивная документация со Swagger UI не будет отображать информацию для тела при использовании `GET`, а промежуточные прокси-серверы могут не поддерживать такой вариант запроса.\n\n///\n\n", "metadata": {"title": "Тело запроса", "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "source_mtime": "2026-01-12T17:48:13.335392+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body.md"}, "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "title": "Тело запроса", "chunk_index": 0, "header": "Тело запроса", "header_level": 1, "token_count": 443}
{"id": "35a1f6caa6bcf9d0", "text": "## Импортируйте `BaseModel` из Pydantic { #import-pydantics-basemodel }\n\nПервое, что нужно сделать, — импортировать `BaseModel` из пакета `pydantic`:\n\n{* ../../docs_src/body/tutorial001_py310.py hl[2] *}\n\n", "metadata": {"title": "Тело запроса", "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "source_mtime": "2026-01-12T17:48:13.335392+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body.md"}, "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "title": "Тело запроса", "chunk_index": 1, "header": "Импортируйте `BaseModel` из Pydantic", "header_level": 2, "token_count": 74}
{"id": "5ed2742eea50fd40", "text": "## Создайте модель данных { #create-your-data-model }\n\nЗатем опишите свою модель данных как класс, наследующийся от `BaseModel`.\n\nИспользуйте стандартные типы Python для всех атрибутов:\n\n{* ../../docs_src/body/tutorial001_py310.py hl[5:9] *}\n\nТак же, как при объявлении параметров запроса: когда атрибут модели имеет значение по умолчанию, он не обязателен. Иначе он обязателен. Используйте `None`, чтобы сделать его просто необязательным.\n\nНапример, модель выше описывает такой JSON \"объект\" (или Python `dict`):\n\n```JSON\n{\n    \"name\": \"Foo\",\n    \"description\": \"An optional description\",\n    \"price\": 45.2,\n    \"tax\": 3.5\n}\n```\n\n...так как `description` и `tax` являются необязательными (со значением по умолчанию `None`), такой JSON \"объект\" тоже будет корректным:\n\n```JSON\n{\n    \"name\": \"Foo\",\n    \"price\": 45.2\n}\n```\n\n", "metadata": {"title": "Тело запроса", "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "source_mtime": "2026-01-12T17:48:13.335392+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body.md"}, "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "title": "Тело запроса", "chunk_index": 2, "header": "Создайте модель данных", "header_level": 2, "token_count": 307}
{"id": "581505d09785e1b9", "text": "## Объявите её как параметр { #declare-it-as-a-parameter }\n\nЧтобы добавить её в вашу *операцию пути*, объявите её так же, как вы объявляли параметры пути и параметры запроса:\n\n{* ../../docs_src/body/tutorial001_py310.py hl[16] *}\n\n...и укажите тип параметра как созданную вами модель, `Item`.\n\n", "metadata": {"title": "Тело запроса", "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "source_mtime": "2026-01-12T17:48:13.335392+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body.md"}, "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "title": "Тело запроса", "chunk_index": 3, "header": "Объявите её как параметр", "header_level": 2, "token_count": 102}
{"id": "5b23563ed5ce1880", "text": "## Результаты { #results }\n\nВсего лишь с этой аннотацией типов Python **FastAPI**:\n\n* Считает тело запроса как JSON.\n* Приведёт данные к соответствующим типам (если потребуется).\n* Проведёт валидацию данных.\n    * Если данные некорректны, вернёт понятную и наглядную ошибку, указывающую, где именно и что было некорректно.\n* Передаст полученные данные в параметр `item`.\n    * Поскольку внутри функции вы объявили его с типом `Item`, у вас будет поддержка со стороны редактора кода (автозавершение и т. п.) для всех атрибутов и их типов.\n* Сгенерирует определения <a href=\"https://json-schema.org\" class=\"external-link\" target=\"_blank\">JSON Schema</a> для вашей модели; вы можете использовать их и в других местах, если это имеет смысл для вашего проекта.\n* Эти схемы будут частью сгенерированной схемы OpenAPI и будут использоваться автоматической документацией <abbr title=\"User Interfaces – Пользовательские интерфейсы\">UIs</abbr>.\n\n", "metadata": {"title": "Тело запроса", "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "source_mtime": "2026-01-12T17:48:13.335392+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body.md"}, "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "title": "Тело запроса", "chunk_index": 4, "header": "Результаты", "header_level": 2, "token_count": 354}
{"id": "49d169d48a65a35b", "text": "## Автоматическая документация { #automatic-docs }\n\nJSON Schema ваших моделей будет частью сгенерированной схемы OpenAPI и будет отображаться в интерактивной документации API:\n\n<img src=\"/img/tutorial/body/image01.png\">\n\nА также они будут использоваться в документации API внутри каждой *операции пути*, где это требуется:\n\n<img src=\"/img/tutorial/body/image02.png\">\n\n", "metadata": {"title": "Тело запроса", "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "source_mtime": "2026-01-12T17:48:13.335392+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body.md"}, "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "title": "Тело запроса", "chunk_index": 5, "header": "Автоматическая документация", "header_level": 2, "token_count": 115}
{"id": "aac6185d122b2f2e", "text": "## Поддержка редактора кода { #editor-support }\n\nВ вашем редакторе кода внутри функции вы получите подсказки по типам и автозавершение повсюду (этого бы не было, если бы вы получали `dict` вместо модели Pydantic):\n\n<img src=\"/img/tutorial/body/image03.png\">\n\nТакже вы получите проверку ошибок при некорректных операциях с типами:\n\n<img src=\"/img/tutorial/body/image04.png\">\n\nЭто не случайность — весь фреймворк построен вокруг такого дизайна.\n\nИ это было тщательно протестировано ещё на этапе проектирования, до реализации, чтобы убедиться, что всё будет работать со всеми редакторами.\n\nВ сам Pydantic даже были внесены некоторые изменения для поддержки этого.\n\nПредыдущие скриншоты сделаны в <a href=\"https://code.visualstudio.com\" class=\"external-link\" target=\"_blank\">Visual Studio Code</a>.\n\nНо вы получите такую же поддержку редактора кода в <a href=\"https://www.jetbrains.com/pycharm/\" class=\"external-link\" target=\"_blank\">PyCharm</a> и большинстве других редакторов Python:\n\n<img src=\"/img/tutorial/body/image05.png\">\n\n/// tip | Совет\n\nЕсли вы используете <a href=\"https://www.jetbrains.com/pycharm/\" class=\"external-link\" target=\"_blank\">PyCharm</a> в качестве редактора кода, вы можете использовать плагин <a href=\"https://github.com/koxudaxi/pydantic-pycharm-plugin/\" class=\"external-link\" target=\"_blank\">Pydantic PyCharm Plugin</a>.\n\nОн улучшает поддержку моделей Pydantic в редакторе кода, включая:", "metadata": {"title": "Тело запроса", "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "source_mtime": "2026-01-12T17:48:13.335392+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body.md", "section_header": "Поддержка редактора кода", "section_header_level": 2}, "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "title": "Тело запроса", "chunk_index": 6, "header": "Поддержка редактора кода", "header_level": 2, "token_count": 482}
{"id": "35a1f6caa6bcf9d0", "text": "://github.com/koxudaxi/pydantic-pycharm-plugin/\" class=\"external-link\" target=\"_blank\">Pydantic PyCharm Plugin</a>.\n\nОн улучшает поддержку моделей Pydantic в редакторе кода, включая:\n\n* автозавершение\n* проверки типов\n* рефакторинг\n* поиск\n* инспекции\n\n///", "metadata": {"title": "Тело запроса", "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "source_mtime": "2026-01-12T17:48:13.335392+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body.md", "section_header": "Поддержка редактора кода", "section_header_level": 2}, "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "title": "Тело запроса", "chunk_index": 7, "header": "Поддержка редактора кода", "header_level": 2, "token_count": 99}
{"id": "3c6015df9c22ec5a", "text": "## Использование модели { #use-the-model }\n\nВнутри функции вам доступны все атрибуты объекта модели напрямую:\n\n{* ../../docs_src/body/tutorial002_py310.py *}\n\n/// info | Информация\n\nВ Pydantic v1 метод назывался `.dict()`, в Pydantic v2 он был помечен как устаревший (но всё ещё поддерживается) и переименован в `.model_dump()`.\n\nПримеры здесь используют `.dict()` для совместимости с Pydantic v1, но если вы можете использовать Pydantic v2, используйте `.model_dump()`.\n\n///\n\n", "metadata": {"title": "Тело запроса", "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "source_mtime": "2026-01-12T17:48:13.335392+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body.md"}, "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "title": "Тело запроса", "chunk_index": 8, "header": "Использование модели", "header_level": 2, "token_count": 169}
{"id": "8d42254530b0b882", "text": "## Тело запроса + параметры пути { #request-body-path-parameters }\n\nВы можете одновременно объявить параметры пути и тело запроса.\n\n**FastAPI** распознает, что параметры функции, соответствующие параметрам пути, должны быть **получены из пути**, а параметры функции, объявленные как модели Pydantic, должны быть **получены из тела запроса**.\n\n{* ../../docs_src/body/tutorial003_py310.py hl[15:16] *}\n\n", "metadata": {"title": "Тело запроса", "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "source_mtime": "2026-01-12T17:48:13.335392+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body.md"}, "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "title": "Тело запроса", "chunk_index": 9, "header": "Тело запроса + параметры пути", "header_level": 2, "token_count": 134}
{"id": "de83863420087e8e", "text": "## Тело запроса + параметры пути + параметры запроса { #request-body-path-query-parameters }\n\nВы также можете одновременно объявить параметры **тела**, **пути** и **запроса**.\n\n**FastAPI** распознает каждый из них и возьмёт данные из правильного источника.\n\n{* ../../docs_src/body/tutorial004_py310.py hl[16] *}\n\nПараметры функции будут распознаны следующим образом:\n\n* Если параметр также объявлен в **пути**, он будет использоваться как параметр пути.\n* Если параметр имеет **скалярный тип** (например, `int`, `float`, `str`, `bool` и т. п.), он будет интерпретирован как параметр **запроса**.\n* Если параметр объявлен как тип **модели Pydantic**, он будет интерпретирован как **тело** запроса.\n\n/// note | Заметка\n\nFastAPI понимает, что значение `q` не является обязательным из-за значения по умолчанию `= None`.\n\nАннотации типов `str | None` (Python 3.10+) или `Union[str, None]` (Python 3.9+) не используются FastAPI для определения обязательности; он узнает, что параметр не обязателен, потому что у него есть значение по умолчанию `= None`.\n\nНо добавление аннотаций типов позволит вашему редактору кода лучше вас поддерживать и обнаруживать ошибки.\n\n///\n\n", "metadata": {"title": "Тело запроса", "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "source_mtime": "2026-01-12T17:48:13.335392+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body.md"}, "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "title": "Тело запроса", "chunk_index": 10, "header": "Тело запроса + параметры пути + параметры запроса", "header_level": 2, "token_count": 418}
{"id": "3eefd4f0d46e34fd", "text": "## Без Pydantic { #without-pydantic }\n\nЕсли вы не хотите использовать модели Pydantic, вы также можете использовать параметры **Body**. См. раздел документации [Тело — Несколько параметров: Единичные значения в теле](body-multiple-params.md#singular-values-in-body){.internal-link target=_blank}.\n", "metadata": {"title": "Тело запроса", "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "source_mtime": "2026-01-12T17:48:13.335392+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\body.md"}, "doc_id": "86d3b4a0cb21", "source_path": "docs\\tutorial\\body.md", "title": "Тело запроса", "chunk_index": 11, "header": "Без Pydantic", "header_level": 2, "token_count": 89}
{"id": "25ffa52b4244e08f", "text": "# Модели параметров cookie { #cookie-parameter-models }\n\nЕсли у вас есть группа **cookies**, которые связаны между собой, вы можете создать **Pydantic-модель** для их объявления. \n\nЭто позволит вам **переиспользовать модель** в **разных местах**, а также объявить проверки и метаданные сразу для всех параметров. \n\n/// note | Заметка\n\nЭтот функционал доступен с версии `0.115.0`. \n\n///\n\n/// tip | Совет\n\nТакой же подход применяется для `Query`, `Cookie`, и `Header`. \n\n///\n\n", "metadata": {"title": "Модели параметров cookie", "doc_id": "87605fa67655", "source_path": "docs\\tutorial\\cookie-param-models.md", "source_mtime": "2026-01-12T17:48:13.342921+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cookie-param-models.md"}, "doc_id": "87605fa67655", "source_path": "docs\\tutorial\\cookie-param-models.md", "title": "Модели параметров cookie", "chunk_index": 0, "header": "Модели параметров cookie", "header_level": 1, "token_count": 176}
{"id": "5f6f8e733ca9f989", "text": "## Pydantic-модель для cookies { #cookies-with-a-pydantic-model }\n\nОбъявите параметры **cookie**, которые вам нужны, в **Pydantic-модели**, а затем объявите параметр как `Cookie`:\n\n{* ../../docs_src/cookie_param_models/tutorial001_an_py310.py hl[9:12,16] *}\n\n**FastAPI** **извлечёт** данные для **каждого поля** из **cookies**, полученных в запросе, и выдаст вам объявленную Pydantic-модель.\n\n", "metadata": {"title": "Модели параметров cookie", "doc_id": "87605fa67655", "source_path": "docs\\tutorial\\cookie-param-models.md", "source_mtime": "2026-01-12T17:48:13.342921+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cookie-param-models.md"}, "doc_id": "87605fa67655", "source_path": "docs\\tutorial\\cookie-param-models.md", "title": "Модели параметров cookie", "chunk_index": 1, "header": "Pydantic-модель для cookies", "header_level": 2, "token_count": 135}
{"id": "1ae6693a47c5d8a1", "text": "## Проверка сгенерированной документации { #check-the-docs }\n\nВы можете посмотреть объявленные cookies в графическом интерфейсе Документации по пути `/docs`:\n\n<div class=\"screenshot\">\n<img src=\"/img/tutorial/cookie-param-models/image01.png\">\n</div>\n\n/// info | Дополнительная информация\n\nИмейте в виду, что, поскольку **браузеры обрабатывают cookies** особым образом и под капотом, они **не** позволят **JavaScript** легко получить доступ к ним.\n\nЕсли вы перейдёте к **графическому интерфейсу документации API** по пути `/docs`, то сможете увидеть **документацию** по cookies для ваших *операций путей*.\n\nНо даже если вы **заполните данные** и нажмёте \"Execute\", поскольку графический интерфейс Документации работает с **JavaScript**, cookies не будут отправлены, и вы увидите сообщение об **ошибке** как будто не указывали никаких значений.\n\n///\n\n", "metadata": {"title": "Модели параметров cookie", "doc_id": "87605fa67655", "source_path": "docs\\tutorial\\cookie-param-models.md", "source_mtime": "2026-01-12T17:48:13.342921+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cookie-param-models.md"}, "doc_id": "87605fa67655", "source_path": "docs\\tutorial\\cookie-param-models.md", "title": "Модели параметров cookie", "chunk_index": 2, "header": "Проверка сгенерированной документации", "header_level": 2, "token_count": 306}
{"id": "25ffa52b4244e08f", "text": "## Запрет дополнительных cookies { #forbid-extra-cookies }\n\nВ некоторых случаях (не особо часто встречающихся) вам может понадобиться **ограничить** cookies, которые вы хотите получать.\n\nТеперь ваш API сам решает, <abbr title=\"Это шутка, на всякий случай. Это не имеет никакого отношения к согласию на использование cookie, но забавно, что даже API теперь может отклонять несчастные cookies. Съешьте печеньку. \">принимать ли cookies</abbr>. \n\nВы можете сконфигурировать Pydantic-модель так, чтобы запретить (`forbid`) любые дополнительные (`extra`) поля:\n\n{* ../../docs_src/cookie_param_models/tutorial002_an_py310.py hl[10] *}\n\nЕсли клиент попробует отправить **дополнительные cookies**, то в ответ он получит **ошибку**.\n\nБедные баннеры cookies, они всеми силами пытаются получить ваше согласие — и всё ради того, чтобы <abbr title=\"Это ещё одна шутка. Не обращайте на меня внимания. Выпейте кофе со своей печенькой. \">API его отклонил</abbr>. \n\nНапример, если клиент попытается отправить cookie `santa_tracker` со значением `good-list-please`, то в ответ он получит **ошибку**, сообщающую ему, что cookie `santa_tracker` <abbr title=\"Санта не одобряет пропажу печенья.  Ладно, больше никаких шуток про печенье.\">не разрешён</abbr>:", "metadata": {"title": "Модели параметров cookie", "doc_id": "87605fa67655", "source_path": "docs\\tutorial\\cookie-param-models.md", "source_mtime": "2026-01-12T17:48:13.342921+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cookie-param-models.md", "section_header": "Запрет дополнительных cookies", "section_header_level": 2}, "doc_id": "87605fa67655", "source_path": "docs\\tutorial\\cookie-param-models.md", "title": "Модели параметров cookie", "chunk_index": 3, "header": "Запрет дополнительных cookies", "header_level": 2, "token_count": 479}
{"id": "5f6f8e733ca9f989", "text": "му, что cookie `santa_tracker` <abbr title=\"Санта не одобряет пропажу печенья.  Ладно, больше никаких шуток про печенье.\">не разрешён</abbr>:\n\n```json\n{\n    \"detail\": [\n        {\n            \"type\": \"extra_forbidden\",\n            \"loc\": [\"cookie\", \"santa_tracker\"],\n            \"msg\": \"Extra inputs are not permitted\",\n            \"input\": \"good-list-please\",\n        }\n    ]\n}\n```", "metadata": {"title": "Модели параметров cookie", "doc_id": "87605fa67655", "source_path": "docs\\tutorial\\cookie-param-models.md", "source_mtime": "2026-01-12T17:48:13.342921+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cookie-param-models.md", "section_header": "Запрет дополнительных cookies", "section_header_level": 2}, "doc_id": "87605fa67655", "source_path": "docs\\tutorial\\cookie-param-models.md", "title": "Модели параметров cookie", "chunk_index": 4, "header": "Запрет дополнительных cookies", "header_level": 2, "token_count": 123}
{"id": "b6a19dc4a9961adf", "text": "## Заключение { #summary }\n\nВы можете использовать **Pydantic-модели** для объявления <abbr title=\"Съешьте последнюю печеньку, прежде чем уйти. \">**cookies**</abbr> в **FastAPI**.\n", "metadata": {"title": "Модели параметров cookie", "doc_id": "87605fa67655", "source_path": "docs\\tutorial\\cookie-param-models.md", "source_mtime": "2026-01-12T17:48:13.342921+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cookie-param-models.md"}, "doc_id": "87605fa67655", "source_path": "docs\\tutorial\\cookie-param-models.md", "title": "Модели параметров cookie", "chunk_index": 5, "header": "Заключение", "header_level": 2, "token_count": 68}
{"id": "b31cf45271dae610", "text": "# Параметры Cookie { #cookie-parameters }\n\nВы можете задать параметры Cookie таким же способом, как `Query` и `Path` параметры.\n\n", "metadata": {"title": "Параметры Cookie", "doc_id": "8e83e0ec440b", "source_path": "docs\\tutorial\\cookie-params.md", "source_mtime": "2026-01-12T17:48:13.348532+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cookie-params.md"}, "doc_id": "8e83e0ec440b", "source_path": "docs\\tutorial\\cookie-params.md", "title": "Параметры Cookie", "chunk_index": 0, "header": "Параметры Cookie", "header_level": 1, "token_count": 39}
{"id": "21ec52ab2b8b2fc8", "text": "## Импорт `Cookie` { #import-cookie }\n\nСначала импортируйте `Cookie`:\n\n{* ../../docs_src/cookie_params/tutorial001_an_py310.py hl[3] *}\n\n", "metadata": {"title": "Параметры Cookie", "doc_id": "8e83e0ec440b", "source_path": "docs\\tutorial\\cookie-params.md", "source_mtime": "2026-01-12T17:48:13.348532+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cookie-params.md"}, "doc_id": "8e83e0ec440b", "source_path": "docs\\tutorial\\cookie-params.md", "title": "Параметры Cookie", "chunk_index": 1, "header": "Импорт `Cookie`", "header_level": 2, "token_count": 46}
{"id": "4d97c7fb05664a00", "text": "## Объявление параметров `Cookie` { #declare-cookie-parameters }\n\nЗатем объявляйте параметры cookie, используя ту же структуру, что и с `Path` и `Query`.\n\nВы можете задать значение по умолчанию, а также все дополнительные параметры валидации или аннотации:\n\n{* ../../docs_src/cookie_params/tutorial001_an_py310.py hl[9] *}\n\n/// note | Технические детали\n\n`Cookie` - это класс, родственный `Path` и `Query`. Он также наследуется от общего класса `Param`.\n\nНо помните, что когда вы импортируете `Query`, `Path`, `Cookie` и другое из `fastapi`, это фактически функции, которые возвращают специальные классы.\n\n///\n\n/// info | Дополнительная информация\n\nДля объявления cookies, вам нужно использовать `Cookie`, иначе параметры будут интерпретированы как параметры запроса.\n\n///\n\n/// info | Дополнительная информация\n\nИмейте в виду, что, поскольку браузеры обрабатывают cookies особым образом и «за кулисами», они не позволяют JavaScript просто так получать к ним доступ.\n\nЕсли вы откроете интерфейс документации API на `/docs`, вы сможете увидеть документацию по cookies для ваших операций пути.\n\nНо даже если вы заполните данные и нажмёте «Execute», поскольку UI документации работает с JavaScript, cookies отправлены не будут, и вы увидите сообщение об ошибке, как будто вы не указали никаких значений.\n\n///\n\n", "metadata": {"title": "Параметры Cookie", "doc_id": "8e83e0ec440b", "source_path": "docs\\tutorial\\cookie-params.md", "source_mtime": "2026-01-12T17:48:13.348532+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cookie-params.md"}, "doc_id": "8e83e0ec440b", "source_path": "docs\\tutorial\\cookie-params.md", "title": "Параметры Cookie", "chunk_index": 2, "header": "Объявление параметров `Cookie`", "header_level": 2, "token_count": 457}
{"id": "e63531c8a7a32656", "text": "## Резюме { #recap }\n\nОбъявляйте cookies с помощью `Cookie`, используя тот же общий шаблон, что и `Query`, и `Path`.\n", "metadata": {"title": "Параметры Cookie", "doc_id": "8e83e0ec440b", "source_path": "docs\\tutorial\\cookie-params.md", "source_mtime": "2026-01-12T17:48:13.348532+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cookie-params.md"}, "doc_id": "8e83e0ec440b", "source_path": "docs\\tutorial\\cookie-params.md", "title": "Параметры Cookie", "chunk_index": 3, "header": "Резюме", "header_level": 2, "token_count": 50}
{"id": "773e0fa5a6743034", "text": "# CORS (Cross-Origin Resource Sharing) { #cors-cross-origin-resource-sharing }\n\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\" class=\"external-link\" target=\"_blank\">Понятие CORS или \"Cross-Origin Resource Sharing\"</a> относится к ситуациям, при которых запущенный в браузере фронтенд содержит JavaScript-код, который взаимодействует с бэкендом, находящимся на другом \"источнике\" (\"origin\").\n\n", "metadata": {"title": "CORS (Cross-Origin Resource Sharing)", "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "source_mtime": "2026-01-12T17:48:13.352565+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cors.md"}, "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "title": "CORS (Cross-Origin Resource Sharing)", "chunk_index": 0, "header": "CORS (Cross-Origin Resource Sharing)", "header_level": 1, "token_count": 128}
{"id": "2cac24934630a74f", "text": "## Источник { #origin }\n\nИсточник — это совокупность протокола (`http`, `https`), домена (`myapp.com`, `localhost`, `localhost.tiangolo.com`) и порта (`80`, `443`, `8080`).\n\nПоэтому это три разных источника:\n\n* `http://localhost`\n* `https://localhost`\n* `http://localhost:8080`\n\nДаже если они все расположены в `localhost`, они используют разные протоколы или порты, а значит, являются разными источниками.\n\n", "metadata": {"title": "CORS (Cross-Origin Resource Sharing)", "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "source_mtime": "2026-01-12T17:48:13.352565+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cors.md"}, "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "title": "CORS (Cross-Origin Resource Sharing)", "chunk_index": 1, "header": "Источник", "header_level": 2, "token_count": 150}
{"id": "2a78ec6394725eef", "text": "## Шаги { #steps }\n\nДопустим, у вас есть фронтенд, запущенный в браузере по адресу `http://localhost:8080`, и его JavaScript-код пытается взаимодействовать с бэкендом, запущенным по адресу `http://localhost` (поскольку мы не указали порт, браузер по умолчанию будет использовать порт `80`).\n\nЗатем браузер отправит на бэкенд на `:80` HTTP-запрос `OPTIONS`, и если бэкенд вернёт соответствующие HTTP-заголовки, авторизующие взаимодействие с другим источником (`http://localhost:8080`), то браузер на `:8080` разрешит JavaScript на фронтенде отправить свой запрос на бэкенд на `:80`.\n\nЧтобы это работало, у бэкенда на `:80` должен быть список \"разрешённых источников\" (\"allowed origins\").\n\nВ таком случае этот список должен содержать `http://localhost:8080`, чтобы фронтенд на `:8080` работал корректно.\n\n", "metadata": {"title": "CORS (Cross-Origin Resource Sharing)", "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "source_mtime": "2026-01-12T17:48:13.352565+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cors.md"}, "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "title": "CORS (Cross-Origin Resource Sharing)", "chunk_index": 2, "header": "Шаги", "header_level": 2, "token_count": 319}
{"id": "a50b7e5f9ae27f53", "text": "## Подстановочный символ \"*\" { #wildcards }\n\nВ качестве списка источников можно указать подстановочный символ `\"*\"` (\"wildcard\"), чтобы разрешить любые источники.\n\nНо тогда будут разрешены только некоторые виды взаимодействия, и всё, что связано с учётными данными, будет исключено: куки, HTTP-заголовки Authorization, как при использовании Bearer-токенов, и т.п.\n\nПоэтому, чтобы всё работало корректно, лучше явно указывать список разрешённых источников.\n\n", "metadata": {"title": "CORS (Cross-Origin Resource Sharing)", "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "source_mtime": "2026-01-12T17:48:13.352565+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cors.md"}, "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "title": "CORS (Cross-Origin Resource Sharing)", "chunk_index": 3, "header": "Подстановочный символ \"*\"", "header_level": 2, "token_count": 175}
{"id": "773e0fa5a6743034", "text": "## Использование `CORSMiddleware` { #use-corsmiddleware }\n\nВы можете настроить это в вашем **FastAPI**-приложении, используя `CORSMiddleware`.\n\n* Импортируйте `CORSMiddleware`.\n* Создайте список разрешённых источников (в виде строк).\n* Добавьте его как \"middleware\" (промежуточный слой) к вашему **FastAPI**-приложению.\n\nВы также можете указать, разрешает ли ваш бэкенд использование:\n\n* Учётных данных (HTTP-заголовки Authorization, куки и т.п.).\n* Отдельных HTTP-методов (`POST`, `PUT`) или всех вместе, используя `\"*\"`.\n* Отдельных HTTP-заголовков или всех вместе, используя `\"*\"`.\n\n{* ../../docs_src/cors/tutorial001_py39.py hl[2,6:11,13:19] *}\n\n`CORSMiddleware` использует \"запрещающие\" значения по умолчанию, поэтому вам нужно явным образом разрешить использование отдельных источников, методов или заголовков, чтобы браузеры могли использовать их в кросс-доменном контексте.\n\nПоддерживаются следующие аргументы:", "metadata": {"title": "CORS (Cross-Origin Resource Sharing)", "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "source_mtime": "2026-01-12T17:48:13.352565+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cors.md", "section_header": "Использование `CORSMiddleware`", "section_header_level": 2}, "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "title": "CORS (Cross-Origin Resource Sharing)", "chunk_index": 4, "header": "Использование `CORSMiddleware`", "header_level": 2, "token_count": 352}
{"id": "2cac24934630a74f", "text": "ить использование отдельных источников, методов или заголовков, чтобы браузеры могли использовать их в кросс-доменном контексте.\n\nПоддерживаются следующие аргументы:\n\n* `allow_origins` - Список источников, на которые разрешено выполнять кросс-доменные запросы. Например, `['https://example.org', 'https://www.example.org']`. Можно использовать `['*']`, чтобы разрешить любые источники.\n* `allow_origin_regex` - Регулярное выражение для определения источников, на которые разрешено выполнять кросс-доменные запросы. Например, `'https://.*\\.example\\.org'`.\n* `allow_methods` - Список HTTP-методов, которые разрешены для кросс-доменных запросов. По умолчанию `['GET']`. Можно использовать `['*']`, чтобы разрешить все стандартные методы.\n* `allow_headers` - Список HTTP-заголовков запроса, которые должны поддерживаться при кросс-доменных запросах. По умолчанию `[]`. Можно использовать `['*']`, чтобы разрешить все заголовки. Заголовки `Accept`, `Accept-Language`, `Content-Language` и `Content-Type` всегда разрешены для <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests\" class=\"external-link\" rel=\"noopener\" target=\"_blank\">простых CORS-запросов</a>.\n* `allow_credentials` - Указывает, что куки разрешены в кросс-доменных запросах. По умолчанию `False`.", "metadata": {"title": "CORS (Cross-Origin Resource Sharing)", "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "source_mtime": "2026-01-12T17:48:13.352565+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cors.md", "section_header": "Использование `CORSMiddleware`", "section_header_level": 2}, "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "title": "CORS (Cross-Origin Resource Sharing)", "chunk_index": 5, "header": "Использование `CORSMiddleware`", "header_level": 2, "token_count": 465}
{"id": "2a78ec6394725eef", "text": "\" rel=\"noopener\" target=\"_blank\">простых CORS-запросов</a>.\n* `allow_credentials` - Указывает, что куки разрешены в кросс-доменных запросах. По умолчанию `False`.\n\n    Ни один из параметров `allow_origins`, `allow_methods` и `allow_headers` не может быть установлен в `['*']`, если `allow_credentials` имеет значение `True`. Все они должны быть <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#credentialed_requests_and_wildcards\" class=\"external-link\" rel=\"noopener\" target=\"_blank\">указаны явно</a>.\n\n* `expose_headers` - Указывает любые заголовки ответа, которые должны быть доступны браузеру. По умолчанию `[]`.\n* `max_age` - Устанавливает максимальное время в секундах, в течение которого браузер кэширует CORS-ответы. По умолчанию `600`.\n\n`CORSMiddleware` отвечает на два типа HTTP-запросов...", "metadata": {"title": "CORS (Cross-Origin Resource Sharing)", "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "source_mtime": "2026-01-12T17:48:13.352565+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cors.md", "section_header": "Использование `CORSMiddleware`", "section_header_level": 2}, "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "title": "CORS (Cross-Origin Resource Sharing)", "chunk_index": 6, "header": "Использование `CORSMiddleware`", "header_level": 2, "token_count": 290}
{"id": "9dd7e4c0a44b25b9", "text": "### CORS-запросы с предварительной проверкой { #cors-preflight-requests }\n\nЭто любые `OPTIONS`-запросы с заголовками `Origin` и `Access-Control-Request-Method`.\n\nВ этом случае middleware перехватит входящий запрос и отправит соответствующие CORS-заголовки в ответе, а также ответ `200` или `400` в информационных целях.\n\n", "metadata": {"title": "CORS (Cross-Origin Resource Sharing)", "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "source_mtime": "2026-01-12T17:48:13.352565+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cors.md"}, "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "title": "CORS (Cross-Origin Resource Sharing)", "chunk_index": 7, "header": "CORS-запросы с предварительной проверкой", "header_level": 3, "token_count": 112}
{"id": "34cf2b45ba07a9b1", "text": "### Простые запросы { #simple-requests }\n\nЛюбые запросы с заголовком `Origin`. В этом случае middleware передаст запрос дальше как обычно, но добавит соответствующие CORS-заголовки к ответу.\n\n", "metadata": {"title": "CORS (Cross-Origin Resource Sharing)", "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "source_mtime": "2026-01-12T17:48:13.352565+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cors.md"}, "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "title": "CORS (Cross-Origin Resource Sharing)", "chunk_index": 8, "header": "Простые запросы", "header_level": 3, "token_count": 65}
{"id": "97cf4860afcec2cd", "text": "## Больше информации { #more-info }\n\nДля получения более подробной информации о <abbr title=\"Cross-Origin Resource Sharing – совместное использование ресурсов между источниками\">CORS</abbr> обратитесь к <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\" class=\"external-link\" target=\"_blank\">документации CORS от Mozilla</a>.\n\n/// note | Технические детали\n\nВы также можете использовать `from starlette.middleware.cors import CORSMiddleware`.\n\n**FastAPI** предоставляет несколько middleware в `fastapi.middleware` только для вашего удобства как разработчика. Но большинство доступных middleware взяты напрямую из Starlette.\n\n///\n", "metadata": {"title": "CORS (Cross-Origin Resource Sharing)", "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "source_mtime": "2026-01-12T17:48:13.352565+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\cors.md"}, "doc_id": "e1e77a0c70f6", "source_path": "docs\\tutorial\\cors.md", "title": "CORS (Cross-Origin Resource Sharing)", "chunk_index": 9, "header": "Больше информации", "header_level": 2, "token_count": 191}
{"id": "3dd0c0656aec0145", "text": "# Отладка { #debugging }\n\nВы можете подключить отладчик в своем редакторе, например, в Visual Studio Code или PyCharm.\n\n", "metadata": {"title": "Отладка", "doc_id": "c52d6f6ff5bc", "source_path": "docs\\tutorial\\debugging.md", "source_mtime": "2026-01-12T17:48:13.356657+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\debugging.md"}, "doc_id": "c52d6f6ff5bc", "source_path": "docs\\tutorial\\debugging.md", "title": "Отладка", "chunk_index": 0, "header": "Отладка", "header_level": 1, "token_count": 42}
{"id": "f7de547bb2139150", "text": "## Вызов `uvicorn` { #call-uvicorn }\n\nВ вашем FastAPI приложении, импортируйте и вызовите `uvicorn` напрямую:\n\n{* ../../docs_src/debugging/tutorial001_py39.py hl[1,15] *}\n\n", "metadata": {"title": "Отладка", "doc_id": "c52d6f6ff5bc", "source_path": "docs\\tutorial\\debugging.md", "source_mtime": "2026-01-12T17:48:13.356657+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\debugging.md"}, "doc_id": "c52d6f6ff5bc", "source_path": "docs\\tutorial\\debugging.md", "title": "Отладка", "chunk_index": 1, "header": "Вызов `uvicorn`", "header_level": 2, "token_count": 63}
{"id": "c1c3ba398feda995", "text": "### Описание `__name__ == \"__main__\"` { #about-name-main }\n\nГлавная цель использования `__name__ == \"__main__\"` в том, чтобы код выполнялся при запуске файла с помощью:\n\n<div class=\"termy\">\n\n```console\n$ python myapp.py\n```\n\n</div>\n\nно не вызывался, когда другой файл импортирует это, например:\n\n```Python\nfrom myapp import app\n```\n\n#### Больше деталей { #more-details }\n\nДавайте назовём ваш файл `myapp.py`.\n\nЕсли вы запустите его с помощью:\n\n<div class=\"termy\">\n\n```console\n$ python myapp.py\n```\n\n</div>\n\nто встроенная переменная `__name__`, автоматически создаваемая Python в вашем файле, будет иметь значение строкового типа `\"__main__\"`.\n\nТогда выполнится условие и эта часть кода:\n\n```Python\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\nбудет запущена.\n\n---\n\nНо этого не произойдет, если вы импортируете этот модуль (файл).\n\nТаким образом, если у вас есть файл `importer.py` с таким импортом:\n\n```Python\nfrom myapp import app\n\n", "metadata": {"title": "Отладка", "doc_id": "c52d6f6ff5bc", "source_path": "docs\\tutorial\\debugging.md", "source_mtime": "2026-01-12T17:48:13.356657+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\debugging.md"}, "doc_id": "c52d6f6ff5bc", "source_path": "docs\\tutorial\\debugging.md", "title": "Отладка", "chunk_index": 2, "header": "Описание `__name__ == \"__main__\"`", "header_level": 3, "token_count": 333}
{"id": "81a7795c241ca87a", "text": "# Some more code\n```\n\nто автоматическая создаваемая внутри файла `myapp.py` переменная  `__name__` будет иметь значение отличающееся от `\"__main__\"`.\n\nСледовательно, строка:\n\n```Python\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\nне будет выполнена.\n\n/// info | Информация\n\nДля получения дополнительной информации, ознакомьтесь с <a href=\"https://docs.python.org/3/library/__main__.html\" class=\"external-link\" target=\"_blank\">официальной документацией Python</a>.\n\n///\n\n", "metadata": {"title": "Отладка", "doc_id": "c52d6f6ff5bc", "source_path": "docs\\tutorial\\debugging.md", "source_mtime": "2026-01-12T17:48:13.356657+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\debugging.md"}, "doc_id": "c52d6f6ff5bc", "source_path": "docs\\tutorial\\debugging.md", "title": "Отладка", "chunk_index": 3, "header": "Some more code", "header_level": 1, "token_count": 165}
{"id": "e212335caf2399d4", "text": "## Запуск вашего кода с помощью отладчика { #run-your-code-with-your-debugger }\n\nТак как вы запускаете сервер Uvicorn непосредственно из вашего кода, вы можете вызвать Python программу (ваше FastAPI приложение) напрямую из отладчика.\n\n---\n\nНапример, в Visual Studio Code вы можете выполнить следующие шаги:\n\n* Перейдите на панель \"Debug\".\n* Выберите \"Add configuration...\".\n* Выберите \"Python\"\n* Запустите отладчик \"`Python: Current File (Integrated Terminal)`\".\n\nЭто запустит сервер с вашим **FastAPI** кодом, остановится на точках останова, и т.д.\n\nВот как это может выглядеть:\n\n<img src=\"/img/tutorial/debugging/image01.png\">\n\n---\n\nЕсли используете Pycharm, вы можете выполнить следующие шаги:\n\n* Открыть \"Run\" меню.\n* Выбрать опцию \"Debug...\".\n* Затем в появившемся контекстном меню.\n* Выбрать файл для отладки (в данном случае, `main.py`).\n\nЭто запустит сервер с вашим **FastAPI** кодом, остановится на точках останова, и т.д.\n\nВот как это может выглядеть:\n\n<img src=\"/img/tutorial/debugging/image02.png\">\n", "metadata": {"title": "Отладка", "doc_id": "c52d6f6ff5bc", "source_path": "docs\\tutorial\\debugging.md", "source_mtime": "2026-01-12T17:48:13.356657+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\debugging.md"}, "doc_id": "c52d6f6ff5bc", "source_path": "docs\\tutorial\\debugging.md", "title": "Отладка", "chunk_index": 4, "header": "Запуск вашего кода с помощью отладчика", "header_level": 2, "token_count": 351}
{"id": "50269369fa204aed", "text": "# JSON-совместимый кодировщик { #json-compatible-encoder }\n\nВ некоторых случаях может потребоваться преобразование типа данных (например, Pydantic-модели) в тип, совместимый с JSON (например, `dict`, `list` и т.д.).\n\nНапример, если необходимо хранить его в базе данных.\n\nДля этого **FastAPI** предоставляет функцию `jsonable_encoder()`.\n\n", "metadata": {"title": "JSON-совместимый кодировщик", "doc_id": "2133b0e4958d", "source_path": "docs\\tutorial\\encoder.md", "source_mtime": "2026-01-12T17:48:13.356657+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\encoder.md"}, "doc_id": "2133b0e4958d", "source_path": "docs\\tutorial\\encoder.md", "title": "JSON-совместимый кодировщик", "chunk_index": 0, "header": "JSON-совместимый кодировщик", "header_level": 1, "token_count": 124}
{"id": "6264251485a5d078", "text": "## Использование `jsonable_encoder` { #using-the-jsonable-encoder }\n\nПредставим, что у вас есть база данных `fake_db`, которая принимает только JSON-совместимые данные.\n\nНапример, он не принимает объекты `datetime`, так как они не совместимы с JSON.\n\nВ таком случае объект `datetime` следует преобразовать в строку соответствующую <a href=\"https://en.wikipedia.org/wiki/ISO_8601\" class=\"external-link\" target=\"_blank\">формату ISO</a>.\n\nТочно так же эта база данных не может принять Pydantic-модель (объект с атрибутами), а только `dict`.\n\nДля этого можно использовать функцию `jsonable_encoder`.\n\nОна принимает объект, например, Pydantic-модель, и возвращает его версию, совместимую с JSON:\n\n{* ../../docs_src/encoder/tutorial001_py310.py hl[4,21] *}\n\nВ данном примере она преобразует Pydantic-модель в `dict`, а `datetime` - в `str`.\n\nРезультатом её вызова является объект, который может быть закодирован с помощью функции из стандартной библиотеки Python – <a href=\"https://docs.python.org/3/library/json.html#json.dumps\" class=\"external-link\" target=\"_blank\">`json.dumps()`</a>.\n\nФункция не возвращает большой `str`, содержащий данные в формате JSON (в виде строки). Она возвращает стандартную структуру данных Python (например, `dict`) со значениями и подзначениями, которые совместимы с JSON.\n\n/// note | Примечание\n\n`jsonable_encoder` фактически используется **FastAPI** внутри системы для преобразования данных. Однако он полезен и во многих других сценариях.\n\n///\n", "metadata": {"title": "JSON-совместимый кодировщик", "doc_id": "2133b0e4958d", "source_path": "docs\\tutorial\\encoder.md", "source_mtime": "2026-01-12T17:48:13.356657+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\encoder.md"}, "doc_id": "2133b0e4958d", "source_path": "docs\\tutorial\\encoder.md", "title": "JSON-совместимый кодировщик", "chunk_index": 1, "header": "Использование `jsonable_encoder`", "header_level": 2, "token_count": 499}
{"id": "d1083e420915c030", "text": "# Дополнительные типы данных { #extra-data-types }\n\nДо сих пор вы использовали простые типы данных, такие как:\n\n* `int`\n* `float`\n* `str`\n* `bool`\n\nНо вы также можете использовать и более сложные типы.\n\nПри этом у вас останутся те же возможности, что и до сих пор:\n\n* Отличная поддержка редактора кода.\n* Преобразование данных из входящих запросов.\n* Преобразование данных для ответа.\n* Валидация данных.\n* Автоматическая аннотация и документация.\n\n", "metadata": {"title": "Дополнительные типы данных", "doc_id": "941db00bda96", "source_path": "docs\\tutorial\\extra-data-types.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-data-types.md"}, "doc_id": "941db00bda96", "source_path": "docs\\tutorial\\extra-data-types.md", "title": "Дополнительные типы данных", "chunk_index": 0, "header": "Дополнительные типы данных", "header_level": 1, "token_count": 165}
{"id": "d1083e420915c030", "text": "## Другие типы данных { #other-data-types }\n\nНиже перечислены некоторые из дополнительных типов данных, которые вы можете использовать:", "metadata": {"title": "Дополнительные типы данных", "doc_id": "941db00bda96", "source_path": "docs\\tutorial\\extra-data-types.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-data-types.md", "section_header": "Другие типы данных", "section_header_level": 2}, "doc_id": "941db00bda96", "source_path": "docs\\tutorial\\extra-data-types.md", "title": "Дополнительные типы данных", "chunk_index": 1, "header": "Другие типы данных", "header_level": 2, "token_count": 43}
{"id": "075a335ff502fc48", "text": "## Другие типы данных { #other-data-types }\n\nНиже перечислены некоторые из дополнительных типов данных, которые вы можете использовать:\n\n* `UUID`:\n    * Стандартный \"Универсальный уникальный идентификатор\", используемый в качестве идентификатора во многих базах данных и системах.\n    * В запросах и ответах будет представлен как `str`.\n* `datetime.datetime`:\n    * Встроенный в Python `datetime.datetime`.\n    * В запросах и ответах будет представлен как `str` в формате ISO 8601, например: `2008-09-15T15:53:00+05:00`.\n* `datetime.date`:\n    * Встроенный в Python `datetime.date`.\n    * В запросах и ответах будет представлен как `str` в формате ISO 8601, например: `2008-09-15`.\n* `datetime.time`:\n    * Встроенный в Python `datetime.time`.\n    * В запросах и ответах будет представлен как `str` в формате ISO 8601, например: `14:23:55.003`.\n* `datetime.timedelta`:\n    * Встроенный в Python `datetime.timedelta`.\n    * В запросах и ответах будет представлен в виде общего количества секунд типа `float`.\n    * Pydantic также позволяет представить его как \"Кодировку разницы во времени ISO 8601\", <a href=\"https://docs.pydantic.dev/latest/concepts/serialization/#custom-serializers\" class=\"external-link\" target=\"_blank\">см. документацию для получения дополнительной информации</a>.\n* `frozenset`:\n    * В запросах и ответах обрабатывается так же, как и `set`:\n        * В запросах будет прочитан список, исключены дубликаты и преобразован в `set`.\n        * В ответах `set` будет преобразован в `list`.\n        * В сгенерированной схеме будет указано, что значения `set` уникальны (с помощью JSON-схемы `uniqueItems`).\n* `bytes`:\n    * Встроенный в Python `bytes`.\n    * В запросах и ответах будет рассматриваться как `str`.\n    * В сгенерированной схеме будет указано, что это `str` в формате `binary`.\n* `Decimal`:\n    * Встроенный в Python `Decimal`.\n    * В запросах и ответах обрабатывается так же, как и `float`.\n* Вы можете проверить все допустимые типы данных Pydantic здесь: <a href=\"https://docs.pydantic.dev/latest/usage/types/types/\" class=\"external-link\" target=\"_blank\">Типы данных Pydantic</a>.", "metadata": {"title": "Дополнительные типы данных", "doc_id": "941db00bda96", "source_path": "docs\\tutorial\\extra-data-types.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-data-types.md", "section_header": "Другие типы данных", "section_header_level": 2}, "doc_id": "941db00bda96", "source_path": "docs\\tutorial\\extra-data-types.md", "title": "Дополнительные типы данных", "chunk_index": 2, "header": "Другие типы данных", "header_level": 2, "token_count": 746}
{"id": "132818444e7ee960", "text": ", как и `float`.\n* Вы можете проверить все допустимые типы данных Pydantic здесь: <a href=\"https://docs.pydantic.dev/latest/usage/types/types/\" class=\"external-link\" target=\"_blank\">Типы данных Pydantic</a>.", "metadata": {"title": "Дополнительные типы данных", "doc_id": "941db00bda96", "source_path": "docs\\tutorial\\extra-data-types.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-data-types.md", "section_header": "Другие типы данных", "section_header_level": 2}, "doc_id": "941db00bda96", "source_path": "docs\\tutorial\\extra-data-types.md", "title": "Дополнительные типы данных", "chunk_index": 3, "header": "Другие типы данных", "header_level": 2, "token_count": 64}
{"id": "c0534c4332fb74b4", "text": "## Пример { #example }\n\nВот пример *операции пути* с параметрами, который демонстрирует некоторые из вышеперечисленных типов.\n\n{* ../../docs_src/extra_data_types/tutorial001_an_py310.py hl[1,3,12:16] *}\n\nОбратите внимание, что параметры внутри функции имеют свой естественный тип данных, и вы, например, можете выполнять обычные манипуляции с датами, такие как:\n\n{* ../../docs_src/extra_data_types/tutorial001_an_py310.py hl[18:19] *}\n", "metadata": {"title": "Дополнительные типы данных", "doc_id": "941db00bda96", "source_path": "docs\\tutorial\\extra-data-types.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-data-types.md"}, "doc_id": "941db00bda96", "source_path": "docs\\tutorial\\extra-data-types.md", "title": "Дополнительные типы данных", "chunk_index": 4, "header": "Пример", "header_level": 2, "token_count": 157}
{"id": "758425967d43277d", "text": "# Дополнительные модели { #extra-models }\n\nВ продолжение прошлого примера будет уже обычным делом иметь несколько связанных между собой моделей.\n\nЭто особенно применимо в случае моделей пользователя, потому что:\n\n* **Модель для ввода** должна иметь возможность содержать пароль.\n* **Модель для вывода** не должна содержать пароль.\n* **Модель для базы данных**, возможно, должна содержать хэшированный пароль.\n\n/// danger | Внимание\n\nНикогда не храните пароли пользователей в чистом виде. Всегда храните \"безопасный хэш\", который вы затем сможете проверить.\n\nЕсли вам это не знакомо, вы можете узнать про \"хэш пароля\" в [главах о безопасности](security/simple-oauth2.md#password-hashing){.internal-link target=_blank}.\n\n///\n\n", "metadata": {"title": "Дополнительные модели", "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-models.md"}, "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "title": "Дополнительные модели", "chunk_index": 0, "header": "Дополнительные модели", "header_level": 1, "token_count": 263}
{"id": "d2d9e65fd4471f1f", "text": "## Множественные модели { #multiple-models }\n\nНиже изложена основная идея того, как могут выглядеть эти модели с полями для паролей, а также описаны места, где они используются:\n\n{* ../../docs_src/extra_models/tutorial001_py310.py hl[7,9,14,20,22,27:28,31:33,38:39] *}\n\n/// info | Информация\n\nВ Pydantic v1 метод назывался `.dict()`, в Pydantic v2 он помечен как устаревший (но всё ещё поддерживается) и переименован в `.model_dump()`.\n\nВ примерах здесь используется `.dict()` для совместимости с Pydantic v1, но если вы используете Pydantic v2, следует использовать `.model_dump()`.\n\n///\n\n", "metadata": {"title": "Дополнительные модели", "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-models.md"}, "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "title": "Дополнительные модели", "chunk_index": 1, "header": "Множественные модели", "header_level": 2, "token_count": 227}
{"id": "758425967d43277d", "text": "### Про `**user_in.dict()` { #about-user-in-dict }\n\n#### `.dict()` из Pydantic { #pydantics-dict }\n\n`user_in` - это Pydantic-модель класса `UserIn`.\n\nУ Pydantic-моделей есть метод `.dict()`, который возвращает `dict` с данными модели.\n\nПоэтому, если мы создадим Pydantic-объект `user_in` таким способом:\n\n```Python\nuser_in = UserIn(username=\"john\", password=\"secret\", email=\"john.doe@example.com\")\n```\n\nи затем вызовем:\n\n```Python\nuser_dict = user_in.dict()\n```\n\nто теперь у нас есть `dict` с данными модели в переменной `user_dict` (это `dict` вместо объекта Pydantic-модели).\n\nИ если мы вызовем:\n\n```Python\nprint(user_dict)\n```\n\nмы можем получить `dict` с такими данными:\n\n```Python\n{\n    'username': 'john',\n    'password': 'secret',\n    'email': 'john.doe@example.com',\n    'full_name': None,\n}\n```\n\n#### Распаковка `dict` { #unpacking-a-dict }\n\nЕсли мы возьмём `dict` наподобие `user_dict` и передадим его в функцию (или класс), используя `**user_dict`, Python распакует его. Он передаст ключи и значения `user_dict` напрямую как аргументы типа ключ-значение.\n\nПоэтому, продолжая описанный выше пример с `user_dict`, написание такого кода:\n\n```Python\nUserInDB(**user_dict)\n```\n\nБудет работать так же, как примерно такой код:\n\n```Python\nUserInDB(\n    username=\"john\",\n    password=\"secret\",\n    email=\"john.doe@example.com\",\n    full_name=None,\n)\n```\n\nИли, если для большей точности мы напрямую используем `user_dict` с любым потенциальным содержимым, то этот пример будет выглядеть так:", "metadata": {"title": "Дополнительные модели", "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-models.md", "section_header": "Про `**user_in.dict()`", "section_header_level": 3}, "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "title": "Дополнительные модели", "chunk_index": 2, "header": "Про `**user_in.dict()`", "header_level": 3, "token_count": 510}
{"id": "d2d9e65fd4471f1f", "text": "@example.com\",\n    full_name=None,\n)\n```\n\nИли, если для большей точности мы напрямую используем `user_dict` с любым потенциальным содержимым, то этот пример будет выглядеть так:\n\n```Python\nUserInDB(\n    username = user_dict[\"username\"],\n    password = user_dict[\"password\"],\n    email = user_dict[\"email\"],\n    full_name = user_dict[\"full_name\"],\n)\n```\n\n#### Pydantic-модель из содержимого другой модели { #a-pydantic-model-from-the-contents-of-another }\n\nКак в примере выше мы получили `user_dict` из `user_in.dict()`, этот код:\n\n```Python\nuser_dict = user_in.dict()\nUserInDB(**user_dict)\n```\n\nбудет равнозначен такому:\n\n```Python\nUserInDB(**user_in.dict())\n```\n\n...потому что `user_in.dict()` - это `dict`, и затем мы указываем, чтобы Python его \"распаковал\", когда передаём его в `UserInDB` и ставим перед ним `**`.\n\nТаким образом мы получаем Pydantic-модель на основе данных из другой Pydantic-модели.\n\n#### Распаковка `dict` и дополнительные именованные аргументы { #unpacking-a-dict-and-extra-keywords }\n\nИ затем, если мы добавим дополнительный именованный аргумент `hashed_password=hashed_password` как здесь:\n\n```Python\nUserInDB(**user_in.dict(), hashed_password=hashed_password)\n```\n\n... то мы получим что-то подобное:\n\n```Python\nUserInDB(\n    username = user_dict[\"username\"],\n    password = user_dict[\"password\"],\n    email = user_dict[\"email\"],\n    full_name = user_dict[\"full_name\"],\n    hashed_password = hashed_password,\n)\n```\n\n/// warning | Предупреждение", "metadata": {"title": "Дополнительные модели", "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-models.md", "section_header": "Про `**user_in.dict()`", "section_header_level": 3}, "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "title": "Дополнительные модели", "chunk_index": 3, "header": "Про `**user_in.dict()`", "header_level": 3, "token_count": 463}
{"id": "72458d3853b9981c", "text": "ное:\n\n```Python\nUserInDB(\n    username = user_dict[\"username\"],\n    password = user_dict[\"password\"],\n    email = user_dict[\"email\"],\n    full_name = user_dict[\"full_name\"],\n    hashed_password = hashed_password,\n)\n```\n\n/// warning | Предупреждение\n\nВспомогательные функции `fake_password_hasher` и `fake_save_user` используются только для демонстрации возможного потока данных и, конечно, не обеспечивают настоящую безопасность.\n\n///", "metadata": {"title": "Дополнительные модели", "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-models.md", "section_header": "Про `**user_in.dict()`", "section_header_level": 3}, "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "title": "Дополнительные модели", "chunk_index": 4, "header": "Про `**user_in.dict()`", "header_level": 3, "token_count": 127}
{"id": "8cbe4747b0290c4d", "text": "## Сократите дублирование { #reduce-duplication }\n\nСокращение дублирования кода - это одна из главных идей **FastAPI**.\n\nПоскольку дублирование кода повышает риск появления багов, проблем с безопасностью, проблем десинхронизации кода (когда вы обновляете код в одном месте, но не обновляете в другом), и т.д.\n\nА все описанные выше модели используют много общих данных и дублируют названия атрибутов и типов.\n\nМы можем это улучшить.\n\nМы можем определить модель `UserBase`, которая будет базовой для остальных моделей. И затем мы можем создать подклассы этой модели, которые будут наследовать её атрибуты (объявления типов, валидацию, и т.п.).\n\nВсе операции конвертации, валидации, документации, и т.п. будут по-прежнему работать нормально.\n\nВ этом случае мы можем определить только различия между моделями (с `password` в чистом виде, с `hashed_password` и без пароля):\n\n{* ../../docs_src/extra_models/tutorial002_py310.py hl[7,13:14,17:18,21:22] *}\n\n", "metadata": {"title": "Дополнительные модели", "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-models.md"}, "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "title": "Дополнительные модели", "chunk_index": 5, "header": "Сократите дублирование", "header_level": 2, "token_count": 376}
{"id": "6a1c21e9da878370", "text": "## `Union` или `anyOf` { #union-or-anyof }\n\nВы можете определить ответ как `Union` из двух или более типов. Это означает, что ответ должен соответствовать одному из них.\n\nОн будет определён в OpenAPI как `anyOf`.\n\nДля этого используйте стандартную аннотацию типов в Python <a href=\"https://docs.python.org/3/library/typing.html#typing.Union\" class=\"external-link\" target=\"_blank\">`typing.Union`</a>:\n\n/// note | Примечание\n\nПри объявлении <a href=\"https://docs.pydantic.dev/latest/concepts/types/#unions\" class=\"external-link\" target=\"_blank\">`Union`</a>, сначала указывайте наиболее детальные типы, затем менее детальные. В примере ниже более детальный `PlaneItem` стоит перед `CarItem` в `Union[PlaneItem, CarItem]`.\n\n///\n\n{* ../../docs_src/extra_models/tutorial003_py310.py hl[1,14:15,18:20,33] *}\n\n", "metadata": {"title": "Дополнительные модели", "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-models.md"}, "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "title": "Дополнительные модели", "chunk_index": 6, "header": "`Union` или `anyOf`", "header_level": 2, "token_count": 279}
{"id": "8f804b3a58eaab45", "text": "### `Union` в Python 3.10 { #union-in-python-3-10 }\n\nВ этом примере мы передаём `Union[PlaneItem, CarItem]` в качестве значения аргумента `response_model`.\n\nПоскольку мы передаём его как **значение аргумента** вместо того, чтобы поместить его в **аннотацию типа**, нам придётся использовать `Union` даже в Python 3.10.\n\nЕсли оно было бы указано в аннотации типа, то мы могли бы использовать вертикальную черту как в примере:\n\n```Python\nsome_variable: PlaneItem | CarItem\n```\n\nНо если мы помещаем его в `response_model=PlaneItem | CarItem` мы получим ошибку, потому что Python попытается произвести **некорректную операцию** между `PlaneItem` и `CarItem` вместо того, чтобы интерпретировать это как аннотацию типа.\n\n", "metadata": {"title": "Дополнительные модели", "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-models.md"}, "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "title": "Дополнительные модели", "chunk_index": 7, "header": "`Union` в Python 3.10", "header_level": 3, "token_count": 261}
{"id": "7d548a18ee6e68bb", "text": "## Список моделей { #list-of-models }\n\nТаким же образом вы можете определять ответы как списки объектов.\n\nДля этого используйте `typing.List` из стандартной библиотеки Python (или просто `list` в Python 3.9 и выше):\n\n{* ../../docs_src/extra_models/tutorial004_py39.py hl[18] *}\n\n", "metadata": {"title": "Дополнительные модели", "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-models.md"}, "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "title": "Дополнительные модели", "chunk_index": 8, "header": "Список моделей", "header_level": 2, "token_count": 97}
{"id": "62ec9f7952af24e3", "text": "## Ответ с произвольным `dict` { #response-with-arbitrary-dict }\n\nВы также можете определить ответ, используя произвольный одноуровневый `dict` и определяя только типы ключей и значений без использования Pydantic-моделей.\n\nЭто полезно, если вы заранее не знаете корректных названий полей/атрибутов (которые будут нужны при использовании Pydantic-модели).\n\nВ этом случае вы можете использовать `typing.Dict` (или просто `dict` в Python 3.9 и выше):\n\n{* ../../docs_src/extra_models/tutorial005_py39.py hl[6] *}\n\n", "metadata": {"title": "Дополнительные модели", "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-models.md"}, "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "title": "Дополнительные модели", "chunk_index": 9, "header": "Ответ с произвольным `dict`", "header_level": 2, "token_count": 180}
{"id": "9f688c25a2823161", "text": "## Резюме { #recap }\n\nИспользуйте несколько Pydantic-моделей и свободно применяйте наследование для каждой из них.\n\nВам не обязательно иметь единственную модель данных для каждой сущности, если эта сущность должна иметь возможность быть в разных \"состояниях\". Как в случае с \"сущностью\" пользователя, у которого есть состояния с полями `password`, `password_hash` и без пароля.\n", "metadata": {"title": "Дополнительные модели", "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\extra-models.md"}, "doc_id": "9d0aaa42cc53", "source_path": "docs\\tutorial\\extra-models.md", "title": "Дополнительные модели", "chunk_index": 10, "header": "Резюме", "header_level": 2, "token_count": 139}
{"id": "35c79df9a3b9f2ad", "text": "# Первые шаги { #first-steps }\n\nСамый простой файл FastAPI может выглядеть так:\n\n{* ../../docs_src/first_steps/tutorial001_py39.py *}\n\nСкопируйте это в файл `main.py`.\n\nЗапустите сервер в режиме реального времени:\n\n<div class=\"termy\">\n\n```console\n$ <font color=\"#4E9A06\">fastapi</font> dev <u style=\"text-decoration-style:solid\">main.py</u>\n\n  <span style=\"background-color:#009485\"><font color=\"#D3D7CF\"> FastAPI </font></span>  Starting development server 🚀\n\n             Searching for package file structure from directories\n             with <font color=\"#3465A4\">__init__.py</font> files\n             Importing from <font color=\"#75507B\">/home/user/code/</font><font color=\"#AD7FA8\">awesomeapp</font>\n\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> module </font></span>  🐍 main.py\n\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> code </font></span>  Importing the FastAPI app object from the module with\n             the following code:\n\n             <u style=\"text-decoration-style:solid\">from </u><u style=\"text-decoration-style:solid\"><b>main</b></u><u style=\"text-decoration-style:solid\"> import </u><u style=\"text-decoration-style:solid\"><b>app</b></u>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> app </font></span>  Using import string: <font color=\"#3465A4\">main:app</font>", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md", "section_header": "Первые шаги", "section_header_level": 1}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 0, "header": "Первые шаги", "header_level": 1, "token_count": 399}
{"id": "8a2ed1718264ae5d", "text": "><u style=\"text-decoration-style:solid\"><b>app</b></u>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> app </font></span>  Using import string: <font color=\"#3465A4\">main:app</font>\n\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Server started at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://127.0.0.1:8000</u></font>\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Documentation at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://127.0.0.1:8000/docs</u></font>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> tip </font></span>  Running in development mode, for production use:\n             <b>fastapi run</b>\n\n             Logs:", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md", "section_header": "Первые шаги", "section_header_level": 1}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 1, "header": "Первые шаги", "header_level": 1, "token_count": 241}
{"id": "ff4cb891518c3bb2", "text": ".0.0.1:8000/docs</u></font>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> tip </font></span>  Running in development mode, for production use:\n             <b>fastapi run</b>\n\n             Logs:\n\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Will watch for changes in these directories:\n             <b>[</b><font color=\"#4E9A06\">&apos;/home/user/code/awesomeapp&apos;</font><b>]</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Uvicorn running on <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://127.0.0.1:8000</u></font> <b>(</b>Press CTRL+C\n             to quit<b>)</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started reloader process <b>[</b><font color=\"#34E2E2\"><b>383138</b></font><b>]</b> using WatchFiles\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started server process <b>[</b><font color=\"#34E2E2\"><b>383153</b></font><b>]</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Waiting for application startup.\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Application startup complete.\n```\n\n</div>\n\nВ выводе будет строка примерно такого вида:\n\n```hl_lines=\"4\"\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\nЭта строка показывает URL, по которому ваше приложение доступно на локальной машине.", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md", "section_header": "Первые шаги", "section_header_level": 1}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 2, "header": "Первые шаги", "header_level": 1, "token_count": 487}
{"id": "a6d77e63bd02beda", "text": "### Проверьте { #check-it }\n\nОткройте браузер по адресу: <a href=\"http://127.0.0.1:8000\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000</a>.\n\nВы увидите JSON-ответ вида:\n\n```JSON\n{\"message\": \"Hello World\"}\n```\n\n", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md"}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 3, "header": "Проверьте", "header_level": 3, "token_count": 90}
{"id": "b8d244e4d9997712", "text": "### Интерактивная документация API { #interactive-api-docs }\n\nТеперь перейдите по адресу: <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a>.\n\nВы увидите автоматически сгенерированную интерактивную документацию по API (предоставлено <a href=\"https://github.com/swagger-api/swagger-ui\" class=\"external-link\" target=\"_blank\">Swagger UI</a>):\n\n![Swagger UI](https://fastapi.tiangolo.com/img/index/index-01-swagger-ui-simple.png)\n\n", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md"}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 4, "header": "Интерактивная документация API", "header_level": 3, "token_count": 158}
{"id": "58b52f4b04dd86c9", "text": "### Альтернативная документация API { #alternative-api-docs }\n\nИ теперь перейдите по адресу <a href=\"http://127.0.0.1:8000/redoc\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/redoc</a>.\n\nВы увидите альтернативную автоматически сгенерированную документацию (предоставлено <a href=\"https://github.com/Rebilly/ReDoc\" class=\"external-link\" target=\"_blank\">ReDoc</a>):\n\n![ReDoc](https://fastapi.tiangolo.com/img/index/index-02-redoc-simple.png)\n\n", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md"}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 5, "header": "Альтернативная документация API", "header_level": 3, "token_count": 164}
{"id": "35c79df9a3b9f2ad", "text": "### OpenAPI { #openapi }\n\n**FastAPI** генерирует «схему» всего вашего API, используя стандарт **OpenAPI** для описания API.\n\n#### «Схема» { #schema }\n\n«Схема» — это определение или описание чего-либо. Не код, который это реализует, а только абстрактное описание.\n\n#### «Схема» API { #api-schema }\n\nВ данном случае <a href=\"https://github.com/OAI/OpenAPI-Specification\" class=\"external-link\" target=\"_blank\">OpenAPI</a> — это спецификация, которая определяет, как описывать схему вашего API.\n\nЭто определение схемы включает пути вашего API, возможные параметры, которые они принимают, и т. п.\n\n#### «Схема» данных { #data-schema }\n\nТермин «схема» также может относиться к форме некоторых данных, например, к содержимому JSON.\n\nВ таком случае это будут атрибуты JSON, их типы данных и т. п.\n\n#### OpenAPI и JSON Schema { #openapi-and-json-schema }\n\nOpenAPI определяет схему API для вашего API. И эта схема включает определения (или «схемы») данных, отправляемых и получаемых вашим API, с использованием стандарта **JSON Schema** для схем данных JSON.\n\n#### Посмотрите `openapi.json` { #check-the-openapi-json }\n\nЕсли вам интересно, как выглядит исходная схема OpenAPI, FastAPI автоматически генерирует JSON (схему) с описанием всего вашего API.", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md", "section_header": "OpenAPI", "section_header_level": 3}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 6, "header": "OpenAPI", "header_level": 3, "token_count": 455}
{"id": "8a2ed1718264ae5d", "text": "{ #check-the-openapi-json }\n\nЕсли вам интересно, как выглядит исходная схема OpenAPI, FastAPI автоматически генерирует JSON (схему) с описанием всего вашего API.\n\nВы можете посмотреть её напрямую по адресу: <a href=\"http://127.0.0.1:8000/openapi.json\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/openapi.json</a>.\n\nВы увидите JSON, начинающийся примерно так:\n\n```JSON\n{\n    \"openapi\": \"3.1.0\",\n    \"info\": {\n        \"title\": \"FastAPI\",\n        \"version\": \"0.1.0\"\n    },\n    \"paths\": {\n        \"/items/\": {\n            \"get\": {\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\n                            \"application/json\": {\n\n\n\n...\n```\n\n#### Для чего нужен OpenAPI { #what-is-openapi-for }\n\nСхема OpenAPI является основой для обеих включённых систем интерактивной документации.\n\nЕсть десятки альтернатив, все основаны на OpenAPI. Вы можете легко добавить любую из них в ваше приложение, созданное с **FastAPI**.\n\nВы также можете использовать её для автоматической генерации кода для клиентов, которые взаимодействуют с вашим API. Например, для фронтенд-, мобильных или IoT-приложений.", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md", "section_header": "OpenAPI", "section_header_level": 3}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 7, "header": "OpenAPI", "header_level": 3, "token_count": 404}
{"id": "8788df0791e9d57e", "text": "### Разверните приложение (необязательно) { #deploy-your-app-optional }\n\nПри желании вы можете развернуть своё приложение FastAPI в <a href=\"https://fastapicloud.com\" class=\"external-link\" target=\"_blank\">FastAPI Cloud</a>, перейдите и присоединитесь к списку ожидания, если ещё не сделали этого. \n\nЕсли у вас уже есть аккаунт **FastAPI Cloud** (мы пригласили вас из списка ожидания ), вы можете развернуть приложение одной командой.\n\nПеред развертыванием убедитесь, что вы вошли в систему:\n\n<div class=\"termy\">\n\n```console\n$ fastapi login\n\nYou are logged in to FastAPI Cloud 🚀\n```\n\n</div>\n\nЗатем разверните приложение:\n\n<div class=\"termy\">\n\n```console\n$ fastapi deploy\n\nDeploying to FastAPI Cloud...\n\n✅ Deployment successful!\n\n🐔 Ready the chicken! Your app is ready at https://myapp.fastapicloud.dev\n```\n\n</div>\n\nГотово! Теперь вы можете открыть своё приложение по этому URL. \n\n", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md"}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 8, "header": "Разверните приложение (необязательно)", "header_level": 3, "token_count": 301}
{"id": "ec8d129f311f3145", "text": "## Рассмотрим поэтапно { #recap-step-by-step }\n\n", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md"}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 9, "header": "Рассмотрим поэтапно", "header_level": 2, "token_count": 18}
{"id": "53cfbc0e45f26931", "text": "### Шаг 1: импортируйте `FastAPI` { #step-1-import-fastapi }\n\n{* ../../docs_src/first_steps/tutorial001_py39.py hl[1] *}\n\n`FastAPI` — это класс на Python, который предоставляет всю функциональность для вашего API.\n\n/// note | Технические детали\n\n`FastAPI` — это класс, который напрямую наследуется от `Starlette`.\n\nВы можете использовать весь функционал <a href=\"https://www.starlette.dev/\" class=\"external-link\" target=\"_blank\">Starlette</a> и в `FastAPI`.\n\n///\n\n", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md"}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 10, "header": "Шаг 1: импортируйте `FastAPI`", "header_level": 3, "token_count": 151}
{"id": "2b1e3ccced4c63a9", "text": "### Шаг 2: создайте экземпляр `FastAPI` { #step-2-create-a-fastapi-instance }\n\n{* ../../docs_src/first_steps/tutorial001_py39.py hl[3] *}\n\nЗдесь переменная `app` будет экземпляром класса `FastAPI`.\n\nЭто будет основная точка взаимодействия для создания всего вашего API.\n\n", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md"}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 11, "header": "Шаг 2: создайте экземпляр `FastAPI`", "header_level": 3, "token_count": 94}
{"id": "35c79df9a3b9f2ad", "text": "### Шаг 3: создайте *операцию пути (path operation)* { #step-3-create-a-path-operation }\n\n#### Путь (path) { #path }\n\nЗдесь «путь» — это последняя часть URL, начиная с первого символа `/`.\n\nИтак, в таком URL:\n\n```\nhttps://example.com/items/foo\n```\n\n...путь будет:\n\n```\n/items/foo\n```\n\n/// info | Информация\n\n«Путь» также часто называют «эндпоинт» или «маршрут».\n\n///\n\nПри создании API «путь» — это основной способ разделения «задач» и «ресурсов».\n\n#### Операция (operation) { #operation }\n\n«Операция» здесь — это один из HTTP-«методов».\n\nОдин из:\n\n* `POST`\n* `GET`\n* `PUT`\n* `DELETE`\n\n...и более экзотические:\n\n* `OPTIONS`\n* `HEAD`\n* `PATCH`\n* `TRACE`\n\nВ протоколе HTTP можно обращаться к каждому пути, используя один (или несколько) из этих «методов».\n\n---\n\nПри создании API обычно используют конкретные HTTP-методы для выполнения конкретных действий.\n\nОбычно используют:\n\n* `POST`: создать данные.\n* `GET`: прочитать данные.\n* `PUT`: обновить данные.\n* `DELETE`: удалить данные.\n\nТаким образом, в OpenAPI каждый HTTP-метод называется «операцией».\n\nМы тоже будем называть их «операциями».\n\n#### Определите *декоратор операции пути (path operation decorator)* { #define-a-path-operation-decorator }\n\n{* ../../docs_src/first_steps/tutorial001_py39.py hl[6] *}\n\n`@app.get(\"/\")` сообщает **FastAPI**, что функция прямо под ним отвечает за обработку запросов, поступающих:", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md", "section_header": "Шаг 3: создайте *операцию пути (path operation)*", "section_header_level": 3}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 12, "header": "Шаг 3: создайте *операцию пути (path operation)*", "header_level": 3, "token_count": 512}
{"id": "8a2ed1718264ae5d", "text": "-a-path-operation-decorator }\n\n{* ../../docs_src/first_steps/tutorial001_py39.py hl[6] *}\n\n`@app.get(\"/\")` сообщает **FastAPI**, что функция прямо под ним отвечает за обработку запросов, поступающих:\n\n* по пути `/`\n* с использованием <abbr title=\"метод HTTP GET\"><code>get</code> операции</abbr>\n\n/// info | Информация о `@decorator`\n\nСинтаксис `@something` в Python называется «декоратор».\n\nЕго размещают над функцией. Как красивая декоративная шляпа (кажется, отсюда и пошёл термин).\n\n«Декоратор» берёт функцию ниже и делает с ней что-то.\n\nВ нашем случае этот декоратор сообщает **FastAPI**, что функция ниже соответствует **пути** `/` с **операцией** `get`.\n\nЭто и есть «декоратор операции пути».\n\n///\n\nМожно также использовать другие операции:\n\n* `@app.post()`\n* `@app.put()`\n* `@app.delete()`\n\nИ более экзотические:\n\n* `@app.options()`\n* `@app.head()`\n* `@app.patch()`\n* `@app.trace()`\n\n/// tip | Подсказка\n\nВы можете использовать каждый метод (HTTP-операцию) так, как считаете нужным.\n\n**FastAPI** не навязывает какого-либо конкретного смысла.\n\nЭта информация дана как рекомендация, а не требование.\n\nНапример, при использовании GraphQL обычно все действия выполняются только с помощью POST-операций.\n\n///", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md", "section_header": "Шаг 3: создайте *операцию пути (path operation)*", "section_header_level": 3}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 13, "header": "Шаг 3: создайте *операцию пути (path operation)*", "header_level": 3, "token_count": 460}
{"id": "0503e8e162872f2e", "text": "### Шаг 4: определите **функцию операции пути** { #step-4-define-the-path-operation-function }\n\nВот наша «функция операции пути»:\n\n* **путь**: `/`.\n* **операция**: `get`.\n* **функция**: функция ниже «декоратора» (ниже `@app.get(\"/\")`).\n\n{* ../../docs_src/first_steps/tutorial001_py39.py hl[7] *}\n\nЭто функция на Python.\n\n**FastAPI** будет вызывать её каждый раз, когда получает запрос к URL «`/`» с операцией `GET`.\n\nВ данном случае это асинхронная (`async`) функция.\n\n---\n\nВы также можете определить её как обычную функцию вместо `async def`:\n\n{* ../../docs_src/first_steps/tutorial003_py39.py hl[7] *}\n\n/// note | Примечание\n\nЕсли вы не знаете, в чём разница, посмотрите [Асинхронность: *\"Нет времени?\"*](../async.md#in-a-hurry){.internal-link target=_blank}.\n\n///\n\n", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md"}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 14, "header": "Шаг 4: определите **функцию операции пути**", "header_level": 3, "token_count": 278}
{"id": "7144342a403bf165", "text": "### Шаг 5: верните содержимое { #step-5-return-the-content }\n\n{* ../../docs_src/first_steps/tutorial001_py39.py hl[8] *}\n\nВы можете вернуть `dict`, `list`, отдельные значения `str`, `int` и т.д.\n\nТакже можно вернуть модели Pydantic (подробнее об этом позже).\n\nМногие другие объекты и модели будут автоматически преобразованы в JSON (включая ORM и т. п.). Попробуйте использовать те, что вам привычнее, с высокой вероятностью они уже поддерживаются.\n\n", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md"}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 15, "header": "Шаг 5: верните содержимое", "header_level": 3, "token_count": 172}
{"id": "ebbd003b6c3d3d1e", "text": "### Шаг 6: разверните приложение { #step-6-deploy-it }\n\nРазверните приложение в **<a href=\"https://fastapicloud.com\" class=\"external-link\" target=\"_blank\">FastAPI Cloud</a>** одной командой: `fastapi deploy`. \n\n#### О FastAPI Cloud { #about-fastapi-cloud }\n\n**<a href=\"https://fastapicloud.com\" class=\"external-link\" target=\"_blank\">FastAPI Cloud</a>** создан тем же автором и командой, что и **FastAPI**.\n\nОн упрощает процесс **создания образа**, **развертывания** и **доступа** к API с минимальными усилиями.\n\nОн переносит тот же **опыт разработчика** при создании приложений с FastAPI на их **развертывание** в облаке. \n\nFastAPI Cloud — основной спонсор и источник финансирования для open-source проектов «FastAPI и друзья». \n\n#### Развертывание у других облачных провайдеров { #deploy-to-other-cloud-providers }\n\nFastAPI — open-source и основан на стандартах. Вы можете развернуть приложения FastAPI у любого облачного провайдера по вашему выбору.\n\nСледуйте руководствам вашего облачного провайдера, чтобы развернуть приложения FastAPI у них. \n\n", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md"}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 16, "header": "Шаг 6: разверните приложение", "header_level": 3, "token_count": 375}
{"id": "89fc17c3c57c2048", "text": "## Резюме { #recap }\n\n* Импортируйте `FastAPI`.\n* Создайте экземпляр `app`.\n* Напишите **декоратор операции пути**, например `@app.get(\"/\")`.\n* Определите **функцию операции пути**; например, `def root(): ...`.\n* Запустите сервер разработки командой `fastapi dev`.\n* При желании разверните приложение командой `fastapi deploy`.\n", "metadata": {"title": "Первые шаги", "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.372705+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\first-steps.md"}, "doc_id": "63e8c306a19d", "source_path": "docs\\tutorial\\first-steps.md", "title": "Первые шаги", "chunk_index": 17, "header": "Резюме", "header_level": 2, "token_count": 128}
{"id": "94adf8487738b684", "text": "# Обработка ошибок { #handling-errors }\n\nСуществует множество ситуаций, когда необходимо сообщить об ошибке клиенту, использующему ваш API.\n\nТаким клиентом может быть браузер с фронтендом, чужой код, IoT-устройство и т.д.\n\nВозможно, вам придется сообщить клиенту о следующем:\n\n* Клиент не имеет достаточных привилегий для выполнения данной операции.\n* Клиент не имеет доступа к данному ресурсу.\n* Элемент, к которому клиент пытался получить доступ, не существует.\n* и т.д.\n\nВ таких случаях обычно возвращается **HTTP-код статуса ответа** в диапазоне **400** (от 400 до 499).\n\nОни похожи на двухсотые HTTP статус-коды (от 200 до 299), которые означают, что запрос обработан успешно.\n\nЧетырёхсотые статус-коды означают, что ошибка произошла по вине клиента.\n\nПомните ли ошибки **\"404 Not Found \"** (и шутки) ?\n\n", "metadata": {"title": "Обработка ошибок", "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "source_mtime": "2026-01-12T17:48:13.388455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\handling-errors.md"}, "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "title": "Обработка ошибок", "chunk_index": 0, "header": "Обработка ошибок", "header_level": 1, "token_count": 321}
{"id": "a92e768a0ac33f07", "text": "## Использование `HTTPException` { #use-httpexception }\n\nДля возврата клиенту HTTP-ответов с ошибками используется `HTTPException`.\n\n", "metadata": {"title": "Обработка ошибок", "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "source_mtime": "2026-01-12T17:48:13.388455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\handling-errors.md"}, "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "title": "Обработка ошибок", "chunk_index": 1, "header": "Использование `HTTPException`", "header_level": 2, "token_count": 40}
{"id": "58d066b11a743c09", "text": "### Импортируйте `HTTPException` { #import-httpexception }\n\n{* ../../docs_src/handling_errors/tutorial001_py39.py hl[1] *}\n\n", "metadata": {"title": "Обработка ошибок", "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "source_mtime": "2026-01-12T17:48:13.388455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\handling-errors.md"}, "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "title": "Обработка ошибок", "chunk_index": 2, "header": "Импортируйте `HTTPException`", "header_level": 3, "token_count": 37}
{"id": "a65daa2d58e3d4da", "text": "### Вызовите `HTTPException` в своем коде { #raise-an-httpexception-in-your-code }\n\n`HTTPException` - это обычное исключение Python с дополнительными данными, актуальными для API.\n\nПоскольку это исключение Python, то его не `возвращают`, а `вызывают`.\n\nЭто также означает, что если вы находитесь внутри функции, которая вызывается внутри вашей *функции операции пути*, и вы поднимаете `HTTPException` внутри этой функции, то она не будет выполнять остальной код в *функции операции пути*, а сразу завершит запрос и отправит HTTP-ошибку из `HTTPException` клиенту.\n\nО том, насколько выгоднее `вызывать` исключение, чем `возвращать` значение, будет рассказано в разделе, посвященном зависимостям и безопасности.\n\nВ данном примере, когда клиент запрашивает элемент по несуществующему ID, возникает исключение со статус-кодом `404`:\n\n{* ../../docs_src/handling_errors/tutorial001_py39.py hl[11] *}\n\n", "metadata": {"title": "Обработка ошибок", "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "source_mtime": "2026-01-12T17:48:13.388455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\handling-errors.md"}, "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "title": "Обработка ошибок", "chunk_index": 3, "header": "Вызовите `HTTPException` в своем коде", "header_level": 3, "token_count": 330}
{"id": "12a28c4cc10c0cd3", "text": "### Возвращаемый ответ { #the-resulting-response }\n\nЕсли клиент запросит `http://example.com/items/foo` (`item_id` `\"foo\"`), то он получит статус-код 200 и ответ в формате JSON:\n\n```JSON\n{\n  \"item\": \"The Foo Wrestlers\"\n}\n```\n\nНо если клиент запросит `http://example.com/items/bar` (несуществующий `item_id` `\"bar\"`), то он получит статус-код 404 (ошибка \"не найдено\") и JSON-ответ в виде:\n\n```JSON\n{\n  \"detail\": \"Item not found\"\n}\n```\n\n/// tip | Подсказка\n\nПри вызове `HTTPException` в качестве параметра `detail` можно передавать любое значение, которое может быть преобразовано в JSON, а не только `str`.\n\nВы можете передать `dict`, `list` и т.д.\n\nОни автоматически обрабатываются **FastAPI** и преобразуются в JSON.\n\n///\n\n", "metadata": {"title": "Обработка ошибок", "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "source_mtime": "2026-01-12T17:48:13.388455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\handling-errors.md"}, "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "title": "Обработка ошибок", "chunk_index": 4, "header": "Возвращаемый ответ", "header_level": 3, "token_count": 250}
{"id": "301483cd231c772f", "text": "## Добавление пользовательских заголовков { #add-custom-headers }\n\nВ некоторых ситуациях полезно иметь возможность добавлять пользовательские заголовки к ошибке HTTP. Например, для некоторых типов безопасности.\n\nСкорее всего, вам не потребуется использовать его непосредственно в коде.\n\nНо в случае, если это необходимо для продвинутого сценария, можно добавить пользовательские заголовки:\n\n{* ../../docs_src/handling_errors/tutorial002_py39.py hl[14] *}\n\n", "metadata": {"title": "Обработка ошибок", "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "source_mtime": "2026-01-12T17:48:13.388455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\handling-errors.md"}, "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "title": "Обработка ошибок", "chunk_index": 5, "header": "Добавление пользовательских заголовков", "header_level": 2, "token_count": 151}
{"id": "5e1e0a584c4def03", "text": "## Установка пользовательских обработчиков исключений { #install-custom-exception-handlers }\n\nВы можете добавить пользовательские обработчики исключений с помощью <a href=\"https://www.starlette.dev/exceptions/\" class=\"external-link\" target=\"_blank\">тех же утилит обработки исключений из Starlette</a>.\n\nДопустим, у вас есть пользовательское исключение `UnicornException`, которое вы (или используемая вами библиотека) можете `вызвать`.\n\nИ вы хотите обрабатывать это исключение глобально с помощью FastAPI.\n\nМожно добавить собственный обработчик исключений с помощью `@app.exception_handler()`:\n\n{* ../../docs_src/handling_errors/tutorial003_py39.py hl[5:7,13:18,24] *}\n\nЗдесь, если запросить `/unicorns/yolo`, то *операция пути* вызовет `UnicornException`.\n\nНо оно будет обработано `unicorn_exception_handler`.\n\nТаким образом, вы получите чистую ошибку с кодом состояния HTTP `418` и содержимым JSON:\n\n```JSON\n{\"message\": \"Oops! yolo did something. There goes a rainbow...\"}\n```\n\n/// note | Технические детали\n\nТакже можно использовать `from starlette.requests import Request` и `from starlette.responses import JSONResponse`.\n\n**FastAPI** предоставляет тот же `starlette.responses`, что и `fastapi.responses`, просто для удобства разработчика. Однако большинство доступных ответов поступает непосредственно из Starlette. То же самое касается и `Request`.\n\n///\n\n", "metadata": {"title": "Обработка ошибок", "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "source_mtime": "2026-01-12T17:48:13.388455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\handling-errors.md"}, "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "title": "Обработка ошибок", "chunk_index": 6, "header": "Установка пользовательских обработчиков исключений", "header_level": 2, "token_count": 443}
{"id": "2513429c7179a513", "text": "## Переопределение стандартных обработчиков исключений { #override-the-default-exception-handlers }\n\n**FastAPI** имеет некоторые обработчики исключений по умолчанию.\n\nЭти обработчики отвечают за возврат стандартных JSON-ответов при `вызове` `HTTPException` и при наличии в запросе недопустимых данных.\n\nВы можете переопределить эти обработчики исключений на свои собственные.\n\n", "metadata": {"title": "Обработка ошибок", "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "source_mtime": "2026-01-12T17:48:13.388455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\handling-errors.md"}, "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "title": "Обработка ошибок", "chunk_index": 7, "header": "Переопределение стандартных обработчиков исключений", "header_level": 2, "token_count": 139}
{"id": "66f4d86e703e9eab", "text": "### Переопределение обработчика исключений проверки запроса { #override-request-validation-exceptions }\n\nКогда запрос содержит недопустимые данные, **FastAPI** внутренне вызывает ошибку `RequestValidationError`.\n\nА также включает в себя обработчик исключений по умолчанию.\n\nЧтобы переопределить его, импортируйте `RequestValidationError` и используйте его с `@app.exception_handler(RequestValidationError)` для создания обработчика исключений.\n\nОбработчик исключения получит объект `Request` и исключение.\n\n{* ../../docs_src/handling_errors/tutorial004_py39.py hl[2,14:19] *}\n\nТеперь, если перейти к `/items/foo`, то вместо стандартной JSON-ошибки с:\n\n```JSON\n{\n    \"detail\": [\n        {\n            \"loc\": [\n                \"path\",\n                \"item_id\"\n            ],\n            \"msg\": \"value is not a valid integer\",\n            \"type\": \"type_error.integer\"\n        }\n    ]\n}\n```\n\nвы получите текстовую версию:\n\n```\nValidation errors:\nField: ('path', 'item_id'), Error: Input should be a valid integer, unable to parse string as an integer\n```\n\n", "metadata": {"title": "Обработка ошибок", "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "source_mtime": "2026-01-12T17:48:13.388455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\handling-errors.md"}, "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "title": "Обработка ошибок", "chunk_index": 8, "header": "Переопределение обработчика исключений проверки запроса", "header_level": 3, "token_count": 304}
{"id": "42207ca26198a37e", "text": "### Переопределите обработчик ошибок `HTTPException` { #override-the-httpexception-error-handler }\n\nАналогичным образом можно переопределить обработчик `HTTPException`.\n\nНапример, для этих ошибок можно вернуть обычный текстовый ответ вместо JSON:\n\n{* ../../docs_src/handling_errors/tutorial004_py39.py hl[3:4,9:11,25] *}\n\n/// note | Технические детали\n\nМожно также использовать `from starlette.responses import PlainTextResponse`.\n\n**FastAPI** предоставляет тот же `starlette.responses`, что и `fastapi.responses`, просто для удобства разработчика. Однако большинство доступных ответов поступает непосредственно из Starlette.\n\n///\n\n/// warning | Внимание\n\nИмейте в виду, что `RequestValidationError` содержит информацию об имени файла и строке, где произошла ошибка валидации, чтобы вы могли при желании отобразить её в логах с релевантными данными.\n\nНо это означает, что если вы просто преобразуете её в строку и вернёте эту информацию напрямую, вы можете допустить небольшую утечку информации о своей системе, поэтому здесь код извлекает и показывает каждую ошибку отдельно.\n\n///\n\n", "metadata": {"title": "Обработка ошибок", "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "source_mtime": "2026-01-12T17:48:13.388455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\handling-errors.md"}, "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "title": "Обработка ошибок", "chunk_index": 9, "header": "Переопределите обработчик ошибок `HTTPException`", "header_level": 3, "token_count": 378}
{"id": "94adf8487738b684", "text": "### Используйте тело `RequestValidationError` { #use-the-requestvalidationerror-body }\n\nОшибка `RequestValidationError` содержит полученное `тело` с недопустимыми данными.\n\nВы можете использовать его при разработке приложения для регистрации тела и его отладки, возврата пользователю и т.д.\n\n{* ../../docs_src/handling_errors/tutorial005_py39.py hl[14] *}\n\nТеперь попробуйте отправить недействительный элемент, например:\n\n```JSON\n{\n  \"title\": \"towel\",\n  \"size\": \"XL\"\n}\n```\n\nВы получите ответ о том, что данные недействительны, содержащий следующее тело:\n\n```JSON hl_lines=\"12-15\"\n{\n  \"detail\": [\n    {\n      \"loc\": [\n        \"body\",\n        \"size\"\n      ],\n      \"msg\": \"value is not a valid integer\",\n      \"type\": \"type_error.integer\"\n    }\n  ],\n  \"body\": {\n    \"title\": \"towel\",\n    \"size\": \"XL\"\n  }\n}\n```\n\n#### `HTTPException` в FastAPI или в Starlette { #fastapis-httpexception-vs-starlettes-httpexception }\n\n**FastAPI** имеет собственный `HTTPException`.\n\nКласс ошибок **FastAPI** `HTTPException` наследует от класса ошибок Starlette `HTTPException`.\n\nЕдинственное отличие состоит в том, что `HTTPException` в **FastAPI** принимает любые данные, пригодные для преобразования в JSON, в поле `detail`, тогда как `HTTPException` в Starlette принимает для него только строки.\n\nТаким образом, вы можете продолжать вызывать `HTTPException` от **FastAPI** как обычно в своем коде.\n\nНо когда вы регистрируете обработчик исключений, вы должны зарегистрировать его для `HTTPException` от Starlette.", "metadata": {"title": "Обработка ошибок", "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "source_mtime": "2026-01-12T17:48:13.388455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\handling-errors.md", "section_header": "Используйте тело `RequestValidationError`", "section_header_level": 3}, "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "title": "Обработка ошибок", "chunk_index": 10, "header": "Используйте тело `RequestValidationError`", "header_level": 3, "token_count": 479}
{"id": "a92e768a0ac33f07", "text": "вызывать `HTTPException` от **FastAPI** как обычно в своем коде.\n\nНо когда вы регистрируете обработчик исключений, вы должны зарегистрировать его для `HTTPException` от Starlette.\n\nТаким образом, если какая-либо часть внутреннего кодa Starlette, расширение или плагин Starlette вызовет исключение Starlette `HTTPException`, ваш обработчик сможет перехватить и обработать его.\n\nВ данном примере, чтобы иметь возможность использовать оба `HTTPException` в одном коде, исключения Starlette переименованы в `StarletteHTTPException`:\n\n```Python\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\n```", "metadata": {"title": "Обработка ошибок", "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "source_mtime": "2026-01-12T17:48:13.388455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\handling-errors.md", "section_header": "Используйте тело `RequestValidationError`", "section_header_level": 3}, "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "title": "Обработка ошибок", "chunk_index": 11, "header": "Используйте тело `RequestValidationError`", "header_level": 3, "token_count": 204}
{"id": "03598ff5f4eda439", "text": "### Переиспользование обработчиков исключений **FastAPI** { #reuse-fastapis-exception-handlers }\n\nЕсли вы хотите использовать исключение вместе с теми же обработчиками исключений по умолчанию из **FastAPI**, вы можете импортировать и повторно использовать обработчики исключений по умолчанию из `fastapi.exception_handlers`:\n\n{* ../../docs_src/handling_errors/tutorial006_py39.py hl[2:5,15,21] *}\n\nВ этом примере вы просто `выводите в терминал` ошибку с очень выразительным сообщением, но идея вам понятна. Вы можете использовать исключение, а затем просто повторно использовать стандартные обработчики исключений.\n", "metadata": {"title": "Обработка ошибок", "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "source_mtime": "2026-01-12T17:48:13.388455+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\handling-errors.md"}, "doc_id": "c1abfcab2a0a", "source_path": "docs\\tutorial\\handling-errors.md", "title": "Обработка ошибок", "chunk_index": 12, "header": "Переиспользование обработчиков исключений **FastAPI**", "header_level": 3, "token_count": 218}
{"id": "0ece5825fb3f99c1", "text": "# Модели Header-параметров { #header-parameter-models }\n\nЕсли у вас есть группа связанных **header-параметров**, то вы можете объединить их в одну **Pydantic-модель**.\n\nЭто позволит вам **переиспользовать модель** в **разных местах**, а также задать валидацию и метаданные сразу для всех параметров. \n\n/// note | Заметка\n\nЭтот функционал доступен в FastAPI начиная с версии `0.115.0`. \n\n///\n\n", "metadata": {"title": "Модели Header-параметров", "doc_id": "7624b0eb3351", "source_path": "docs\\tutorial\\header-param-models.md", "source_mtime": "2026-01-12T17:48:13.396506+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\header-param-models.md"}, "doc_id": "7624b0eb3351", "source_path": "docs\\tutorial\\header-param-models.md", "title": "Модели Header-параметров", "chunk_index": 0, "header": "Модели Header-параметров", "header_level": 1, "token_count": 148}
{"id": "8cdbcf0c7afb872b", "text": "## Header-параметры в виде Pydantic-модели { #header-parameters-with-a-pydantic-model }\n\nОбъявите нужные **header-параметры** в **Pydantic-модели** и затем аннотируйте параметр как `Header`:\n\n{* ../../docs_src/header_param_models/tutorial001_an_py310.py hl[9:14,18] *}\n\n**FastAPI** **извлечёт** данные для **каждого поля** из **заголовков** запроса и выдаст заданную вами Pydantic-модель.\n\n", "metadata": {"title": "Модели Header-параметров", "doc_id": "7624b0eb3351", "source_path": "docs\\tutorial\\header-param-models.md", "source_mtime": "2026-01-12T17:48:13.396506+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\header-param-models.md"}, "doc_id": "7624b0eb3351", "source_path": "docs\\tutorial\\header-param-models.md", "title": "Модели Header-параметров", "chunk_index": 1, "header": "Header-параметры в виде Pydantic-модели", "header_level": 2, "token_count": 139}
{"id": "d1ecb318a2702de5", "text": "## Проверьте документацию { #check-the-docs }\n\nВы можете посмотреть нужные header-параметры в графическом интерфейсе сгенерированной документации по пути `/docs`:\n\n<div class=\"screenshot\">\n<img src=\"/img/tutorial/header-param-models/image01.png\">\n</div>\n\n", "metadata": {"title": "Модели Header-параметров", "doc_id": "7624b0eb3351", "source_path": "docs\\tutorial\\header-param-models.md", "source_mtime": "2026-01-12T17:48:13.396506+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\header-param-models.md"}, "doc_id": "7624b0eb3351", "source_path": "docs\\tutorial\\header-param-models.md", "title": "Модели Header-параметров", "chunk_index": 2, "header": "Проверьте документацию", "header_level": 2, "token_count": 83}
{"id": "5133ee8b3e63990a", "text": "## Как запретить дополнительные заголовки { #forbid-extra-headers }\n\nВ некоторых случаях (не особо часто встречающихся) вам может понадобиться **ограничить** заголовки, которые вы хотите получать.\n\nВы можете использовать возможности конфигурации Pydantic-модели для того, чтобы запретить (`forbid`) любые дополнительные (`extra`) поля:\n\n{* ../../docs_src/header_param_models/tutorial002_an_py310.py hl[10] *}\n\nЕсли клиент попробует отправить **дополнительные заголовки**, то в ответ он получит **ошибку**.\n\nНапример, если клиент попытается отправить заголовок `tool` со значением `plumbus`, то в ответ он получит ошибку, сообщающую ему, что header-параметр `tool` не разрешен:\n\n```json\n{\n    \"detail\": [\n        {\n            \"type\": \"extra_forbidden\",\n            \"loc\": [\"header\", \"tool\"],\n            \"msg\": \"Extra inputs are not permitted\",\n            \"input\": \"plumbus\",\n        }\n    ]\n}\n```\n\n", "metadata": {"title": "Модели Header-параметров", "doc_id": "7624b0eb3351", "source_path": "docs\\tutorial\\header-param-models.md", "source_mtime": "2026-01-12T17:48:13.396506+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\header-param-models.md"}, "doc_id": "7624b0eb3351", "source_path": "docs\\tutorial\\header-param-models.md", "title": "Модели Header-параметров", "chunk_index": 3, "header": "Как запретить дополнительные заголовки", "header_level": 2, "token_count": 293}
{"id": "d201055634304055", "text": "## Как отключить автоматическое преобразование подчеркиваний { #disable-convert-underscores }\n\nКак и в случае с обычными заголовками, если у вас в именах параметров имеются символы подчеркивания, они **автоматически преобразовываются в дефис**.\n\nНапример, если в коде есть header-параметр `save_data`, то ожидаемый HTTP-заголовок будет `save-data` и именно так он будет отображаться в документации.\n\nЕсли по каким-то причинам вам нужно отключить данное автоматическое преобразование, это можно сделать и для Pydantic-моделей для header-параметров.\n\n{* ../../docs_src/header_param_models/tutorial003_an_py310.py hl[19] *}\n\n/// warning | Внимание\n\nПеред тем как устанавливать для параметра `convert_underscores` значение `False`, имейте в виду, что некоторые HTTP-прокси и серверы не разрешают использовать заголовки с символами подчеркивания.\n\n///\n\n", "metadata": {"title": "Модели Header-параметров", "doc_id": "7624b0eb3351", "source_path": "docs\\tutorial\\header-param-models.md", "source_mtime": "2026-01-12T17:48:13.396506+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\header-param-models.md"}, "doc_id": "7624b0eb3351", "source_path": "docs\\tutorial\\header-param-models.md", "title": "Модели Header-параметров", "chunk_index": 4, "header": "Как отключить автоматическое преобразование подчеркиваний", "header_level": 2, "token_count": 302}
{"id": "704750e05a91ca7e", "text": "## Резюме { #summary }\n\nВы можете использовать **Pydantic-модели** для объявления **header-параметров** в **FastAPI**.\n", "metadata": {"title": "Модели Header-параметров", "doc_id": "7624b0eb3351", "source_path": "docs\\tutorial\\header-param-models.md", "source_mtime": "2026-01-12T17:48:13.396506+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\header-param-models.md"}, "doc_id": "7624b0eb3351", "source_path": "docs\\tutorial\\header-param-models.md", "title": "Модели Header-параметров", "chunk_index": 5, "header": "Резюме", "header_level": 2, "token_count": 42}
{"id": "89438caf51092114", "text": "# Header-параметры { #header-parameters }\n\nВы можете определить параметры заголовка таким же образом, как вы определяете параметры `Query`, `Path` и `Cookie`.\n\n", "metadata": {"title": "Header-параметры", "doc_id": "fc7def5a1f11", "source_path": "docs\\tutorial\\header-params.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\header-params.md"}, "doc_id": "fc7def5a1f11", "source_path": "docs\\tutorial\\header-params.md", "title": "Header-параметры", "chunk_index": 0, "header": "Header-параметры", "header_level": 1, "token_count": 50}
{"id": "f79f3bcc9443b7f9", "text": "## Импорт `Header` { #import-header }\n\nСперва импортируйте `Header`:\n\n{* ../../docs_src/header_params/tutorial001_an_py310.py hl[3] *}\n\n", "metadata": {"title": "Header-параметры", "doc_id": "fc7def5a1f11", "source_path": "docs\\tutorial\\header-params.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\header-params.md"}, "doc_id": "fc7def5a1f11", "source_path": "docs\\tutorial\\header-params.md", "title": "Header-параметры", "chunk_index": 1, "header": "Импорт `Header`", "header_level": 2, "token_count": 46}
{"id": "71f241cc65370b03", "text": "## Объявление параметров `Header` { #declare-header-parameters }\n\nЗатем объявите параметры заголовка, используя ту же структуру, что и с `Path`, `Query` и `Cookie`.\n\nПервое значение является значением по умолчанию, вы можете передать все дополнительные параметры валидации или аннотации:\n\n{* ../../docs_src/header_params/tutorial001_an_py310.py hl[9] *}\n\n/// note | Технические детали\n\n`Header` - это \"родственный\" класс `Path`, `Query` и `Cookie`. Он также наследуется от того же общего класса `Param`.\n\nНо помните, что когда вы импортируете `Query`, `Path`, `Header` и другие из `fastapi`, на самом деле это функции, которые возвращают специальные классы.\n\n///\n\n/// info | Информация\n\nЧтобы объявить заголовки, важно использовать `Header`, иначе параметры интерпретируются как query-параметры.\n\n///\n\n", "metadata": {"title": "Header-параметры", "doc_id": "fc7def5a1f11", "source_path": "docs\\tutorial\\header-params.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\header-params.md"}, "doc_id": "fc7def5a1f11", "source_path": "docs\\tutorial\\header-params.md", "title": "Header-параметры", "chunk_index": 2, "header": "Объявление параметров `Header`", "header_level": 2, "token_count": 281}
{"id": "8bb2603150cdad9a", "text": "## Автоматическое преобразование { #automatic-conversion }\n\n`Header` обладает небольшой дополнительной функциональностью в дополнение к тому, что предоставляют `Path`, `Query` и `Cookie`.\n\nБольшинство стандартных заголовков разделены символом \"дефис\", также известным как \"минус\" (`-`).\n\nНо переменная вроде `user-agent` недопустима в Python.\n\nПо умолчанию `Header` преобразует символы имен параметров из символа подчеркивания (`_`) в дефис (`-`) для извлечения и документирования заголовков.\n\nКроме того, HTTP-заголовки не чувствительны к регистру, поэтому вы можете объявить их в стандартном стиле Python (также известном как \"snake_case\").\n\nТаким образом вы можете использовать `user_agent`, как обычно, в коде Python, вместо того, чтобы вводить заглавные буквы как `User_Agent` или что-то подобное.\n\nЕсли по какой-либо причине вам необходимо отключить автоматическое преобразование подчеркиваний в дефисы, установите для параметра `convert_underscores` в `Header` значение `False`:\n\n{* ../../docs_src/header_params/tutorial002_an_py310.py hl[10] *}\n\n/// warning | Внимание\n\nПрежде чем установить для `convert_underscores` значение `False`, имейте в виду, что некоторые HTTP-прокси и серверы запрещают использование заголовков с подчеркиванием.\n\n///\n\n", "metadata": {"title": "Header-параметры", "doc_id": "fc7def5a1f11", "source_path": "docs\\tutorial\\header-params.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\header-params.md"}, "doc_id": "fc7def5a1f11", "source_path": "docs\\tutorial\\header-params.md", "title": "Header-параметры", "chunk_index": 3, "header": "Автоматическое преобразование", "header_level": 2, "token_count": 458}
{"id": "a8d551d1eb91a3dc", "text": "## Повторяющиеся заголовки { #duplicate-headers }\n\nЕсть возможность получать несколько заголовков с одним и тем же именем, но разными значениями.\n\nВы можете определить эти случаи, используя список в объявлении типа.\n\nВы получите все значения из повторяющегося заголовка в виде `list` Python.\n\nНапример, чтобы объявить заголовок `X-Token`, который может появляться более одного раза, вы можете написать:\n\n{* ../../docs_src/header_params/tutorial003_an_py310.py hl[9] *}\n\nЕсли вы взаимодействуете с этой *операцией пути*, отправляя два HTTP-заголовка, таких как:\n\n```\nX-Token: foo\nX-Token: bar\n```\n\nОтвет был бы таким:\n\n```JSON\n{\n    \"X-Token values\": [\n        \"bar\",\n        \"foo\"\n    ]\n}\n```\n\n", "metadata": {"title": "Header-параметры", "doc_id": "fc7def5a1f11", "source_path": "docs\\tutorial\\header-params.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\header-params.md"}, "doc_id": "fc7def5a1f11", "source_path": "docs\\tutorial\\header-params.md", "title": "Header-параметры", "chunk_index": 4, "header": "Повторяющиеся заголовки", "header_level": 2, "token_count": 241}
{"id": "2cc379fe79f2677a", "text": "## Резюме { #recap }\n\nОбъявляйте заголовки с помощью `Header`, используя тот же общий шаблон, как при `Query`, `Path` и `Cookie`.\n\nИ не беспокойтесь о символах подчеркивания в ваших переменных, **FastAPI** позаботится об их преобразовании.\n", "metadata": {"title": "Header-параметры", "doc_id": "fc7def5a1f11", "source_path": "docs\\tutorial\\header-params.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\header-params.md"}, "doc_id": "fc7def5a1f11", "source_path": "docs\\tutorial\\header-params.md", "title": "Header-параметры", "chunk_index": 5, "header": "Резюме", "header_level": 2, "token_count": 103}
{"id": "3337f74e665097e7", "text": "# Учебник - Руководство пользователя { #tutorial-user-guide }\n\nВ этом руководстве шаг за шагом показано, как использовать **FastAPI** с большинством его функций.\n\nКаждый раздел постепенно основывается на предыдущих, но структура разделяет темы, так что вы можете сразу перейти к нужной теме для решения ваших конкретных задач по API.\n\nОн также создан как справочник на будущее, чтобы вы могли вернуться и посмотреть именно то, что вам нужно.\n\n", "metadata": {"title": "Учебник - Руководство пользователя", "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\index.md"}, "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "title": "Учебник - Руководство пользователя", "chunk_index": 0, "header": "Учебник - Руководство пользователя", "header_level": 1, "token_count": 168}
{"id": "3337f74e665097e7", "text": "## Запустите код { #run-the-code }\n\nВсе блоки кода можно копировать и использовать напрямую (это действительно протестированные файлы Python).\n\nЧтобы запустить любой из примеров, скопируйте код в файл `main.py` и запустите `fastapi dev` с:\n\n<div class=\"termy\">\n\n```console\n$ <font color=\"#4E9A06\">fastapi</font> dev <u style=\"text-decoration-style:solid\">main.py</u>\n\n  <span style=\"background-color:#009485\"><font color=\"#D3D7CF\"> FastAPI </font></span>  Starting development server 🚀\n\n             Searching for package file structure from directories\n             with <font color=\"#3465A4\">__init__.py</font> files\n             Importing from <font color=\"#75507B\">/home/user/code/</font><font color=\"#AD7FA8\">awesomeapp</font>\n\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> module </font></span>  🐍 main.py\n\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> code </font></span>  Importing the FastAPI app object from the module with\n             the following code:\n\n             <u style=\"text-decoration-style:solid\">from </u><u style=\"text-decoration-style:solid\"><b>main</b></u><u style=\"text-decoration-style:solid\"> import </u><u style=\"text-decoration-style:solid\"><b>app</b></u>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> app </font></span>  Using import string: <font color=\"#3465A4\">main:app</font>", "metadata": {"title": "Учебник - Руководство пользователя", "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\index.md", "section_header": "Запустите код", "section_header_level": 2}, "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "title": "Учебник - Руководство пользователя", "chunk_index": 1, "header": "Запустите код", "header_level": 2, "token_count": 411}
{"id": "bb82a8b360db3ebf", "text": "><u style=\"text-decoration-style:solid\"><b>app</b></u>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> app </font></span>  Using import string: <font color=\"#3465A4\">main:app</font>\n\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Server started at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://127.0.0.1:8000</u></font>\n   <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Documentation at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://127.0.0.1:8000/docs</u></font>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> tip </font></span>  Running in development mode, for production use:\n             <b>fastapi run</b>\n\n             Logs:", "metadata": {"title": "Учебник - Руководство пользователя", "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\index.md", "section_header": "Запустите код", "section_header_level": 2}, "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "title": "Учебник - Руководство пользователя", "chunk_index": 2, "header": "Запустите код", "header_level": 2, "token_count": 241}
{"id": "76c1522f4be721c5", "text": ".0.0.1:8000/docs</u></font>\n\n      <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> tip </font></span>  Running in development mode, for production use:\n             <b>fastapi run</b>\n\n             Logs:\n\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Will watch for changes in these directories:\n             <b>[</b><font color=\"#4E9A06\">&apos;/home/user/code/awesomeapp&apos;</font><b>]</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Uvicorn running on <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://127.0.0.1:8000</u></font> <b>(</b>Press CTRL+C\n             to quit<b>)</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started reloader process <b>[</b><font color=\"#34E2E2\"><b>383138</b></font><b>]</b> using WatchFiles\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started server process <b>[</b><font color=\"#34E2E2\"><b>383153</b></font><b>]</b>\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Waiting for application startup.\n     <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Application startup complete.\n```\n\n</div>\n\n**НАСТОЯТЕЛЬНО рекомендуется** написать или скопировать код, отредактировать его и запустить локально.", "metadata": {"title": "Учебник - Руководство пользователя", "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\index.md", "section_header": "Запустите код", "section_header_level": 2}, "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "title": "Учебник - Руководство пользователя", "chunk_index": 3, "header": "Запустите код", "header_level": 2, "token_count": 454}
{"id": "afc8e7bc7ff98987", "text": "\"> INFO </font></span>  Application startup complete.\n```\n\n</div>\n\n**НАСТОЯТЕЛЬНО рекомендуется** написать или скопировать код, отредактировать его и запустить локально.\n\nИспользование кода в вашем редакторе кода — это то, что действительно показывает преимущества FastAPI: вы увидите, как мало кода нужно написать, все проверки типов, автозавершение и т.д.\n\n---", "metadata": {"title": "Учебник - Руководство пользователя", "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\index.md", "section_header": "Запустите код", "section_header_level": 2}, "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "title": "Учебник - Руководство пользователя", "chunk_index": 4, "header": "Запустите код", "header_level": 2, "token_count": 137}
{"id": "557930387b9371bf", "text": "## Установка FastAPI { #install-fastapi }\n\nПервый шаг — установить FastAPI.\n\nУбедитесь, что вы создали [виртуальное окружение](../virtual-environments.md){.internal-link target=_blank}, активировали его, и затем **установите FastAPI**:\n\n<div class=\"termy\">\n\n```console\n$ pip install \"fastapi[standard]\"\n\n---> 100%\n```\n\n</div>\n\n/// note | Примечание\n\nПри установке с помощью `pip install \"fastapi[standard]\"` добавляются некоторые стандартные необязательные зависимости по умолчанию, включая `fastapi-cloud-cli`, который позволяет развернуть приложение на <a href=\"https://fastapicloud.com\" class=\"external-link\" target=\"_blank\">FastAPI Cloud</a>.\n\nЕсли вы не хотите иметь эти необязательные зависимости, установите просто `pip install fastapi`.\n\nЕсли вы хотите установить стандартные зависимости, но без `fastapi-cloud-cli`, установите `pip install \"fastapi[standard-no-fastapi-cloud-cli]\"`.\n\n///\n\n", "metadata": {"title": "Учебник - Руководство пользователя", "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\index.md"}, "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "title": "Учебник - Руководство пользователя", "chunk_index": 5, "header": "Установка FastAPI", "header_level": 2, "token_count": 289}
{"id": "1506183bb71b70b2", "text": "## Продвинутое руководство пользователя { #advanced-user-guide }\n\nСуществует также **Продвинутое руководство пользователя**, которое вы сможете прочитать после **Учебник - Руководство пользователя**.\n\n**Продвинутое руководство пользователя** основано на этом, использует те же концепции и обучает некоторым дополнительным функциям.\n\nНо сначала вам следует прочитать **Учебник - Руководство пользователя** (то, что вы читаете прямо сейчас).\n\nОно спроектировано так, что вы можете создать полноценное приложение, используя только **Учебник - Руководство пользователя**, а затем расширить его различными способами, в зависимости от ваших потребностей, используя дополнительные идеи из **Продвинутого руководства пользователя**.\n", "metadata": {"title": "Учебник - Руководство пользователя", "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\index.md"}, "doc_id": "246d2269460b", "source_path": "docs\\tutorial\\index.md", "title": "Учебник - Руководство пользователя", "chunk_index": 6, "header": "Продвинутое руководство пользователя", "header_level": 2, "token_count": 274}
{"id": "6bad2386b0044a19", "text": "# URL-адреса метаданных и документации { #metadata-and-docs-urls }\n\nВы можете настроить несколько конфигураций метаданных в вашем **FastAPI** приложении.\n\n", "metadata": {"title": "URL-адреса метаданных и документации", "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\metadata.md"}, "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "title": "URL-адреса метаданных и документации", "chunk_index": 0, "header": "URL-адреса метаданных и документации", "header_level": 1, "token_count": 58}
{"id": "6bad2386b0044a19", "text": "## Метаданные для API { #metadata-for-api }\n\nВы можете задать следующие поля, которые используются в спецификации OpenAPI и в UI автоматической документации API:", "metadata": {"title": "URL-адреса метаданных и документации", "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\metadata.md", "section_header": "Метаданные для API", "section_header_level": 2}, "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "title": "URL-адреса метаданных и документации", "chunk_index": 1, "header": "Метаданные для API", "header_level": 2, "token_count": 53}
{"id": "2e0e6b081d57c785", "text": "## Метаданные для API { #metadata-for-api }\n\nВы можете задать следующие поля, которые используются в спецификации OpenAPI и в UI автоматической документации API:\n\n| Параметр | Тип | Описание |\n|------------|------|-------------|\n| `title` | `str` | Заголовок API. |\n| `summary` | `str` | Краткое резюме API. <small>Доступно начиная с OpenAPI 3.1.0, FastAPI 0.99.0.</small> |\n| `description` | `str` | Краткое описание API. Может быть использован Markdown. |\n| `version` | `string` | Версия API. Версия вашего собственного приложения, а не OpenAPI. К примеру `2.5.0`. |\n| `terms_of_service` | `str` | Ссылка к условиям пользования API. Если указано, то это должен быть URL-адрес. |\n| `contact` | `dict` | Контактная информация для открытого API. Может содержать несколько полей. <details><summary>поля <code>contact</code></summary><table><thead><tr><th>Параметр</th><th>Тип</th><th>Описание</th></tr></thead><tbody><tr><td><code>name</code></td><td><code>str</code></td><td>Идентификационное имя контактного лица/организации.</td></tr><tr><td><code>url</code></td><td><code>str</code></td><td>URL указывающий на контактную информацию. ДОЛЖЕН быть в формате URL.</td></tr><tr><td><code>email</code></td><td><code>str</code></td><td>Email адрес контактного лица/организации. ДОЛЖЕН быть в формате email адреса.</td></tr></tbody></table></details> |\n| `license_info` | `dict` | Информация о лицензии открытого API. Может содержать несколько полей. <details><summary>поля <code>license_info</code></summary><table><thead><tr><th>Параметр</th><th>Тип</th><th>Описание</th></tr></thead><tbody><tr><td><code>name</code></td><td><code>str</code></td><td><strong>ОБЯЗАТЕЛЬНО</strong> (если установлен параметр <code>license_info</code>). Название лицензии, используемой для API.</td></tr><tr><td><code>identifier</code></td><td><code>str</code></td><td>Выражение лицензии <a href=\"https://spdx.org/licenses/\" class=\"external-link\" target=\"_blank\">SPDX</a> для API. Поле <code>identifier</code> взаимоисключающее с полем <code>url</code>. <small>Доступно начиная с OpenAPI 3.1.0, FastAPI 0.99.0.</small></td></tr><tr><td><code>url</code></td><td><code>str</code></td><td>URL, указывающий на лицензию, используемую для API. ДОЛЖЕН быть в формате URL.</td></tr></tbody></table></details> |", "metadata": {"title": "URL-адреса метаданных и документации", "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\metadata.md", "section_header": "Метаданные для API", "section_header_level": 2}, "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "title": "URL-адреса метаданных и документации", "chunk_index": 2, "header": "Метаданные для API", "header_level": 2, "token_count": 870}
{"id": "85b5581fdb2167cc", "text": "</code></td><td><code>str</code></td><td>URL, указывающий на лицензию, используемую для API. ДОЛЖЕН быть в формате URL.</td></tr></tbody></table></details> |\n\nВы можете задать их следующим образом:\n\n{* ../../docs_src/metadata/tutorial001_py39.py hl[3:16, 19:32] *}\n\n/// tip | Подсказка\n\nВы можете использовать Markdown в поле `description`, и оно будет отображено в выводе.\n\n///\n\nС этой конфигурацией автоматическая документация API будет выглядеть так:\n\n<img src=\"/img/tutorial/metadata/image01.png\">", "metadata": {"title": "URL-адреса метаданных и документации", "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\metadata.md", "section_header": "Метаданные для API", "section_header_level": 2}, "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "title": "URL-адреса метаданных и документации", "chunk_index": 3, "header": "Метаданные для API", "header_level": 2, "token_count": 174}
{"id": "cfc9cb963468d6b3", "text": "## Идентификатор лицензии { #license-identifier }\n\nНачиная с OpenAPI 3.1.0 и FastAPI 0.99.0, вы также можете задать `license_info` с помощью `identifier` вместо `url`.\n\nК примеру:\n\n{* ../../docs_src/metadata/tutorial001_1_py39.py hl[31] *}\n\n", "metadata": {"title": "URL-адреса метаданных и документации", "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\metadata.md"}, "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "title": "URL-адреса метаданных и документации", "chunk_index": 4, "header": "Идентификатор лицензии", "header_level": 2, "token_count": 89}
{"id": "1ed462f64ed842dc", "text": "## Метаданные для тегов { #metadata-for-tags }\n\nВы также можете добавить дополнительные метаданные для различных тегов, используемых для группировки ваших операций пути с помощью параметра `openapi_tags`.\n\nОн принимает список, содержащий один словарь для каждого тега.\n\nКаждый словарь может содержать в себе:\n\n* `name` (**обязательно**): `str`-значение с тем же именем тега, которое вы используете в параметре `tags` в ваших *операциях пути* и `APIRouter`ах.\n* `description`: `str`-значение с кратким описанием для тега. Может содержать Markdown и будет отображаться в UI документации.\n* `externalDocs`:  `dict`-значение описывающее внешнюю документацию. Включает в себя:\n    * `description`: `str`-значение с кратким описанием для внешней документации.\n    * `url` (**обязательно**): `str`-значение с URL-адресом для внешней документации.\n\n", "metadata": {"title": "URL-адреса метаданных и документации", "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\metadata.md"}, "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "title": "URL-адреса метаданных и документации", "chunk_index": 5, "header": "Метаданные для тегов", "header_level": 2, "token_count": 321}
{"id": "5153b2ae958a4c20", "text": "### Создание метаданных для тегов { #create-metadata-for-tags }\n\nДавайте попробуем сделать это на примере с тегами для `users` и `items`.\n\nСоздайте метаданные для ваших тегов и передайте их в параметре `openapi_tags`:\n\n{* ../../docs_src/metadata/tutorial004_py39.py hl[3:16,18] *}\n\nПомните, что вы можете использовать Markdown внутри описания, к примеру \"login\" будет отображен жирным шрифтом (**login**) и \"fancy\" будет отображаться курсивом (_fancy_).\n\n/// tip | Подсказка\n\nВам необязательно добавлять метаданные для всех используемых тегов\n\n///\n\n", "metadata": {"title": "URL-адреса метаданных и документации", "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\metadata.md"}, "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "title": "URL-адреса метаданных и документации", "chunk_index": 6, "header": "Создание метаданных для тегов", "header_level": 3, "token_count": 197}
{"id": "1b1fd75921716229", "text": "### Используйте собственные теги { #use-your-tags }\n\nИспользуйте параметр `tags` с вашими *операциями пути* (и `APIRouter`ами), чтобы присвоить им различные теги:\n\n{* ../../docs_src/metadata/tutorial004_py39.py hl[21,26] *}\n\n/// info | Дополнительная информация\n\nУзнайте больше о тегах в [Конфигурации операции пути](path-operation-configuration.md#tags){.internal-link target=_blank}.\n\n///\n\n", "metadata": {"title": "URL-адреса метаданных и документации", "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\metadata.md"}, "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "title": "URL-адреса метаданных и документации", "chunk_index": 7, "header": "Используйте собственные теги", "header_level": 3, "token_count": 138}
{"id": "8ea46ddd341d8c9c", "text": "### Проверьте документацию { #check-the-docs }\n\nТеперь, если вы проверите документацию, вы увидите всю дополнительную информацию:\n\n<img src=\"/img/tutorial/metadata/image02.png\">\n\n", "metadata": {"title": "URL-адреса метаданных и документации", "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\metadata.md"}, "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "title": "URL-адреса метаданных и документации", "chunk_index": 8, "header": "Проверьте документацию", "header_level": 3, "token_count": 57}
{"id": "f24ac636fef59d9c", "text": "### Порядок расположения тегов { #order-of-tags }\n\nПорядок расположения словарей метаданных для каждого тега определяет также порядок, отображаемый в UI документации.\n\nК примеру, несмотря на то, что `users` будут идти после `items` в алфавитном порядке, они отображаются раньше, потому что мы добавляем свои метаданные в качестве первого словаря в списке.\n\n", "metadata": {"title": "URL-адреса метаданных и документации", "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\metadata.md"}, "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "title": "URL-адреса метаданных и документации", "chunk_index": 9, "header": "Порядок расположения тегов", "header_level": 3, "token_count": 139}
{"id": "2412fd5559392886", "text": "## URL-адрес OpenAPI { #openapi-url }\n\nПо умолчанию схема OpenAPI отображена по адресу `/openapi.json`.\n\nНо вы можете изменить это с помощью параметра `openapi_url`.\n\nК примеру, чтобы задать её отображение по адресу `/api/v1/openapi.json`:\n\n{* ../../docs_src/metadata/tutorial002_py39.py hl[3] *}\n\nЕсли вы хотите отключить схему OpenAPI полностью, вы можете задать `openapi_url=None`, это также отключит пользовательские интерфейсы документации, которые её используют.\n\n", "metadata": {"title": "URL-адреса метаданных и документации", "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\metadata.md"}, "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "title": "URL-адреса метаданных и документации", "chunk_index": 10, "header": "URL-адрес OpenAPI", "header_level": 2, "token_count": 154}
{"id": "9867fd57175a4eee", "text": "## URL-адреса документации { #docs-urls }\n\nВы можете изменить конфигурацию двух пользовательских интерфейсов документации, которые включены:\n\n* **Swagger UI**: отображаемый по адресу `/docs`.\n    * Вы можете задать его URL с помощью параметра `docs_url`.\n    * Вы можете отключить это с помощью настройки `docs_url=None`.\n* **ReDoc**: отображаемый по адресу `/redoc`.\n    * Вы можете задать его URL с помощью параметра `redoc_url`.\n    * Вы можете отключить это с помощью настройки `redoc_url=None`.\n\nК примеру, чтобы задать отображение Swagger UI по адресу `/documentation` и отключить ReDoc:\n\n{* ../../docs_src/metadata/tutorial003_py39.py hl[3] *}\n", "metadata": {"title": "URL-адреса метаданных и документации", "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "source_mtime": "2026-01-12T17:48:13.404590+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\metadata.md"}, "doc_id": "a29184ecbf14", "source_path": "docs\\tutorial\\metadata.md", "title": "URL-адреса метаданных и документации", "chunk_index": 11, "header": "URL-адреса документации", "header_level": 2, "token_count": 206}
{"id": "4a6e3ca9b7af8955", "text": "# Middleware (Промежуточный слой) { #middleware }\n\nВы можете добавить промежуточный слой (middleware) в **FastAPI** приложение.\n\n\"Middleware\" это функция, которая выполняется с каждым запросом до его обработки какой-либо конкретной *операцией пути*.\nА также с каждым ответом перед его возвращением.\n\n* Она принимает каждый поступающий **запрос**.\n* Может что-то сделать с этим **запросом** или выполнить любой нужный код.\n* Затем передает **запрос** для последующей обработки (какой-либо *операцией пути*).\n* Получает **ответ** (от *операции пути*).\n* Может что-то сделать с этим **ответом** или выполнить любой нужный код.\n* И возвращает **ответ**.\n\n/// note | Технические детали\n\nЕсли у вас есть зависимости с `yield`, то код выхода (код после `yield`) будет выполняться *после* middleware.\n\nЕсли были какие‑либо фоновые задачи (рассматриваются в разделе [Фоновые задачи](background-tasks.md){.internal-link target=_blank}, вы увидите это позже), они будут запущены *после* всех middleware.\n\n///\n\n", "metadata": {"title": "Middleware (Промежуточный слой)", "doc_id": "424aaa2ee9ea", "source_path": "docs\\tutorial\\middleware.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\middleware.md"}, "doc_id": "424aaa2ee9ea", "source_path": "docs\\tutorial\\middleware.md", "title": "Middleware (Промежуточный слой)", "chunk_index": 0, "header": "Middleware (Промежуточный слой)", "header_level": 1, "token_count": 379}
{"id": "33678e79209e0d69", "text": "## Создание middleware { #create-a-middleware }\n\nДля создания middleware используйте декоратор `@app.middleware(\"http\")`.\n\nФункция middleware получает:\n\n* `request` (объект запроса).\n* Функцию `call_next`, которая получает `request` в качестве параметра.\n    * Эта функция передаёт `request` соответствующей *операции пути*.\n    * Затем она возвращает ответ `response`, сгенерированный *операцией пути*.\n* Также имеется возможность видоизменить `response`, перед тем как его вернуть.\n\n{* ../../docs_src/middleware/tutorial001_py39.py hl[8:9,11,14] *}\n\n/// tip | Примечание\n\nИмейте в виду, что можно добавлять свои собственные заголовки <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers\" class=\"external-link\" target=\"_blank\">при помощи префикса 'X-'</a>.\n\nЕсли же вы хотите добавить собственные заголовки, которые клиент сможет увидеть в браузере, то вам потребуется добавить их в настройки CORS ([CORS (Cross-Origin Resource Sharing)](cors.md){.internal-link target=_blank}), используя параметр `expose_headers`, см. документацию <a href=\"https://www.starlette.dev/middleware/#corsmiddleware\" class=\"external-link\" target=\"_blank\">Starlette's CORS docs</a>.\n\n///\n\n/// note | Технические детали\n\nВы также можете использовать `from starlette.requests import Request`.\n\n**FastAPI** предоставляет такой доступ для удобства разработчиков. Но, на самом деле, это `Request` из Starlette.\n\n///\n\n", "metadata": {"title": "Middleware (Промежуточный слой)", "doc_id": "424aaa2ee9ea", "source_path": "docs\\tutorial\\middleware.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\middleware.md"}, "doc_id": "424aaa2ee9ea", "source_path": "docs\\tutorial\\middleware.md", "title": "Middleware (Промежуточный слой)", "chunk_index": 1, "header": "Создание middleware", "header_level": 2, "token_count": 452}
{"id": "663eaa91620fba02", "text": "### До и после `response` { #before-and-after-the-response }\n\nВы можете добавить код, использующий `request` до передачи его какой-либо *операции пути*.\n\nА также после формирования `response`, до того, как вы его вернёте.\n\nНапример, вы можете добавить собственный заголовок `X-Process-Time`, содержащий время в секундах, необходимое для обработки запроса и генерации ответа:\n\n{* ../../docs_src/middleware/tutorial001_py39.py hl[10,12:13] *}\n\n/// tip | Примечание\n\nМы используем <a href=\"https://docs.python.org/3/library/time.html#time.perf_counter\" class=\"external-link\" target=\"_blank\">`time.perf_counter()`</a> вместо `time.time()` для обеспечения большей точности наших примеров. \n\n///\n\n", "metadata": {"title": "Middleware (Промежуточный слой)", "doc_id": "424aaa2ee9ea", "source_path": "docs\\tutorial\\middleware.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\middleware.md"}, "doc_id": "424aaa2ee9ea", "source_path": "docs\\tutorial\\middleware.md", "title": "Middleware (Промежуточный слой)", "chunk_index": 2, "header": "До и после `response`", "header_level": 3, "token_count": 225}
{"id": "315a183ae9bb6cce", "text": "## Порядок выполнения нескольких middleware { #multiple-middleware-execution-order }\n\nКогда вы добавляете несколько middleware с помощью декоратора `@app.middleware()` или метода `app.add_middleware()`, каждое новое middleware оборачивает приложение, формируя стек. Последнее добавленное middleware — самое внешнее (*outermost*), а первое — самое внутреннее (*innermost*).\n\nНа пути обработки запроса сначала выполняется самое внешнее middleware.\n\nНа пути формирования ответа оно выполняется последним.\n\nНапример:\n\n```Python\napp.add_middleware(MiddlewareA)\napp.add_middleware(MiddlewareB)\n```\n\nЭто приводит к следующему порядку выполнения:\n\n* **Запрос**: MiddlewareB → MiddlewareA → маршрут\n\n* **Ответ**: маршрут → MiddlewareA → MiddlewareB\n\nТакое стековое поведение обеспечивает предсказуемый и управляемый порядок выполнения middleware.\n\n", "metadata": {"title": "Middleware (Промежуточный слой)", "doc_id": "424aaa2ee9ea", "source_path": "docs\\tutorial\\middleware.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\middleware.md"}, "doc_id": "424aaa2ee9ea", "source_path": "docs\\tutorial\\middleware.md", "title": "Middleware (Промежуточный слой)", "chunk_index": 3, "header": "Порядок выполнения нескольких middleware", "header_level": 2, "token_count": 276}
{"id": "a4e0841c4f91ca0b", "text": "## Другие middleware { #other-middlewares }\n\nО других middleware вы можете узнать больше в разделе [Advanced User Guide: Advanced Middleware](../advanced/middleware.md){.internal-link target=_blank}.\n\nВ следующем разделе вы можете прочитать, как настроить <abbr title=\"Cross-Origin Resource Sharing – совместное использование ресурсов между источниками\">CORS</abbr> с помощью middleware.\n", "metadata": {"title": "Middleware (Промежуточный слой)", "doc_id": "424aaa2ee9ea", "source_path": "docs\\tutorial\\middleware.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\middleware.md"}, "doc_id": "424aaa2ee9ea", "source_path": "docs\\tutorial\\middleware.md", "title": "Middleware (Промежуточный слой)", "chunk_index": 4, "header": "Другие middleware", "header_level": 2, "token_count": 111}
{"id": "7e477c78a1aecf78", "text": "# Конфигурация операций пути { #path-operation-configuration }\n\nСуществует несколько параметров, которые вы можете передать вашему *декоратору операций пути* для его настройки.\n\n/// warning | Внимание\n\nПомните, что эти параметры передаются непосредственно *декоратору операций пути*, а не вашей *функции-обработчику операций пути*.\n\n///\n\n", "metadata": {"title": "Конфигурация операций пути", "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-operation-configuration.md"}, "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "title": "Конфигурация операций пути", "chunk_index": 0, "header": "Конфигурация операций пути", "header_level": 1, "token_count": 124}
{"id": "ed5410095acd5394", "text": "## Статус-код ответа { #response-status-code }\n\nВы можете определить (HTTP) `status_code`, который будет использован в ответах вашей *операции пути*.\n\nВы можете передать только `int`-значение кода, например `404`.\n\nНо если вы не помните, для чего нужен каждый числовой код, вы можете использовать сокращенные константы в параметре `status`:\n\n{* ../../docs_src/path_operation_configuration/tutorial001_py310.py hl[1,15] *}\n\nЭтот статус-код будет использован в ответе и будет добавлен в схему OpenAPI.\n\n/// note | Технические детали\n\nВы также можете использовать `from starlette import status`.\n\n**FastAPI** предоставляет тот же `starlette.status` под псевдонимом `fastapi.status` для удобства разработчика. Но его источник - это непосредственно Starlette.\n\n///\n\n", "metadata": {"title": "Конфигурация операций пути", "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-operation-configuration.md"}, "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "title": "Конфигурация операций пути", "chunk_index": 1, "header": "Статус-код ответа", "header_level": 2, "token_count": 248}
{"id": "eca5fe4497e6ae12", "text": "## Теги { #tags }\n\nВы можете добавлять теги к вашим *операциям пути*, добавив параметр `tags` с `list` заполненным `str`-значениями (обычно в нём только одна строка):\n\n{* ../../docs_src/path_operation_configuration/tutorial002_py310.py hl[15,20,25] *}\n\nОни будут добавлены в схему OpenAPI и будут использованы в автоматической документации интерфейса:\n\n<img src=\"/img/tutorial/path-operation-configuration/image01.png\">\n\n", "metadata": {"title": "Конфигурация операций пути", "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-operation-configuration.md"}, "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "title": "Конфигурация операций пути", "chunk_index": 2, "header": "Теги", "header_level": 2, "token_count": 137}
{"id": "3dbd5a349dba5480", "text": "### Теги с перечислениями { #tags-with-enums }\n\nЕсли у вас большое приложение, вы можете прийти к необходимости добавить **несколько тегов**, и возможно, вы захотите убедиться в том, что всегда используете **один и тот же тег** для связанных *операций пути*.\n\nВ этих случаях, имеет смысл хранить теги в классе `Enum`.\n\n**FastAPI** поддерживает это так же, как и в случае с обычными строками:\n\n{* ../../docs_src/path_operation_configuration/tutorial002b_py39.py hl[1,8:10,13,18] *}\n\n", "metadata": {"title": "Конфигурация операций пути", "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-operation-configuration.md"}, "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "title": "Конфигурация операций пути", "chunk_index": 3, "header": "Теги с перечислениями", "header_level": 3, "token_count": 184}
{"id": "22b2ef51a4ad2851", "text": "## Краткое и развёрнутое содержание { #summary-and-description }\n\nВы можете добавить параметры `summary` и `description`:\n\n{* ../../docs_src/path_operation_configuration/tutorial003_py310.py hl[18:19] *}\n\n", "metadata": {"title": "Конфигурация операций пути", "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-operation-configuration.md"}, "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "title": "Конфигурация операций пути", "chunk_index": 4, "header": "Краткое и развёрнутое содержание", "header_level": 2, "token_count": 56}
{"id": "d32baf25d8fbe690", "text": "## Описание из строк документации { #description-from-docstring }\n\nТак как описания обычно длинные и содержат много строк, вы можете объявить описание *операции пути* в функции <abbr title=\"многострочный текст, первое выражение внутри функции (не присвоенный какой-либо переменной), используемый для документации\">строки документации</abbr> и **FastAPI** прочитает её отсюда.\n\nВы можете использовать <a href=\"https://en.wikipedia.org/wiki/Markdown\" class=\"external-link\" target=\"_blank\">Markdown</a> в строке документации, и он будет интерпретирован и отображён корректно (с учетом отступа в строке документации).\n\n{* ../../docs_src/path_operation_configuration/tutorial004_py310.py hl[17:25] *}\n\nОн будет использован в интерактивной документации:\n\n<img src=\"/img/tutorial/path-operation-configuration/image02.png\">\n\n", "metadata": {"title": "Конфигурация операций пути", "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-operation-configuration.md"}, "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "title": "Конфигурация операций пути", "chunk_index": 5, "header": "Описание из строк документации", "header_level": 2, "token_count": 248}
{"id": "f00b3d1fd554a0e7", "text": "## Описание ответа { #response-description }\n\nВы можете указать описание ответа с помощью параметра `response_description`:\n\n{* ../../docs_src/path_operation_configuration/tutorial005_py310.py hl[19] *}\n\n/// info | Дополнительная информация\n\nПомните, что `response_description` относится конкретно к ответу, а `description` относится к *операции пути* в целом.\n\n///\n\n/// check\n\nOpenAPI указывает, что каждой *операции пути* необходимо описание ответа.\n\nЕсли вдруг вы не укажете его, то **FastAPI** автоматически сгенерирует это описание с текстом \"Successful response\".\n\n///\n\n<img src=\"/img/tutorial/path-operation-configuration/image03.png\">\n\n", "metadata": {"title": "Конфигурация операций пути", "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-operation-configuration.md"}, "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "title": "Конфигурация операций пути", "chunk_index": 6, "header": "Описание ответа", "header_level": 2, "token_count": 187}
{"id": "7cb06783ea3030c1", "text": "## Обозначение *операции пути* как устаревшей { #deprecate-a-path-operation }\n\nЕсли вам необходимо пометить *операцию пути* как <abbr title=\"устаревшее, не рекомендовано к использованию\">устаревшую</abbr>, при этом не удаляя её, передайте параметр `deprecated`:\n\n{* ../../docs_src/path_operation_configuration/tutorial006_py39.py hl[16] *}\n\nОн будет четко помечен как устаревший в интерактивной документации:\n\n<img src=\"/img/tutorial/path-operation-configuration/image04.png\">\n\nПроверьте, как будут выглядеть устаревшие и не устаревшие *операции пути*:\n\n<img src=\"/img/tutorial/path-operation-configuration/image05.png\">\n\n", "metadata": {"title": "Конфигурация операций пути", "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-operation-configuration.md"}, "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "title": "Конфигурация операций пути", "chunk_index": 7, "header": "Обозначение *операции пути* как устаревшей", "header_level": 2, "token_count": 205}
{"id": "e3af025bdffcc088", "text": "## Резюме { #recap }\n\nВы можете легко конфигурировать и добавлять метаданные в ваши *операции пути*, передавая параметры *декораторам операций пути*.\n", "metadata": {"title": "Конфигурация операций пути", "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "source_mtime": "2026-01-12T17:48:13.420325+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-operation-configuration.md"}, "doc_id": "d0e0a4784f36", "source_path": "docs\\tutorial\\path-operation-configuration.md", "title": "Конфигурация операций пути", "chunk_index": 8, "header": "Резюме", "header_level": 2, "token_count": 64}
{"id": "8d93ba62eaf2bb88", "text": "# Path-параметры и валидация числовых данных { #path-parameters-and-numeric-validations }\n\nТак же, как с помощью `Query` вы можете добавлять валидацию и метаданные для query-параметров, так и с помощью `Path` вы можете добавлять такую же валидацию и метаданные для path-параметров.\n\n", "metadata": {"title": "Path-параметры и валидация числовых данных", "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params-numeric-validations.md"}, "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "title": "Path-параметры и валидация числовых данных", "chunk_index": 0, "header": "Path-параметры и валидация числовых данных", "header_level": 1, "token_count": 101}
{"id": "12535562906705f6", "text": "## Импорт `Path` { #import-path }\n\nСначала импортируйте `Path` из `fastapi`, а также импортируйте `Annotated`:\n\n{* ../../docs_src/path_params_numeric_validations/tutorial001_an_py310.py hl[1,3] *}\n\n/// info | Информация\n\nПоддержка `Annotated` была добавлена в FastAPI начиная с версии 0.95.0 (и с этой версии рекомендуется использовать этот подход).\n\nЕсли вы используете более старую версию, вы столкнётесь с ошибками при попытке использовать `Annotated`.\n\nУбедитесь, что вы [обновили версию FastAPI](../deployment/versions.md#upgrading-the-fastapi-versions){.internal-link target=_blank} как минимум до 0.95.1 перед тем, как использовать `Annotated`.\n\n///\n\n", "metadata": {"title": "Path-параметры и валидация числовых данных", "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params-numeric-validations.md"}, "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "title": "Path-параметры и валидация числовых данных", "chunk_index": 1, "header": "Импорт `Path`", "header_level": 2, "token_count": 234}
{"id": "fbb09dca19cf0b64", "text": "## Определите метаданные { #declare-metadata }\n\nВы можете указать все те же параметры, что и для `Query`.\n\nНапример, чтобы указать значение метаданных `title` для path-параметра `item_id`, вы можете написать:\n\n{* ../../docs_src/path_params_numeric_validations/tutorial001_an_py310.py hl[10] *}\n\n/// note | Примечание\n\nPath-параметр всегда является обязательным, поскольку он должен быть частью пути. Даже если вы объявите его как `None` или зададите значение по умолчанию, это ни на что не повлияет — параметр всё равно будет обязательным.\n\n///\n\n", "metadata": {"title": "Path-параметры и валидация числовых данных", "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params-numeric-validations.md"}, "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "title": "Path-параметры и валидация числовых данных", "chunk_index": 2, "header": "Определите метаданные", "header_level": 2, "token_count": 182}
{"id": "bea3d1c41a1f9631", "text": "## Задайте нужный вам порядок параметров { #order-the-parameters-as-you-need }\n\n/// tip | Подсказка\n\nЭто не имеет большого значения, если вы используете `Annotated`.\n\n///\n\nДопустим, вы хотите объявить query-параметр `q` как обязательный параметр типа `str`.\n\nИ если вам больше ничего не нужно указывать для этого параметра, то нет необходимости использовать `Query`.\n\nНо вам по-прежнему нужно использовать `Path` для path-параметра `item_id`. И если по какой-либо причине вы не хотите использовать `Annotated`, то могут возникнуть небольшие сложности.\n\nЕсли вы поместите параметр со значением по умолчанию перед другим параметром, у которого нет значения по умолчанию, то Python укажет на ошибку.\n\nНо вы можете изменить порядок параметров, чтобы параметр без значения по умолчанию (query-параметр `q`) шёл первым.\n\nЭто не имеет значения для **FastAPI**. Он распознает параметры по их названиям, типам и значениям по умолчанию (`Query`, `Path`, и т.д.), ему не важен их порядок.\n\nПоэтому вы можете определить функцию так:\n\n{* ../../docs_src/path_params_numeric_validations/tutorial002_py39.py hl[7] *}\n\nНо имейте в виду, что если вы используете `Annotated`, вы не столкнётесь с этой проблемой, так как вы не используете значения по умолчанию параметров функции для `Query()` или `Path()`.\n\n{* ../../docs_src/path_params_numeric_validations/tutorial002_an_py39.py *}\n\n", "metadata": {"title": "Path-параметры и валидация числовых данных", "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params-numeric-validations.md"}, "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "title": "Path-параметры и валидация числовых данных", "chunk_index": 3, "header": "Задайте нужный вам порядок параметров", "header_level": 2, "token_count": 454}
{"id": "e95016e4179362e1", "text": "## Задайте нужный вам порядок параметров, полезные приёмы { #order-the-parameters-as-you-need-tricks }\n\n/// tip | Подсказка\n\nЭто не имеет большого значения, если вы используете `Annotated`.\n\n///\n\nЗдесь описан **небольшой приём**, который может оказаться удобным, хотя часто он вам не понадобится.\n\nЕсли вы хотите:\n\n* объявить query-параметр `q` без `Query` и без значения по умолчанию\n* объявить path-параметр `item_id` с помощью `Path`\n* указать их в другом порядке\n* не использовать `Annotated`\n\n...то вы можете использовать специальную возможность синтаксиса Python.\n\nПередайте `*` в качестве первого параметра функции.\n\nPython не будет ничего делать с `*`, но он будет знать, что все следующие параметры являются именованными аргументами (парами ключ-значение), также известными как <abbr title=\"От: K-ey W-ord Arg-uments\"><code>kwargs</code></abbr>, даже если у них нет значений по умолчанию.\n\n{* ../../docs_src/path_params_numeric_validations/tutorial003_py39.py hl[7] *}\n\n", "metadata": {"title": "Path-параметры и валидация числовых данных", "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params-numeric-validations.md"}, "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "title": "Path-параметры и валидация числовых данных", "chunk_index": 4, "header": "Задайте нужный вам порядок параметров, полезные приёмы", "header_level": 2, "token_count": 344}
{"id": "302d9aa80ac10764", "text": "### Лучше с `Annotated` { #better-with-annotated }\n\nИмейте в виду, что если вы используете `Annotated`, то, поскольку вы не используете значений по умолчанию для параметров функции, у вас не возникнет подобной проблемы и вам, вероятно, не придётся использовать `*`.\n\n{* ../../docs_src/path_params_numeric_validations/tutorial003_an_py39.py hl[10] *}\n\n", "metadata": {"title": "Path-параметры и валидация числовых данных", "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params-numeric-validations.md"}, "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "title": "Path-параметры и валидация числовых данных", "chunk_index": 5, "header": "Лучше с `Annotated`", "header_level": 3, "token_count": 116}
{"id": "84ad8f8ba8cb7772", "text": "## Валидация числовых данных: больше или равно { #number-validations-greater-than-or-equal }\n\nС помощью `Query` и `Path` (и других классов, которые мы разберём позже) вы можете добавлять ограничения для числовых данных.\n\nВ этом примере при указании `ge=1`, параметр `item_id` должен быть целым числом \"`g`reater than or `e`qual\" — больше или равно `1`.\n\n{* ../../docs_src/path_params_numeric_validations/tutorial004_an_py39.py hl[10] *}\n\n", "metadata": {"title": "Path-параметры и валидация числовых данных", "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params-numeric-validations.md"}, "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "title": "Path-параметры и валидация числовых данных", "chunk_index": 6, "header": "Валидация числовых данных: больше или равно", "header_level": 2, "token_count": 150}
{"id": "62cfebd097847114", "text": "## Валидация числовых данных: больше и меньше или равно { #number-validations-greater-than-and-less-than-or-equal }\n\nТо же самое применимо к:\n\n* `gt`: больше (`g`reater `t`han)\n* `le`: меньше или равно (`l`ess than or `e`qual)\n\n{* ../../docs_src/path_params_numeric_validations/tutorial005_an_py39.py hl[10] *}\n\n", "metadata": {"title": "Path-параметры и валидация числовых данных", "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params-numeric-validations.md"}, "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "title": "Path-параметры и валидация числовых данных", "chunk_index": 7, "header": "Валидация числовых данных: больше и меньше или равно", "header_level": 2, "token_count": 106}
{"id": "79af5c4cb4c39196", "text": "## Валидация числовых данных: числа с плавающей точкой, больше и меньше { #number-validations-floats-greater-than-and-less-than }\n\nВалидация также применима к значениям типа `float`.\n\nВ этом случае становится важной возможность добавить ограничение <abbr title=\"greater than – больше чем\"><code>gt</code></abbr>, вместо <abbr title=\"greater than or equal – больше или равно\"><code>ge</code></abbr>, поскольку в таком случае вы можете, например, создать ограничение, чтобы значение было больше `0`, даже если оно меньше `1`.\n\nТаким образом, `0.5` будет корректным значением. А `0.0` или `0` — нет.\n\nТо же самое справедливо и для <abbr title=\"less than – меньше чем\"><code>lt</code></abbr>.\n\n{* ../../docs_src/path_params_numeric_validations/tutorial006_an_py39.py hl[13] *}\n\n", "metadata": {"title": "Path-параметры и валидация числовых данных", "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params-numeric-validations.md"}, "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "title": "Path-параметры и валидация числовых данных", "chunk_index": 8, "header": "Валидация числовых данных: числа с плавающей точкой, больше и меньше", "header_level": 2, "token_count": 272}
{"id": "8d93ba62eaf2bb88", "text": "## Резюме { #recap }\n\nС помощью `Query`, `Path` (и других классов, которые мы пока не затронули) вы можете добавлять метаданные и строковую валидацию тем же способом, как и в главе [Query-параметры и валидация строк](query-params-str-validations.md){.internal-link target=_blank}.\n\nА также вы можете добавить валидацию числовых данных:\n\n* `gt`: больше (`g`reater `t`han)\n* `ge`: больше или равно (`g`reater than or `e`qual)\n* `lt`: меньше (`l`ess `t`han)\n* `le`: меньше или равно (`l`ess than or `e`qual)\n\n/// info | Информация\n\n`Query`, `Path` и другие классы, которые вы разберёте позже, являются наследниками общего класса `Param`.\n\nВсе они используют те же параметры для дополнительной валидации и метаданных, которые вы видели ранее.\n\n///\n\n/// note | Технические детали\n\n`Query`, `Path` и другие \"классы\", которые вы импортируете из `fastapi`, на самом деле являются функциями, которые при вызове возвращают экземпляры одноимённых классов.\n\nОбъект `Query`, который вы импортируете, является функцией. И при вызове она возвращает экземпляр одноимённого класса `Query`.\n\nИспользование функций (вместо использования классов напрямую) нужно для того, чтобы ваш редактор не подсвечивал ошибки, связанные с их типами.", "metadata": {"title": "Path-параметры и валидация числовых данных", "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params-numeric-validations.md", "section_header": "Резюме", "section_header_level": 2}, "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "title": "Path-параметры и валидация числовых данных", "chunk_index": 9, "header": "Резюме", "header_level": 2, "token_count": 473}
{"id": "12535562906705f6", "text": "р одноимённого класса `Query`.\n\nИспользование функций (вместо использования классов напрямую) нужно для того, чтобы ваш редактор не подсвечивал ошибки, связанные с их типами.\n\nТаким образом вы можете использовать привычный вам редактор и инструменты разработки, не добавляя дополнительных конфигураций для игнорирования подобных ошибок.\n\n///", "metadata": {"title": "Path-параметры и валидация числовых данных", "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params-numeric-validations.md", "section_header": "Резюме", "section_header_level": 2}, "doc_id": "97ff86fb2850", "source_path": "docs\\tutorial\\path-params-numeric-validations.md", "title": "Path-параметры и валидация числовых данных", "chunk_index": 10, "header": "Резюме", "header_level": 2, "token_count": 124}
{"id": "c47adf1426910cc6", "text": "# Path-параметры { #path-parameters }\n\nВы можете определить \"параметры\" или \"переменные\" пути, используя синтаксис форматированных строк Python:\n\n{* ../../docs_src/path_params/tutorial001_py39.py hl[6:7] *}\n\nЗначение параметра пути `item_id` будет передано в функцию в качестве аргумента `item_id`.\n\nЕсли запустите этот пример и перейдёте по адресу: <a href=\"http://127.0.0.1:8000/items/foo\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/items/foo</a>, то увидите ответ:\n\n```JSON\n{\"item_id\":\"foo\"}\n```\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 0, "header": "Path-параметры", "header_level": 1, "token_count": 183}
{"id": "60bbf5ad825d084d", "text": "## Параметры пути с типами { #path-parameters-with-types }\n\nВы можете объявить тип параметра пути в функции, используя стандартные аннотации типов Python:\n\n{* ../../docs_src/path_params/tutorial002_py39.py hl[7] *}\n\nЗдесь, `item_id` объявлен типом `int`.\n\n/// check | Заметка\n\nЭто обеспечит поддержку редактора кода внутри функции (проверка ошибок, автозавершение и т.п.).\n\n///\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 1, "header": "Параметры пути с типами", "header_level": 2, "token_count": 135}
{"id": "bf09190a6ae9dcca", "text": "## <abbr title=\"также известное как: сериализация, парсинг, маршаллинг\">Преобразование</abbr> данных { #data-conversion }\n\nЕсли запустите этот пример и перейдёте по адресу: <a href=\"http://127.0.0.1:8000/items/3\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/items/3</a>, то увидите ответ:\n\n```JSON\n{\"item_id\":3}\n```\n\n/// check | Заметка\n\nОбратите внимание на значение `3`, которое получила (и вернула) функция. Это целочисленный Python `int`, а не строка `\"3\"`.\n\nИспользуя такое объявление типов, **FastAPI** выполняет автоматический <abbr title=\"преобразование строк из HTTP-запроса в типы данных Python\">\"парсинг\"</abbr> запросов.\n\n///\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 2, "header": "<abbr title=\"также известное как: сериализация, парсинг, маршаллинг\">Преобразование</abbr> данных", "header_level": 2, "token_count": 253}
{"id": "7fa1502101867292", "text": "## Валидация данных { #data-validation }\n\nЕсли откроете браузер по адресу <a href=\"http://127.0.0.1:8000/items/foo\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/items/foo</a>, то увидите интересную HTTP-ошибку:\n\n```JSON\n{\n  \"detail\": [\n    {\n      \"type\": \"int_parsing\",\n      \"loc\": [\n        \"path\",\n        \"item_id\"\n      ],\n      \"msg\": \"Input should be a valid integer, unable to parse string as an integer\",\n      \"input\": \"foo\"\n    }\n  ]\n}\n```\n\nиз-за того, что параметр пути `item_id` имеет значение `\"foo\"`, которое не является типом `int`.\n\nТа же ошибка возникнет, если вместо `int` передать `float`, например: <a href=\"http://127.0.0.1:8000/items/4.2\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/items/4.2</a>\n\n/// check | Заметка\n\n**FastAPI** обеспечивает валидацию данных, используя всё те же определения типов.\n\nОбратите внимание, что в тексте ошибки явно указано место, не прошедшее проверку.\n\nЭто очень полезно при разработке и отладке кода, который взаимодействует с API.\n\n///\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 3, "header": "Валидация данных", "header_level": 2, "token_count": 375}
{"id": "c6b5fe7f47687514", "text": "## Документация { #documentation }\n\nИ теперь, когда откроете браузер по адресу: <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a>, то увидите вот такую автоматически сгенерированную документацию API:\n\n<img src=\"/img/tutorial/path-params/image01.png\">\n\n/// check | Заметка\n\nЕщё раз, просто используя определения типов, **FastAPI** обеспечивает автоматическую интерактивную документацию (с интеграцией Swagger UI).\n\nОбратите внимание, что параметр пути объявлен целочисленным.\n\n///\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 4, "header": "Документация", "header_level": 2, "token_count": 201}
{"id": "9979b864d3905f56", "text": "## Преимущества стандартизации, альтернативная документация { #standards-based-benefits-alternative-documentation }\n\nПоскольку сгенерированная схема соответствует стандарту <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md\" class=\"external-link\" target=\"_blank\">OpenAPI</a>, её можно использовать со множеством совместимых инструментов.\n\nИменно поэтому, **FastAPI** сам предоставляет альтернативную документацию API (используя ReDoc), которую можно получить по адресу: <a href=\"http://127.0.0.1:8000/redoc\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/redoc</a>.\n\n<img src=\"/img/tutorial/path-params/image02.png\">\n\nПо той же причине, есть множество совместимых инструментов, включая инструменты генерации кода для многих языков.\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 5, "header": "Преимущества стандартизации, альтернативная документация", "header_level": 2, "token_count": 283}
{"id": "2603fe922271b3b5", "text": "## Pydantic { #pydantic }\n\nВся проверка данных выполняется под капотом с помощью <a href=\"https://docs.pydantic.dev/\" class=\"external-link\" target=\"_blank\">Pydantic</a>. Поэтому вы можете быть уверены в качестве обработки данных.\n\nВы можете использовать в аннотациях как простые типы данных, вроде `str`, `float`, `bool`, так и более сложные типы.\n\nНекоторые из них рассматриваются в следующих главах данного руководства.\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 6, "header": "Pydantic", "header_level": 2, "token_count": 153}
{"id": "5ea9732fac36cc04", "text": "## Порядок имеет значение { #order-matters }\n\nПри создании *операций пути* можно столкнуться с ситуацией, когда путь является фиксированным.\n\nНапример, `/users/me`. Предположим, что это путь для получения данных о текущем пользователе.\n\nУ вас также может быть путь `/users/{user_id}`, чтобы получить данные о конкретном пользователе по его ID.\n\nПоскольку *операции пути* выполняются в порядке их объявления, необходимо, чтобы путь для `/users/me` был объявлен раньше, чем путь для `/users/{user_id}`:\n\n{* ../../docs_src/path_params/tutorial003_py39.py hl[6,11] *}\n\nИначе путь для `/users/{user_id}` также будет соответствовать `/users/me`, \"подразумевая\", что он получает параметр `user_id` со значением `\"me\"`.\n\nАналогично, вы не можете переопределить операцию с путем:\n\n{* ../../docs_src/path_params/tutorial003b_py39.py hl[6,11] *}\n\nПервый будет выполняться всегда, так как путь совпадает первым.\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 7, "header": "Порядок имеет значение", "header_level": 2, "token_count": 322}
{"id": "bdc033446c420297", "text": "## Предопределенные значения { #predefined-values }\n\nЧто если нам нужно заранее определить допустимые *параметры пути*, которые *операция пути* может принимать? В таком случае можно использовать стандартное перечисление <abbr title=\"Enumeration\">`Enum`</abbr> Python.\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 8, "header": "Предопределенные значения", "header_level": 2, "token_count": 88}
{"id": "42e933eb412d5131", "text": "### Создание класса `Enum` { #create-an-enum-class }\n\nИмпортируйте `Enum` и создайте подкласс, который наследуется от `str` и `Enum`.\n\nМы наследуемся от `str`, чтобы документация API могла понять, что значения должны быть типа `string` и отображалась правильно.\n\nЗатем создайте атрибуты класса с фиксированными допустимыми значениями:\n\n{* ../../docs_src/path_params/tutorial005_py39.py hl[1,6:9] *}\n\n/// tip | Подсказка\n\nЕсли интересно, то \"AlexNet\", \"ResNet\" и \"LeNet\" - это названия <abbr title=\"Технически, архитектуры моделей глубокого обучения\">моделей</abbr> Машинного обучения.\n\n///\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 9, "header": "Создание класса `Enum`", "header_level": 3, "token_count": 224}
{"id": "ddca3d5b391fa5c6", "text": "### Определение *параметра пути* { #declare-a-path-parameter }\n\nОпределите *параметр пути*, используя в аннотации типа класс перечисления (`ModelName`), созданный ранее:\n\n{* ../../docs_src/path_params/tutorial005_py39.py hl[16] *}\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 10, "header": "Определение *параметра пути*", "header_level": 3, "token_count": 76}
{"id": "694acc0932072de0", "text": "### Проверьте документацию { #check-the-docs }\n\nПоскольку доступные значения *параметра пути* определены заранее, интерактивная документация может наглядно их отображать:\n\n<img src=\"/img/tutorial/path-params/image03.png\">\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 11, "header": "Проверьте документацию", "header_level": 3, "token_count": 71}
{"id": "05e21fe0f6b3b5a7", "text": "### Работа с *перечислениями* в Python { #working-with-python-enumerations }\n\nЗначение *параметра пути* будет *элементом перечисления*.\n\n#### Сравнение *элементов перечисления* { #compare-enumeration-members }\n\nВы можете сравнить это значение с *элементом перечисления* класса `ModelName`:\n\n{* ../../docs_src/path_params/tutorial005_py39.py hl[17] *}\n\n#### Получение *значения перечисления* { #get-the-enumeration-value }\n\nМожно получить фактическое значение (в данном случае - `str`) с помощью `model_name.value` или в общем случае `your_enum_member.value`:\n\n{* ../../docs_src/path_params/tutorial005_py39.py hl[20] *}\n\n/// tip | Подсказка\n\nЗначение `\"lenet\"` также можно получить с помощью `ModelName.lenet.value`.\n\n///\n\n#### Возврат *элементов перечисления* { #return-enumeration-members }\n\nИз *операции пути* можно вернуть *элементы перечисления*, даже вложенные в тело JSON (например в `dict`).\n\nОни будут преобразованы в соответствующие значения (в данном случае - строки) перед их возвратом клиенту:\n\n{* ../../docs_src/path_params/tutorial005_py39.py hl[18,21,23] *}\nВы отправите клиенту такой JSON-ответ:\n\n```JSON\n{\n  \"model_name\": \"alexnet\",\n  \"message\": \"Deep Learning FTW!\"\n}\n```\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 12, "header": "Работа с *перечислениями* в Python", "header_level": 3, "token_count": 395}
{"id": "bb86baec0d26f063", "text": "## Path-параметры, содержащие пути { #path-parameters-containing-paths }\n\nПредположим, что есть *операция пути* с путем `/files/{file_path}`.\n\nНо вам нужно, чтобы `file_path` сам содержал *путь*, например, `home/johndoe/myfile.txt`.\n\nТогда URL для этого файла будет такой: `/files/home/johndoe/myfile.txt`.\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 13, "header": "Path-параметры, содержащие пути", "header_level": 2, "token_count": 107}
{"id": "59c4bb3d587c61f9", "text": "### Поддержка OpenAPI { #openapi-support }\n\nOpenAPI не поддерживает способов объявления *параметра пути*, содержащего внутри *путь*, так как это может привести к сценариям, которые сложно определять и тестировать.\n\nТем не менее это можно сделать в **FastAPI**, используя один из внутренних инструментов Starlette.\n\nДокументация по-прежнему будет работать, хотя и не добавит никакой информации о том, что параметр должен содержать путь.\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 14, "header": "Поддержка OpenAPI", "header_level": 3, "token_count": 158}
{"id": "23d4b01dfa0ac2bc", "text": "### Конвертер пути { #path-convertor }\n\nБлагодаря одной из опций Starlette, можете объявить *параметр пути*, содержащий *путь*, используя URL вроде:\n\n```\n/files/{file_path:path}\n```\n\nВ этом случае `file_path` - это имя параметра, а часть `:path`, указывает, что параметр должен соответствовать любому *пути*.\n\nМожете использовать так:\n\n{* ../../docs_src/path_params/tutorial004_py39.py hl[6] *}\n\n/// tip | Подсказка\n\nВозможно, вам понадобится, чтобы параметр содержал `/home/johndoe/myfile.txt` с ведущим слэшем (`/`).\n\nВ этом случае URL будет таким: `/files//home/johndoe/myfile.txt`, с двойным слэшем (`//`) между `files` и `home`.\n\n///\n\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 15, "header": "Конвертер пути", "header_level": 3, "token_count": 240}
{"id": "ca7b34ed805319df", "text": "## Резюме { #recap }\n\nИспользуя **FastAPI** вместе со стандартными объявлениями типов Python (короткими и интуитивно понятными), вы получаете:\n\n* Поддержку редактора кода (проверку ошибок, автозавершение и т.п.)\n* \"<abbr title=\"преобразование строк из HTTP-запроса в типы данных Python\">Парсинг</abbr>\" данных\n* Валидацию данных\n* Аннотации API и автоматическую документацию\n\nИ объявлять типы достаточно один раз.\n\nЭто, вероятно, является главным заметным преимуществом **FastAPI** по сравнению с альтернативными фреймворками (кроме <abbr title=\"не считая оптимизаций\">сырой</abbr> производительности).\n", "metadata": {"title": "Path-параметры", "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "source_mtime": "2026-01-12T17:48:13.436057+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\path-params.md"}, "doc_id": "b6ae4aa4cee4", "source_path": "docs\\tutorial\\path-params.md", "title": "Path-параметры", "chunk_index": 16, "header": "Резюме", "header_level": 2, "token_count": 257}
{"id": "10865fa00d6bf528", "text": "# Модели Query-Параметров { #query-parameter-models }\n\nЕсли у вас есть группа связанных **query-параметров**, то вы можете объединить их в одну **Pydantic-модель**.\n\nЭто позволит вам **переиспользовать модель** в **разных местах**, устанавливать валидаторы и метаданные, в том числе для сразу всех параметров, в одном месте. \n\n/// note | Заметка\n\nЭтот функционал доступен с версии `0.115.0`. \n\n///\n\n", "metadata": {"title": "Модели Query-Параметров", "doc_id": "1de2e82abee6", "source_path": "docs\\tutorial\\query-param-models.md", "source_mtime": "2026-01-12T17:48:13.452659+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-param-models.md"}, "doc_id": "1de2e82abee6", "source_path": "docs\\tutorial\\query-param-models.md", "title": "Модели Query-Параметров", "chunk_index": 0, "header": "Модели Query-Параметров", "header_level": 1, "token_count": 157}
{"id": "9e9393df20818352", "text": "## Pydantic-Модель для Query-Параметров { #query-parameters-with-a-pydantic-model }\n\nОбъявите нужные **query-параметры** в **Pydantic-модели**, а после аннотируйте параметр как `Query`:\n\n{* ../../docs_src/query_param_models/tutorial001_an_py310.py hl[9:13,17] *}\n\n**FastAPI извлечёт** данные соответствующие **каждому полю модели** из **query-параметров** запроса и выдаст вам объявленную Pydantic-модель заполненную ими.\n\n", "metadata": {"title": "Модели Query-Параметров", "doc_id": "1de2e82abee6", "source_path": "docs\\tutorial\\query-param-models.md", "source_mtime": "2026-01-12T17:48:13.452659+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-param-models.md"}, "doc_id": "1de2e82abee6", "source_path": "docs\\tutorial\\query-param-models.md", "title": "Модели Query-Параметров", "chunk_index": 1, "header": "Pydantic-Модель для Query-Параметров", "header_level": 2, "token_count": 151}
{"id": "d2ca1dee5f10f269", "text": "## Проверьте Сгенерированную Документацию { #check-the-docs }\n\nВы можете посмотреть query-параметры в графическом интерфейсе сгенерированной документации по пути `/docs`:\n\n<div class=\"screenshot\">\n<img src=\"/img/tutorial/query-param-models/image01.png\">\n</div>\n\n", "metadata": {"title": "Модели Query-Параметров", "doc_id": "1de2e82abee6", "source_path": "docs\\tutorial\\query-param-models.md", "source_mtime": "2026-01-12T17:48:13.452659+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-param-models.md"}, "doc_id": "1de2e82abee6", "source_path": "docs\\tutorial\\query-param-models.md", "title": "Модели Query-Параметров", "chunk_index": 2, "header": "Проверьте Сгенерированную Документацию", "header_level": 2, "token_count": 88}
{"id": "a362b91bd769121e", "text": "## Запретить Дополнительные Query-Параметры { #forbid-extra-query-parameters }\n\nВ некоторых случаях (не особо часто встречающихся) вам может понадобиться **ограничить** query-параметры, которые вы хотите получить.\n\nВы можете сконфигурировать Pydantic-модель так, чтобы запретить (`forbid`) все дополнительные (`extra`) поля.\n\n{* ../../docs_src/query_param_models/tutorial002_an_py310.py hl[10] *}\n\nЕсли клиент попробует отправить **дополнительные** данные в **query-параметрах**, то в ответ он получит **ошибку**.\n\nНапример, если клиент попытается отправить query-параметр `tool` с значением `plumbus`, в виде:\n\n```http\nhttps://example.com/items/?limit=10&tool=plumbus\n```\n\nТо в ответ он получит **ошибку**, сообщающую ему, что query-параметр `tool` не разрешен:\n\n```json\n{\n    \"detail\": [\n        {\n            \"type\": \"extra_forbidden\",\n            \"loc\": [\"query\", \"tool\"],\n            \"msg\": \"Extra inputs are not permitted\",\n            \"input\": \"plumbus\"\n        }\n    ]\n}\n```\n\n", "metadata": {"title": "Модели Query-Параметров", "doc_id": "1de2e82abee6", "source_path": "docs\\tutorial\\query-param-models.md", "source_mtime": "2026-01-12T17:48:13.452659+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-param-models.md"}, "doc_id": "1de2e82abee6", "source_path": "docs\\tutorial\\query-param-models.md", "title": "Модели Query-Параметров", "chunk_index": 3, "header": "Запретить Дополнительные Query-Параметры", "header_level": 2, "token_count": 327}
{"id": "d2cb646b3f3cabae", "text": "## Заключение { #summary }\n\nВы можете использовать **Pydantic-модели** для объявления **query-параметров** в **FastAPI**. \n\n/// tip | Совет\n\nСпойлер: вы также можете использовать Pydantic-модели, чтобы объявлять cookies и HTTP-заголовки, но об этом вы прочитаете позже. \n\n///\n", "metadata": {"title": "Модели Query-Параметров", "doc_id": "1de2e82abee6", "source_path": "docs\\tutorial\\query-param-models.md", "source_mtime": "2026-01-12T17:48:13.452659+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-param-models.md"}, "doc_id": "1de2e82abee6", "source_path": "docs\\tutorial\\query-param-models.md", "title": "Модели Query-Параметров", "chunk_index": 4, "header": "Заключение", "header_level": 2, "token_count": 102}
{"id": "efac7c34e41d1feb", "text": "# Query-параметры и валидация строк { #query-parameters-and-string-validations }\n\n**FastAPI** позволяет определять дополнительную информацию и выполнять валидацию для ваших параметров.\n\nРассмотрим это приложение в качестве примера:\n\n{* ../../docs_src/query_params_str_validations/tutorial001_py310.py hl[7] *}\n\nQuery-параметр `q` имеет тип `str | None`, это означает, что он имеет тип `str`, но также может быть `None`. Значение по умолчанию действительно `None`, поэтому FastAPI будет знать, что он не обязателен.\n\n/// note | Технические детали\n\nFastAPI поймёт, что значение `q` не обязательно, из‑за значения по умолчанию `= None`.\n\nАннотация `str | None` позволит вашему редактору кода обеспечить лучшую поддержку и находить ошибки.\n\n///\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 0, "header": "Query-параметры и валидация строк", "header_level": 1, "token_count": 265}
{"id": "3c0816d62e4b03f9", "text": "## Дополнительная валидация { #additional-validation }\n\nМы собираемся добавить ограничение: хотя `q` и необязателен, когда он передан, **его длина не должна превышать 50 символов**.\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 1, "header": "Дополнительная валидация", "header_level": 2, "token_count": 72}
{"id": "523fa5f306bf2861", "text": "### Импорт `Query` и `Annotated` { #import-query-and-annotated }\n\nЧтобы сделать это, сначала импортируйте:\n\n* `Query` из `fastapi`\n* `Annotated` из `typing`\n\n{* ../../docs_src/query_params_str_validations/tutorial002_an_py310.py hl[1,3] *}\n\n/// info | Дополнительная информация\n\nПоддержка `Annotated` (и рекомендация использовать его) появилась в FastAPI версии 0.95.0.\n\nЕсли у вас более старая версия, при попытке использовать `Annotated` вы получите ошибки.\n\nУбедитесь, что вы [обновили версию FastAPI](../deployment/versions.md#upgrading-the-fastapi-versions){.internal-link target=_blank} как минимум до 0.95.1 перед использованием `Annotated`.\n\n///\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 2, "header": "Импорт `Query` и `Annotated`", "header_level": 3, "token_count": 227}
{"id": "dd9f1d818ba6f504", "text": "## Использовать `Annotated` в типе для параметра `q` { #use-annotated-in-the-type-for-the-q-parameter }\n\nПомните, я уже говорил, что `Annotated` можно использовать для добавления метаданных к параметрам в разделе [Введение в типы Python](../python-types.md#type-hints-with-metadata-annotations){.internal-link target=_blank}?\n\nПришло время использовать его с FastAPI. \n\nУ нас была такая аннотация типа:\n\n//// tab | Python 3.10+\n\n```Python\nq: str | None = None\n```\n\n////\n\n//// tab | Python 3.9+\n\n```Python\nq: Union[str, None] = None\n```\n\n////\n\nМы «обернём» это в `Annotated`, и получится:\n\n//// tab | Python 3.10+\n\n```Python\nq: Annotated[str | None] = None\n```\n\n////\n\n//// tab | Python 3.9+\n\n```Python\nq: Annotated[Union[str, None]] = None\n```\n\n////\n\nОбе версии означают одно и то же: `q` — параметр, который может быть `str` или `None`, и по умолчанию равен `None`.\n\nА теперь к самому интересному. \n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 3, "header": "Использовать `Annotated` в типе для параметра `q`", "header_level": 2, "token_count": 311}
{"id": "7b9bb3f12c0e7cdc", "text": "## Добавим `Query` в `Annotated` для параметра `q` { #add-query-to-annotated-in-the-q-parameter }\n\nТеперь, когда у нас есть `Annotated`, куда можно поместить дополнительную информацию (в нашем случае — дополнительные правила валидации), добавим `Query` внутрь `Annotated` и установим параметр `max_length` равным `50`:\n\n{* ../../docs_src/query_params_str_validations/tutorial002_an_py310.py hl[9] *}\n\nОбратите внимание, что значение по умолчанию по‑прежнему `None`, то есть параметр остаётся необязательным.\n\nНо теперь, добавив `Query(max_length=50)` внутрь `Annotated`, мы говорим FastAPI, что этому значению нужна **дополнительная валидация** — максимум 50 символов. \n\n/// tip | Совет\n\nЗдесь мы используем `Query()`, потому что это **query-параметр**. Позже мы увидим другие — `Path()`, `Body()`, `Header()` и `Cookie()`, — они также принимают те же аргументы, что и `Query()`.\n\n///\n\nТеперь FastAPI будет:\n\n* **валидировать** данные, удостоверяясь, что максимальная длина — 50 символов;\n* показывать **понятную ошибку** клиенту, если данные невалидны;\n* **документировать** параметр в *операции пути* схемы OpenAPI (он будет показан в **UI автоматической документации**).\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 4, "header": "Добавим `Query` в `Annotated` для параметра `q`", "header_level": 2, "token_count": 437}
{"id": "efac7c34e41d1feb", "text": "## Альтернатива (устаревшее): `Query` как значение по умолчанию { #alternative-old-query-as-the-default-value }\n\nВ предыдущих версиях FastAPI (до <abbr title=\"до 2023-03\">0.95.0</abbr>) требовалось использовать `Query` как значение по умолчанию для параметра вместо помещения его в `Annotated`. Скорее всего вы ещё встретите такой код, поэтому поясню.\n\n/// tip | Подсказка\n\nДля нового кода и везде, где это возможно, используйте `Annotated`, как описано выше. У этого есть несколько преимуществ (см. ниже) и нет недостатков. \n\n///\n\nВот как можно использовать `Query()` как значение по умолчанию для параметра функции, установив `max_length` равным 50:\n\n{* ../../docs_src/query_params_str_validations/tutorial002_py310.py hl[7] *}\n\nТак как в этом случае (без `Annotated`) мы заменяем в функции значение по умолчанию `None` на `Query()`, теперь нужно указать значение по умолчанию через параметр `Query(default=None)`, это служит той же цели — задать значение по умолчанию (по крайней мере для FastAPI).\n\nИтак:\n\n```Python\nq: str | None = Query(default=None)\n```\n\n...делает параметр необязательным со значением по умолчанию `None`, так же как:\n\n```Python\nq: str | None = None\n```\n\nНо вариант с `Query` явно объявляет его как query-параметр.\n\nЗатем мы можем передать и другие параметры в `Query`. В данном случае — параметр `max_length`, применимый к строкам:\n\n```Python\nq: str | None = Query(default=None, max_length=50)\n```", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md", "section_header": "Альтернатива (устаревшее): `Query` как значение по умолчанию", "section_header_level": 2}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 5, "header": "Альтернатива (устаревшее): `Query` как значение по умолчанию", "header_level": 2, "token_count": 505}
{"id": "3c0816d62e4b03f9", "text": "-параметр.\n\nЗатем мы можем передать и другие параметры в `Query`. В данном случае — параметр `max_length`, применимый к строкам:\n\n```Python\nq: str | None = Query(default=None, max_length=50)\n```\n\nЭто провалидирует данные, покажет понятную ошибку, если данные невалидны, и задокументирует параметр в *операции пути* схемы OpenAPI.", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md", "section_header": "Альтернатива (устаревшее): `Query` как значение по умолчанию", "section_header_level": 2}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 6, "header": "Альтернатива (устаревшее): `Query` как значение по умолчанию", "header_level": 2, "token_count": 117}
{"id": "ae176094145ba969", "text": "### `Query` как значение по умолчанию или внутри `Annotated` { #query-as-the-default-value-or-in-annotated }\n\nПомните, что при использовании `Query` внутри `Annotated` нельзя указывать параметр `default` у `Query`.\n\nВместо этого используйте обычное значение по умолчанию параметра функции. Иначе это будет неоднозначно.\n\nНапример, так делать нельзя:\n\n```Python\nq: Annotated[str, Query(default=\"rick\")] = \"morty\"\n```\n\n...потому что непонятно, какое значение должно быть по умолчанию: `\"rick\"` или `\"morty\"`.\n\nСледовательно, используйте (предпочтительно):\n\n```Python\nq: Annotated[str, Query()] = \"rick\"\n```\n\n...или в старой кодовой базе вы увидите:\n\n```Python\nq: str = Query(default=\"rick\")\n```\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 7, "header": "`Query` как значение по умолчанию или внутри `Annotated`", "header_level": 3, "token_count": 243}
{"id": "4e65693cc50b7f22", "text": "### Преимущества `Annotated` { #advantages-of-annotated }\n\n**Рекомендуется использовать `Annotated`** вместо задания значения по умолчанию в параметрах функции — так **лучше** по нескольким причинам. \n\n**Значение по умолчанию** у **параметра функции** — это **настоящее значение по умолчанию**, что более интуитивно для Python. \n\nВы можете **вызвать** эту же функцию в **других местах** без FastAPI, и она будет **работать как ожидается**. Если есть **обязательный** параметр (без значения по умолчанию), ваш **редактор кода** сообщит об ошибке, **Python** тоже пожалуется, если вы запустите её без передачи обязательного параметра.\n\nЕсли вы не используете `Annotated`, а применяете **(устаревший) стиль со значением по умолчанию**, то при вызове этой функции без FastAPI в **других местах** вам нужно **помнить** о том, что надо передать аргументы, чтобы всё работало корректно, иначе значения будут не такими, как вы ожидаете (например, вместо `str` будет `QueryInfo` или что-то подобное). И ни редактор, ни Python не будут ругаться при самом вызове функции — ошибка проявится лишь при операциях внутри.\n\nТак как `Annotated` может содержать больше одной аннотации метаданных, теперь вы можете использовать ту же функцию и с другими инструментами, например с <a href=\"https://typer.tiangolo.com/\" class=\"external-link\" target=\"_blank\">Typer</a>. \n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 8, "header": "Преимущества `Annotated`", "header_level": 3, "token_count": 496}
{"id": "7f766bb7b6a40a73", "text": "## Больше валидаций { #add-more-validations }\n\nМожно также добавить параметр `min_length`:\n\n{* ../../docs_src/query_params_str_validations/tutorial003_an_py310.py hl[10] *}\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 9, "header": "Больше валидаций", "header_level": 2, "token_count": 50}
{"id": "19931e999de1dd72", "text": "## Регулярные выражения { #add-regular-expressions }\n\nВы можете определить <abbr title=\"Регулярное выражение (regex, regexp) — это последовательность символов, задающая шаблон поиска для строк.\">регулярное выражение</abbr> `pattern`, которому должен соответствовать параметр:\n\n{* ../../docs_src/query_params_str_validations/tutorial004_an_py310.py hl[11] *}\n\nДанный шаблон регулярного выражения проверяет, что полученное значение параметра:\n\n* `^`: начинается с следующих символов, до них нет символов.\n* `fixedquery`: имеет точное значение `fixedquery`.\n* `$`: заканчивается здесь, после `fixedquery` нет никаких символов.\n\nЕсли вы теряетесь во всех этих идеях про **«регулярные выражения»**, не переживайте. Это сложная тема для многих. Многое можно сделать и без них.\n\nТеперь вы знаете, что когда они понадобятся, вы сможете использовать их в **FastAPI**.\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 10, "header": "Регулярные выражения", "header_level": 2, "token_count": 312}
{"id": "6f0fa23d9e53516d", "text": "### `regex` из Pydantic v1 вместо `pattern` { #pydantic-v1-regex-instead-of-pattern }\n\nДо Pydantic версии 2 и до FastAPI 0.100.0 этот параметр назывался `regex`, а не `pattern`, но сейчас он устарел.\n\nВы всё ещё можете встретить такой код:\n\n//// tab | Pydantic v1\n\n{* ../../docs_src/query_params_str_validations/tutorial004_regex_an_py310.py hl[11] *}\n\n////\n\nИмейте в виду, что это устарело, и код следует обновить на использование нового параметра `pattern`. \n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 11, "header": "`regex` из Pydantic v1 вместо `pattern`", "header_level": 3, "token_count": 162}
{"id": "e29eadd200fce46d", "text": "## Значения по умолчанию { #default-values }\n\nКонечно, можно использовать и другие значения по умолчанию, не только `None`.\n\nДопустим, вы хотите объявить, что query-параметр `q` должен иметь `min_length` равный `3` и значение по умолчанию `\"fixedquery\"`:\n\n{* ../../docs_src/query_params_str_validations/tutorial005_an_py39.py hl[9] *}\n\n/// note | Примечание\n\nНаличие значения по умолчанию любого типа, включая `None`, делает параметр необязательным.\n\n///\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 12, "header": "Значения по умолчанию", "header_level": 2, "token_count": 153}
{"id": "2d21d01736bf9cc3", "text": "## Обязательные параметры { #required-parameters }\n\nКогда не требуется объявлять дополнительные проверки или метаданные, можно сделать query-параметр `q` обязательным, просто не указывая значение по умолчанию, например:\n\n```Python\nq: str\n```\n\nвместо:\n\n```Python\nq: str | None = None\n```\n\nНо сейчас мы объявляем его через `Query`, например так:\n\n```Python\nq: Annotated[str | None, Query(min_length=3)] = None\n```\n\nПоэтому, когда вам нужно объявить значение как обязательное при использовании `Query`, просто не указывайте значение по умолчанию:\n\n{* ../../docs_src/query_params_str_validations/tutorial006_an_py39.py hl[9] *}\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 13, "header": "Обязательные параметры", "header_level": 2, "token_count": 214}
{"id": "e2f5c19889817b24", "text": "### Обязательный, но может быть `None` { #required-can-be-none }\n\nМожно объявить, что параметр может принимать `None`, но при этом остаётся обязательным. Это заставит клиентов отправлять значение, даже если это значение — `None`.\n\nДля этого объявите, что `None` — валидный тип, но просто не задавайте значение по умолчанию:\n\n{* ../../docs_src/query_params_str_validations/tutorial006c_an_py310.py hl[9] *}\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 14, "header": "Обязательный, но может быть `None`", "header_level": 3, "token_count": 138}
{"id": "63eeb4503f416939", "text": "## Query-параметр - список / несколько значений { #query-parameter-list-multiple-values }\n\nКогда вы явно объявляете query-параметр через `Query`, можно также указать, что он принимает список значений, иначе говоря — несколько значений.\n\nНапример, чтобы объявить query-параметр `q`, который может встречаться в URL несколько раз, можно написать:\n\n{* ../../docs_src/query_params_str_validations/tutorial011_an_py310.py hl[9] *}\n\nТогда при таком URL:\n\n```\nhttp://localhost:8000/items/?q=foo&q=bar\n```\n\nвы получите множественные значения query-параметра `q` (`foo` и `bar`) в виде Python-`list` внутри вашей *функции обработки пути*, в *параметре функции* `q`.\n\nТаким образом, ответ на этот URL будет:\n\n```JSON\n{\n  \"q\": [\n    \"foo\",\n    \"bar\"\n  ]\n}\n```\n\n/// tip | Совет\n\nЧтобы объявить query-параметр типа `list`, как в примере выше, нужно явно использовать `Query`, иначе он будет интерпретирован как тело запроса.\n\n///\n\nИнтерактивная документация API обновится соответствующим образом и позволит передавать несколько значений:\n\n<img src=\"/img/tutorial/query-params-str-validations/image02.png\">\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 15, "header": "Query-параметр - список / несколько значений", "header_level": 2, "token_count": 370}
{"id": "fcabb8bb71bf07a2", "text": "### Query-параметр - список / несколько значений со значением по умолчанию { #query-parameter-list-multiple-values-with-defaults }\n\nМожно также определить значение по умолчанию как `list`, если ничего не передано:\n\n{* ../../docs_src/query_params_str_validations/tutorial012_an_py39.py hl[9] *}\n\nЕсли вы перейдёте по адресу:\n\n```\nhttp://localhost:8000/items/\n```\n\nзначение по умолчанию для `q` будет: `[\"foo\", \"bar\"]`, и ответом будет:\n\n```JSON\n{\n  \"q\": [\n    \"foo\",\n    \"bar\"\n  ]\n}\n```\n\n#### Просто `list` { #using-just-list }\n\nМожно использовать `list` напрямую вместо `list[str]`:\n\n{* ../../docs_src/query_params_str_validations/tutorial013_an_py39.py hl[9] *}\n\n/// note | Технические детали\n\nИмейте в виду, что в этом случае FastAPI не будет проверять содержимое списка.\n\nНапример, `list[int]` проверит (и задокументирует), что элементы списка — целые числа. А просто `list` — нет.\n\n///\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 16, "header": "Query-параметр - список / несколько значений со значением по умолчанию", "header_level": 3, "token_count": 297}
{"id": "82db68bc4db1fa67", "text": "## Больше метаданных { #declare-more-metadata }\n\nМожно добавить больше информации о параметре.\n\nЭта информация будет включена в сгенерированную OpenAPI-схему и использована интерфейсами документации и внешними инструментами.\n\n/// note | Технические детали\n\nПомните, что разные инструменты могут иметь разный уровень поддержки OpenAPI.\n\nНекоторые из них пока могут не показывать всю дополнительную информацию, хотя в большинстве случаев недостающая возможность уже запланирована к разработке.\n\n///\n\nМожно задать `title`:\n\n{* ../../docs_src/query_params_str_validations/tutorial007_an_py310.py hl[10] *}\n\nИ `description`:\n\n{* ../../docs_src/query_params_str_validations/tutorial008_an_py310.py hl[14] *}\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 17, "header": "Больше метаданных", "header_level": 2, "token_count": 238}
{"id": "319fcab941298202", "text": "## Псевдонимы параметров { #alias-parameters }\n\nПредставьте, что вы хотите, чтобы параметр назывался `item-query`.\n\nНапример:\n\n```\nhttp://127.0.0.1:8000/items/?item-query=foobaritems\n```\n\nНо `item-query` — недопустимое имя переменной в Python.\n\nБлижайший вариант — `item_query`.\n\nНо вам всё равно нужно именно `item-query`...\n\nТогда можно объявить `alias`, и этот псевдоним будет использован для поиска значения параметра:\n\n{* ../../docs_src/query_params_str_validations/tutorial009_an_py310.py hl[9] *}\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 18, "header": "Псевдонимы параметров", "header_level": 2, "token_count": 174}
{"id": "291af605c7762d16", "text": "## Маркировка параметров как устаревших { #deprecating-parameters }\n\nПредположим, этот параметр вам больше не нравится.\n\nЕго нужно оставить на какое‑то время, так как клиенты его используют, но вы хотите, чтобы в документации он явно отображался как <abbr title=\"устаревший, не рекомендуется использовать\">устаревший</abbr>.\n\nТогда передайте параметр `deprecated=True` в `Query`:\n\n{* ../../docs_src/query_params_str_validations/tutorial010_an_py310.py hl[19] *}\n\nВ документации это будет показано так:\n\n<img src=\"/img/tutorial/query-params-str-validations/image01.png\">\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 19, "header": "Маркировка параметров как устаревших", "header_level": 2, "token_count": 181}
{"id": "c6b4ee8c9514f7c0", "text": "## Исключить параметры из OpenAPI { #exclude-parameters-from-openapi }\n\nЧтобы исключить query-параметр из генерируемой OpenAPI-схемы (и, следовательно, из систем автоматической документации), укажите у `Query` параметр `include_in_schema=False`:\n\n{* ../../docs_src/query_params_str_validations/tutorial014_an_py310.py hl[10] *}\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 20, "header": "Исключить параметры из OpenAPI", "header_level": 2, "token_count": 103}
{"id": "efac7c34e41d1feb", "text": "## Кастомная валидация { #custom-validation }\n\nБывают случаи, когда нужна **кастомная валидация**, которую нельзя выразить параметрами выше.\n\nВ таких случаях можно использовать **кастомную функцию-валидатор**, которая применяется после обычной валидации (например, после проверки, что значение — это `str`).\n\nЭтого можно добиться, используя <a href=\"https://docs.pydantic.dev/latest/concepts/validators/#field-after-validator\" class=\"external-link\" target=\"_blank\">`AfterValidator` Pydantic</a> внутри `Annotated`.\n\n/// tip | Совет\n\nВ Pydantic также есть <a href=\"https://docs.pydantic.dev/latest/concepts/validators/#field-before-validator\" class=\"external-link\" target=\"_blank\">`BeforeValidator`</a> и другие. \n\n///\n\nНапример, эта кастомная проверка убеждается, что ID элемента начинается с `isbn-` для номера книги <abbr title=\"ISBN означает International Standard Book Number – Международный стандартный книжный номер\">ISBN</abbr> или с `imdb-` для ID URL фильма на <abbr title=\"IMDB (Internet Movie Database) — веб‑сайт с информацией о фильмах\">IMDB</abbr>:\n\n{* ../../docs_src/query_params_str_validations/tutorial015_an_py310.py hl[5,16:19,24] *}\n\n/// info | Дополнительная информация\n\nЭто доступно в Pydantic версии 2 и выше. \n\n///\n\n/// tip | Совет\n\nЕсли вам нужна валидация, требующая общения с каким‑либо **внешним компонентом** — базой данных или другим API — вместо этого используйте **Зависимости FastAPI** (FastAPI Dependencies), вы познакомитесь с ними позже.", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md", "section_header": "Кастомная валидация", "section_header_level": 2}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 21, "header": "Кастомная валидация", "header_level": 2, "token_count": 496}
{"id": "3c0816d62e4b03f9", "text": "им‑либо **внешним компонентом** — базой данных или другим API — вместо этого используйте **Зависимости FastAPI** (FastAPI Dependencies), вы познакомитесь с ними позже.\n\nЭти кастомные валидаторы предназначены для проверок, которые можно выполнить, имея **только** те же **данные**, что пришли в запросе.\n\n///", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md", "section_header": "Кастомная валидация", "section_header_level": 2}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 22, "header": "Кастомная валидация", "header_level": 2, "token_count": 115}
{"id": "8612537e215a866a", "text": "### Понимание этого кода { #understand-that-code }\n\nВажный момент — это использовать **`AfterValidator` с функцией внутри `Annotated`**. Смело пропускайте эту часть. \n\n---\n\nНо если вам любопытен именно этот пример и всё ещё интересно, вот немного подробностей.\n\n#### Строка и `value.startswith()` { #string-with-value-startswith }\n\nЗаметили? Метод строки `value.startswith()` может принимать кортеж — тогда будет проверено каждое значение из кортежа:\n\n{* ../../docs_src/query_params_str_validations/tutorial015_an_py310.py ln[16:19] hl[17] *}\n\n#### Случайный элемент { #a-random-item }\n\nС помощью `data.items()` мы получаем <abbr title=\"Объект, по которому можно итерироваться циклом for, например список, множество и т. п.\">итерируемый объект</abbr> с кортежами, содержащими ключ и значение для каждого элемента словаря.\n\nМы превращаем этот итерируемый объект в обычный `list` через `list(data.items())`.\n\nЗатем с `random.choice()` можно получить **случайное значение** из списка — то есть кортеж вида `(id, name)`. Это будет что‑то вроде `(\"imdb-tt0371724\", \"The Hitchhiker's Guide to the Galaxy\")`.\n\nПосле этого мы **распаковываем** эти два значения кортежа в переменные `id` и `name`.\n\nТак что, если пользователь не передал ID элемента, он всё равно получит случайную рекомендацию.\n\n...и всё это в **одной простой строке**.  Разве не прекрасен Python? \n\n{* ../../docs_src/query_params_str_validations/tutorial015_an_py310.py ln[22:30] hl[29] *}\n\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 23, "header": "Понимание этого кода", "header_level": 3, "token_count": 497}
{"id": "d4d0b1c333418b89", "text": "## Резюме { #recap }\n\nВы можете объявлять дополнительные проверки и метаданные для параметров.\n\nОбщие метаданные и настройки:\n\n* `alias`\n* `title`\n* `description`\n* `deprecated`\n\nПроверки, специфичные для строк:\n\n* `min_length`\n* `max_length`\n* `pattern`\n\nКастомные проверки с использованием `AfterValidator`.\n\nВ этих примерах вы видели, как объявлять проверки для значений типа `str`.\n\nСмотрите следующие главы, чтобы узнать, как объявлять проверки для других типов, например чисел.\n", "metadata": {"title": "Query-параметры и валидация строк", "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "source_mtime": "2026-01-12T17:48:13.456194+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params-str-validations.md"}, "doc_id": "e198938965ec", "source_path": "docs\\tutorial\\query-params-str-validations.md", "title": "Query-параметры и валидация строк", "chunk_index": 24, "header": "Резюме", "header_level": 2, "token_count": 170}
{"id": "36bbae7358fb087c", "text": "# Query-параметры { #query-parameters }\n\nКогда вы объявляете параметры функции, которые не являются параметрами пути, они автоматически интерпретируются как \"query\"-параметры.\n\n{* ../../docs_src/query_params/tutorial001_py39.py hl[9] *}\n\nQuery-параметры представляют из себя набор пар ключ-значение, которые идут после знака `?` в URL-адресе, разделенные символами `&`.\n\nНапример, в этом URL-адресе:\n\n```\nhttp://127.0.0.1:8000/items/?skip=0&limit=10\n```\n\n...параметры запроса такие:\n\n* `skip`: со значением `0`\n* `limit`: со значением `10`\n\nБудучи частью URL-адреса, они \"по умолчанию\" являются строками.\n\nНо когда вы объявляете их с использованием типов Python (в примере выше, как `int`), они конвертируются в указанный тип данных и проходят проверку на соответствие ему.\n\nВсе те же правила, которые применяются к path-параметрам, также применяются и query-параметрам:\n\n* Поддержка от редактора кода (очевидно)\n* <abbr title=\"преобразование строки, полученной из HTTP запроса в Python данные\">\"Парсинг\"</abbr> данных\n* Проверка на соответствие данных (Валидация)\n* Автоматическая документация\n\n", "metadata": {"title": "Query-параметры", "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params.md"}, "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "title": "Query-параметры", "chunk_index": 0, "header": "Query-параметры", "header_level": 1, "token_count": 431}
{"id": "565e2e785f62ad37", "text": "## Значения по умолчанию { #defaults }\n\nПоскольку query-параметры не являются фиксированной частью пути, они могут быть не обязательными и иметь значения по умолчанию.\n\nВ примере выше значения по умолчанию равны `skip=0` и `limit=10`.\n\nТаким образом, результат перехода по URL-адресу:\n\n```\nhttp://127.0.0.1:8000/items/\n```\n\nбудет таким же, как если перейти используя параметры по умолчанию:\n\n```\nhttp://127.0.0.1:8000/items/?skip=0&limit=10\n```\n\nНо если вы введёте, например:\n\n```\nhttp://127.0.0.1:8000/items/?skip=20\n```\n\nЗначения параметров в вашей функции будут:\n\n* `skip=20`: потому что вы установили это в URL-адресе\n* `limit=10`: т.к это было значение по умолчанию\n\n", "metadata": {"title": "Query-параметры", "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params.md"}, "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "title": "Query-параметры", "chunk_index": 1, "header": "Значения по умолчанию", "header_level": 2, "token_count": 275}
{"id": "66c1536f9ff0c82f", "text": "## Необязательные параметры { #optional-parameters }\n\nАналогично, вы можете объявлять необязательные query-параметры, установив их значение по умолчанию, равное `None`:\n\n{* ../../docs_src/query_params/tutorial002_py310.py hl[7] *}\n\nВ этом случае, параметр  `q` будет не обязательным и будет иметь значение `None` по умолчанию.\n\n/// check | Важно\n\nТакже обратите внимание, что **FastAPI** достаточно умён чтобы заметить, что параметр `item_id` является path-параметром, а `q` нет, поэтому, это параметр запроса.\n\n///\n\n", "metadata": {"title": "Query-параметры", "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params.md"}, "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "title": "Query-параметры", "chunk_index": 2, "header": "Необязательные параметры", "header_level": 2, "token_count": 186}
{"id": "f872733e01485296", "text": "## Преобразование типа параметра запроса { #query-parameter-type-conversion }\n\nВы также можете объявлять параметры с типом `bool`, которые будут преобразованы соответственно:\n\n{* ../../docs_src/query_params/tutorial003_py310.py hl[7] *}\n\nВ этом случае, если вы сделаете запрос:\n\n```\nhttp://127.0.0.1:8000/items/foo?short=1\n```\n\nили\n\n```\nhttp://127.0.0.1:8000/items/foo?short=True\n```\n\nили\n\n```\nhttp://127.0.0.1:8000/items/foo?short=true\n```\n\nили\n\n```\nhttp://127.0.0.1:8000/items/foo?short=on\n```\n\nили\n\n```\nhttp://127.0.0.1:8000/items/foo?short=yes\n```\n\nили в любом другом варианте написания (в верхнем регистре, с заглавной буквой, и т.п), внутри вашей функции параметр `short` будет иметь значение `True` типа данных `bool` . В противном случае - `False`.\n\n", "metadata": {"title": "Query-параметры", "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params.md"}, "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "title": "Query-параметры", "chunk_index": 3, "header": "Преобразование типа параметра запроса", "header_level": 2, "token_count": 293}
{"id": "06af80a4af05e0f9", "text": "## Смешивание query-параметров и path-параметров { #multiple-path-and-query-parameters }\n\nВы можете объявлять несколько query-параметров и path-параметров одновременно, **FastAPI** сам разберётся, что чем является.\n\nИ вы не обязаны объявлять их в каком-либо определенном порядке.\n\nОни будут обнаружены по именам:\n\n{* ../../docs_src/query_params/tutorial004_py310.py hl[6,8] *}\n\n", "metadata": {"title": "Query-параметры", "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params.md"}, "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "title": "Query-параметры", "chunk_index": 4, "header": "Смешивание query-параметров и path-параметров", "header_level": 2, "token_count": 135}
{"id": "36bbae7358fb087c", "text": "## Обязательные query-параметры { #required-query-parameters }\n\nКогда вы объявляете значение по умолчанию для параметра, который не является path-параметром (в этом разделе, мы пока что познакомились только с  path-параметрами), то он не является обязательным.\n\nЕсли вы не хотите задавать конкретное значение, но хотите сделать параметр необязательным, вы можете установить значение по умолчанию равным `None`.\n\nНо если вы хотите сделать query-параметр обязательным, вы можете просто не указывать значение по умолчанию:\n\n{* ../../docs_src/query_params/tutorial005_py39.py hl[6:7] *}\n\nЗдесь параметр запроса `needy` является обязательным параметром с типом данных  `str`.\n\nЕсли вы откроете в браузере URL-адрес, например:\n\n```\nhttp://127.0.0.1:8000/items/foo-item\n```\n\n...без добавления обязательного параметра `needy`, вы увидите подобного рода ошибку:\n\n```JSON\n{\n  \"detail\": [\n    {\n      \"type\": \"missing\",\n      \"loc\": [\n        \"query\",\n        \"needy\"\n      ],\n      \"msg\": \"Field required\",\n      \"input\": null\n    }\n  ]\n}\n```\n\nПоскольку `needy` является обязательным параметром, вам необходимо указать его в URL-адресе:\n\n```\nhttp://127.0.0.1:8000/items/foo-item?needy=sooooneedy\n```\n\n...это будет работать:\n\n```JSON\n{\n    \"item_id\": \"foo-item\",\n    \"needy\": \"sooooneedy\"\n}\n```", "metadata": {"title": "Query-параметры", "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params.md", "section_header": "Обязательные query-параметры", "section_header_level": 2}, "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "title": "Query-параметры", "chunk_index": 5, "header": "Обязательные query-параметры", "header_level": 2, "token_count": 464}
{"id": "565e2e785f62ad37", "text": "е:\n\n```\nhttp://127.0.0.1:8000/items/foo-item?needy=sooooneedy\n```\n\n...это будет работать:\n\n```JSON\n{\n    \"item_id\": \"foo-item\",\n    \"needy\": \"sooooneedy\"\n}\n```\n\nКонечно, вы можете определить некоторые параметры как обязательные, некоторые — со значением по умолчанию, а некоторые — полностью необязательные:\n\n{* ../../docs_src/query_params/tutorial006_py310.py hl[8] *}\n\nВ этом примере, у нас есть 3 параметра запроса:\n\n* `needy`, обязательный `str`.\n* `skip`, типа `int` и со значением по умолчанию `0`.\n* `limit`, необязательный `int`.\n\n/// tip | Подсказка\n\nВы можете использовать класс `Enum` также, как ранее применяли его с [Path-параметрами](path-params.md#predefined-values){.internal-link target=_blank}.\n\n///", "metadata": {"title": "Query-параметры", "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\query-params.md", "section_header": "Обязательные query-параметры", "section_header_level": 2}, "doc_id": "2f12fcf787f1", "source_path": "docs\\tutorial\\query-params.md", "title": "Query-параметры", "chunk_index": 6, "header": "Обязательные query-параметры", "header_level": 2, "token_count": 257}
{"id": "bdcac97dc1d4533f", "text": "# Загрузка файлов { #request-files }\n\nИспользуя класс `File`, мы можем позволить клиентам загружать файлы.\n\n/// info | Дополнительная информация\n\nЧтобы получать загруженные файлы, сначала установите <a href=\"https://github.com/Kludex/python-multipart\" class=\"external-link\" target=\"_blank\">`python-multipart`</a>.\n\nУбедитесь, что вы создали [виртуальное окружение](../virtual-environments.md){.internal-link target=_blank}, активировали его, а затем установили пакет, например:\n\n```console\n$ pip install python-multipart\n```\n\nЭто связано с тем, что загружаемые файлы передаются как \"данные формы\".\n\n///\n\n", "metadata": {"title": "Загрузка файлов", "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-files.md"}, "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "title": "Загрузка файлов", "chunk_index": 0, "header": "Загрузка файлов", "header_level": 1, "token_count": 200}
{"id": "c21b0d59580fc1d2", "text": "## Импорт `File` { #import-file }\n\nИмпортируйте `File` и `UploadFile` из модуля `fastapi`:\n\n{* ../../docs_src/request_files/tutorial001_an_py39.py hl[3] *}\n\n", "metadata": {"title": "Загрузка файлов", "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-files.md"}, "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "title": "Загрузка файлов", "chunk_index": 1, "header": "Импорт `File`", "header_level": 2, "token_count": 56}
{"id": "97966221b3e5d52a", "text": "## Определите параметры `File` { #define-file-parameters }\n\nСоздайте параметры `File` так же, как вы это делаете для `Body` или `Form`:\n\n{* ../../docs_src/request_files/tutorial001_an_py39.py hl[9] *}\n\n/// info | Дополнительная информация\n\n`File` - это класс, который наследуется непосредственно от `Form`.\n\nНо помните, что когда вы импортируете `Query`, `Path`, `File` и другие из `fastapi`, на самом деле это функции, которые возвращают специальные классы.\n\n///\n\n/// tip | Подсказка\n\nДля объявления тела файла необходимо использовать `File`, поскольку в противном случае параметры будут интерпретироваться как параметры запроса или параметры тела (JSON).\n\n///\n\nФайлы будут загружены как данные формы.\n\nЕсли вы объявите тип параметра у *функции операции пути* как `bytes`, то **FastAPI** прочитает файл за вас, и вы получите его содержимое в виде `bytes`.\n\nСледует иметь в виду, что все содержимое будет храниться в памяти. Это хорошо подходит для небольших файлов.\n\nОднако возможны случаи, когда использование `UploadFile` может оказаться полезным.\n\n", "metadata": {"title": "Загрузка файлов", "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-files.md"}, "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "title": "Загрузка файлов", "chunk_index": 2, "header": "Определите параметры `File`", "header_level": 2, "token_count": 364}
{"id": "4a8ce45b9cff1c42", "text": "## Параметры файла с `UploadFile` { #file-parameters-with-uploadfile }\n\nОпределите параметр файла с типом `UploadFile`:\n\n{* ../../docs_src/request_files/tutorial001_an_py39.py hl[14] *}\n\nИспользование `UploadFile` имеет ряд преимуществ перед `bytes`:\n\n* Использовать `File()` в значении параметра по умолчанию не обязательно.\n* При этом используется \"буферный\" файл:\n    * Файл, хранящийся в памяти до максимального предела размера, после преодоления которого он будет храниться на диске.\n* Это означает, что он будет хорошо работать с большими файлами, такими как изображения, видео, большие бинарные файлы и т.д., не потребляя при этом всю память.\n* Из загруженного файла можно получить метаданные.\n* Он реализует <a href=\"https://docs.python.org/3/glossary.html#term-file-like-object\" class=\"external-link\" target=\"_blank\">file-like</a> `async` интерфейс.\n* Он предоставляет реальный объект Python <a href=\"https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile\" class=\"external-link\" target=\"_blank\">`SpooledTemporaryFile`</a> который вы можете передать непосредственно другим библиотекам, которые ожидают файл в качестве объекта.\n\n", "metadata": {"title": "Загрузка файлов", "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-files.md"}, "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "title": "Загрузка файлов", "chunk_index": 3, "header": "Параметры файла с `UploadFile`", "header_level": 2, "token_count": 392}
{"id": "bdcac97dc1d4533f", "text": "### `UploadFile` { #uploadfile }\n\n`UploadFile` имеет следующие атрибуты:\n\n* `filename`: Строка `str` с исходным именем файла, который был загружен (например, `myimage.jpg`).\n* `content_type`: Строка `str` с типом содержимого (MIME type / media type) (например, `image/jpeg`).\n* `file`: <a href=\"https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile\" class=\"external-link\" target=\"_blank\">`SpooledTemporaryFile`</a> (a <a href=\"https://docs.python.org/3/glossary.html#term-file-like-object\" class=\"external-link\" target=\"_blank\">file-like</a> объект). Это фактический файл Python, который можно передавать непосредственно другим функциям или библиотекам, ожидающим файл в качестве объекта.\n\n`UploadFile` имеет следующие методы `async`. Все они вызывают соответствующие файловые методы (используя внутренний `SpooledTemporaryFile`).\n\n* `write(data)`: Записать данные `data` (`str` или `bytes`) в файл.\n* `read(size)`: Прочитать количество `size` (`int`) байт/символов из файла.\n* `seek(offset)`: Перейти к байту на позиции `offset` (`int`) в файле.\n    * Например, `await myfile.seek(0)` перейдет к началу файла.\n    * Это особенно удобно, если вы один раз выполнили команду `await myfile.read()`, а затем вам нужно прочитать содержимое файла еще раз.\n* `close()`: Закрыть файл.\n\nПоскольку все эти методы являются `async` методами, вам следует использовать \"await\" вместе с ними.", "metadata": {"title": "Загрузка файлов", "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-files.md", "section_header": "`UploadFile`", "section_header_level": 3}, "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "title": "Загрузка файлов", "chunk_index": 4, "header": "`UploadFile`", "header_level": 3, "token_count": 503}
{"id": "c21b0d59580fc1d2", "text": "но прочитать содержимое файла еще раз.\n* `close()`: Закрыть файл.\n\nПоскольку все эти методы являются `async` методами, вам следует использовать \"await\" вместе с ними.\n\nНапример, внутри `async` *функции операции пути* можно получить содержимое с помощью:\n\n```Python\ncontents = await myfile.read()\n```\n\nЕсли вы находитесь внутри обычной `def` *функции операции пути*, можно получить прямой доступ к файлу `UploadFile.file`, например:\n\n```Python\ncontents = myfile.file.read()\n```\n\n/// note | Технические детали `async`\n\nПри использовании методов `async` **FastAPI** запускает файловые методы в пуле потоков и ожидает их.\n\n///\n\n/// note | Технические детали Starlette\n\n**FastAPI** наследует `UploadFile` непосредственно из **Starlette**, но добавляет некоторые детали для совместимости с **Pydantic** и другими частями FastAPI.\n\n///", "metadata": {"title": "Загрузка файлов", "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-files.md", "section_header": "`UploadFile`", "section_header_level": 3}, "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "title": "Загрузка файлов", "chunk_index": 5, "header": "`UploadFile`", "header_level": 3, "token_count": 300}
{"id": "764a0064ff9111d8", "text": "## Что такое «данные формы» { #what-is-form-data }\n\nСпособ, которым HTML-формы (`<form></form>`) отправляют данные на сервер, обычно использует \"специальную\" кодировку для этих данных, отличную от JSON.\n\n**FastAPI** позаботится о том, чтобы считать эти данные из нужного места, а не из JSON.\n\n/// note | Технические детали\n\nДанные из форм обычно кодируются с использованием \"media type\" `application/x-www-form-urlencoded` когда он не включает файлы.\n\nНо когда форма включает файлы, она кодируется как multipart/form-data. Если вы используете `File`, **FastAPI** будет знать, что ему нужно получить файлы из нужной части тела.\n\nЕсли вы хотите узнать больше об этих кодировках и полях форм, перейдите по ссылке <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST\" class=\"external-link\" target=\"_blank\"><abbr title=\"Mozilla Developer Network – Сеть разработчиков Mozilla\">MDN</abbr> web docs for <code>POST</code></a>.\n\n///\n\n/// warning | Внимание\n\nВ операции *функции операции пути* можно объявить несколько параметров `File` и `Form`, но нельзя также объявлять поля `Body`, которые предполагается получить в виде JSON, поскольку тело запроса будет закодировано с помощью `multipart/form-data`, а не `application/json`.\n\nЭто не является ограничением **FastAPI**, это часть протокола HTTP.\n\n///\n\n", "metadata": {"title": "Загрузка файлов", "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-files.md"}, "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "title": "Загрузка файлов", "chunk_index": 6, "header": "Что такое «данные формы»", "header_level": 2, "token_count": 446}
{"id": "c5f12e1592097905", "text": "## Необязательная загрузка файлов { #optional-file-upload }\n\nВы можете сделать загрузку файла необязательной, используя стандартные аннотации типов и установив значение по умолчанию `None`:\n\n{* ../../docs_src/request_files/tutorial001_02_an_py310.py hl[9,17] *}\n\n", "metadata": {"title": "Загрузка файлов", "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-files.md"}, "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "title": "Загрузка файлов", "chunk_index": 7, "header": "Необязательная загрузка файлов", "header_level": 2, "token_count": 84}
{"id": "d4b3d2459408cf72", "text": "## `UploadFile` с дополнительными метаданными { #uploadfile-with-additional-metadata }\n\nВы также можете использовать `File()` вместе с `UploadFile`, например, для установки дополнительных метаданных:\n\n{* ../../docs_src/request_files/tutorial001_03_an_py39.py hl[9,15] *}\n\n", "metadata": {"title": "Загрузка файлов", "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-files.md"}, "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "title": "Загрузка файлов", "chunk_index": 8, "header": "`UploadFile` с дополнительными метаданными", "header_level": 2, "token_count": 85}
{"id": "576113ee37fcfa31", "text": "## Загрузка нескольких файлов { #multiple-file-uploads }\n\nМожно одновременно загружать несколько файлов.\n\nОни будут связаны с одним и тем же \"полем формы\", отправляемым с помощью данных формы.\n\nДля этого необходимо объявить список `bytes` или `UploadFile`:\n\n{* ../../docs_src/request_files/tutorial002_an_py39.py hl[10,15] *}\n\nВы получите, как и было объявлено, список `list` из `bytes` или `UploadFile`.\n\n/// note | Технические детали\n\nМожно также использовать `from starlette.responses import HTMLResponse`.\n\n**FastAPI** предоставляет тот же `starlette.responses`, что и `fastapi.responses`, просто для удобства разработчика. Однако большинство доступных ответов поступает непосредственно из Starlette.\n\n///\n\n", "metadata": {"title": "Загрузка файлов", "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-files.md"}, "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "title": "Загрузка файлов", "chunk_index": 9, "header": "Загрузка нескольких файлов", "header_level": 2, "token_count": 238}
{"id": "6866b531c653c70f", "text": "### Загрузка нескольких файлов с дополнительными метаданными { #multiple-file-uploads-with-additional-metadata }\n\nТак же, как и раньше, вы можете использовать `File()` для задания дополнительных параметров, даже для `UploadFile`:\n\n{* ../../docs_src/request_files/tutorial003_an_py39.py hl[11,18:20] *}\n\n", "metadata": {"title": "Загрузка файлов", "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-files.md"}, "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "title": "Загрузка файлов", "chunk_index": 10, "header": "Загрузка нескольких файлов с дополнительными метаданными", "header_level": 3, "token_count": 96}
{"id": "d288b60cd481f114", "text": "## Резюме { #recap }\n\nИспользуйте `File`, `bytes` и `UploadFile` для работы с файлами, которые будут загружаться и передаваться в виде данных формы.\n", "metadata": {"title": "Загрузка файлов", "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "source_mtime": "2026-01-12T17:48:13.467776+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-files.md"}, "doc_id": "ab8c29545d81", "source_path": "docs\\tutorial\\request-files.md", "title": "Загрузка файлов", "chunk_index": 11, "header": "Резюме", "header_level": 2, "token_count": 52}
{"id": "1783c6161957a1ed", "text": "# Модели форм { #form-models }\n\nВы можете использовать **Pydantic-модели** для объявления **полей формы** в FastAPI.\n\n/// info | Дополнительная информация\n\nЧтобы использовать формы, сначала установите <a href=\"https://github.com/Kludex/python-multipart\" class=\"external-link\" target=\"_blank\">`python-multipart`</a>.\n\nУбедитесь, что вы создали и активировали [виртуальное окружение](../virtual-environments.md){.internal-link target=_blank}, а затем установите пакет, например:\n\n```console\n$ pip install python-multipart\n```\n\n///\n\n/// note | Заметка\n\nЭтот функционал доступен начиная с версии FastAPI `0.113.0`. \n\n///\n\n", "metadata": {"title": "Модели форм", "doc_id": "ad3558e0e713", "source_path": "docs\\tutorial\\request-form-models.md", "source_mtime": "2026-01-12T17:48:13.482745+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-form-models.md"}, "doc_id": "ad3558e0e713", "source_path": "docs\\tutorial\\request-form-models.md", "title": "Модели форм", "chunk_index": 0, "header": "Модели форм", "header_level": 1, "token_count": 200}
{"id": "b9730501034fe922", "text": "## Pydantic-модели для форм { #pydantic-models-for-forms }\n\nВам просто нужно объявить **Pydantic-модель** с полями, которые вы хотите получить как **поля формы**, а затем объявить параметр как `Form`:\n\n{* ../../docs_src/request_form_models/tutorial001_an_py39.py hl[9:11,15] *}\n\n**FastAPI** **извлечёт** данные для **каждого поля** из **данных формы** в запросе и выдаст вам объявленную Pydantic-модель.\n\n", "metadata": {"title": "Модели форм", "doc_id": "ad3558e0e713", "source_path": "docs\\tutorial\\request-form-models.md", "source_mtime": "2026-01-12T17:48:13.482745+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-form-models.md"}, "doc_id": "ad3558e0e713", "source_path": "docs\\tutorial\\request-form-models.md", "title": "Модели форм", "chunk_index": 1, "header": "Pydantic-модели для форм", "header_level": 2, "token_count": 147}
{"id": "3d5c47054093b181", "text": "## Проверьте документацию { #check-the-docs }\n\nВы можете проверить это в интерфейсе документации по адресу `/docs`:\n\n<div class=\"screenshot\">\n<img src=\"/img/tutorial/request-form-models/image01.png\">\n</div>\n\n", "metadata": {"title": "Модели форм", "doc_id": "ad3558e0e713", "source_path": "docs\\tutorial\\request-form-models.md", "source_mtime": "2026-01-12T17:48:13.482745+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-form-models.md"}, "doc_id": "ad3558e0e713", "source_path": "docs\\tutorial\\request-form-models.md", "title": "Модели форм", "chunk_index": 2, "header": "Проверьте документацию", "header_level": 2, "token_count": 60}
{"id": "74dcfb6595bd4e53", "text": "## Запрет дополнительных полей формы { #forbid-extra-form-fields }\n\nВ некоторых случаях (не особо часто встречающихся) вам может понадобиться **ограничить** поля формы только теми, которые объявлены в Pydantic-модели. И **запретить** любые **дополнительные** поля.\n\n/// note | Заметка\n\nЭтот функционал доступен начиная с версии FastAPI `0.114.0`. \n\n///\n\nВы можете сконфигурировать Pydantic-модель так, чтобы запретить (`forbid`) все дополнительные (`extra`) поля:\n\n{* ../../docs_src/request_form_models/tutorial002_an_py39.py hl[12] *}\n\nЕсли клиент попробует отправить дополнительные данные, то в ответ он получит **ошибку**.\n\nНапример, если клиент попытается отправить поля формы:\n\n* `username`: `Rick`\n* `password`: `Portal Gun`\n* `extra`: `Mr. Poopybutthole`\n\nТо в ответ он получит **ошибку**, сообщающую ему, что поле `extra` не разрешено:\n\n```json\n{\n    \"detail\": [\n        {\n            \"type\": \"extra_forbidden\",\n            \"loc\": [\"body\", \"extra\"],\n            \"msg\": \"Extra inputs are not permitted\",\n            \"input\": \"Mr. Poopybutthole\"\n        }\n    ]\n}\n```\n\n", "metadata": {"title": "Модели форм", "doc_id": "ad3558e0e713", "source_path": "docs\\tutorial\\request-form-models.md", "source_mtime": "2026-01-12T17:48:13.482745+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-form-models.md"}, "doc_id": "ad3558e0e713", "source_path": "docs\\tutorial\\request-form-models.md", "title": "Модели форм", "chunk_index": 3, "header": "Запрет дополнительных полей формы", "header_level": 2, "token_count": 368}
{"id": "2b2c150ce0891581", "text": "## Итоги { #summary }\n\nВы можете использовать Pydantic-модели для объявления полей форм в FastAPI.\n", "metadata": {"title": "Модели форм", "doc_id": "ad3558e0e713", "source_path": "docs\\tutorial\\request-form-models.md", "source_mtime": "2026-01-12T17:48:13.482745+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-form-models.md"}, "doc_id": "ad3558e0e713", "source_path": "docs\\tutorial\\request-form-models.md", "title": "Модели форм", "chunk_index": 4, "header": "Итоги", "header_level": 2, "token_count": 33}
{"id": "a49aee406fc2d2e2", "text": "# Файлы и формы в запросе { #request-forms-and-files }\n\nВы можете определять файлы и поля формы одновременно, используя `File` и `Form`.\n\n/// info | Информация\n\nЧтобы получать загруженные файлы и/или данные форм, сначала установите <a href=\"https://github.com/Kludex/python-multipart\" class=\"external-link\" target=\"_blank\">`python-multipart`</a>.\n\nУбедитесь, что вы создали [виртуальное окружение](../virtual-environments.md){.internal-link target=_blank}, активировали его, а затем установили пакет, например:\n\n```console\n$ pip install python-multipart\n```\n\n///\n\n", "metadata": {"title": "Файлы и формы в запросе", "doc_id": "32e8e4e6dd68", "source_path": "docs\\tutorial\\request-forms-and-files.md", "source_mtime": "2026-01-12T17:48:13.488576+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-forms-and-files.md"}, "doc_id": "32e8e4e6dd68", "source_path": "docs\\tutorial\\request-forms-and-files.md", "title": "Файлы и формы в запросе", "chunk_index": 0, "header": "Файлы и формы в запросе", "header_level": 1, "token_count": 183}
{"id": "72c0233dd0ffd46a", "text": "## Импортируйте `File` и `Form` { #import-file-and-form }\n\n{* ../../docs_src/request_forms_and_files/tutorial001_an_py39.py hl[3] *}\n\n", "metadata": {"title": "Файлы и формы в запросе", "doc_id": "32e8e4e6dd68", "source_path": "docs\\tutorial\\request-forms-and-files.md", "source_mtime": "2026-01-12T17:48:13.488576+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-forms-and-files.md"}, "doc_id": "32e8e4e6dd68", "source_path": "docs\\tutorial\\request-forms-and-files.md", "title": "Файлы и формы в запросе", "chunk_index": 1, "header": "Импортируйте `File` и `Form`", "header_level": 2, "token_count": 42}
{"id": "4fde897e4e2755ca", "text": "## Определите параметры `File` и `Form` { #define-file-and-form-parameters }\n\nСоздайте параметры файла и формы таким же образом, как для `Body` или `Query`:\n\n{* ../../docs_src/request_forms_and_files/tutorial001_an_py39.py hl[10:12] *}\n\nФайлы и поля формы будут загружены в виде данных формы, и вы получите файлы и поля формы.\n\nВы можете объявить некоторые файлы как `bytes`, а некоторые — как `UploadFile`.\n\n/// warning | Внимание\n\nВы можете объявить несколько параметров `File` и `Form` в операции пути, но вы не можете также объявить поля `Body`, которые вы ожидаете получить в виде JSON, так как запрос будет иметь тело, закодированное с помощью `multipart/form-data` вместо `application/json`.\n\nЭто не ограничение **FastAPI**, это часть протокола HTTP.\n\n///\n\n", "metadata": {"title": "Файлы и формы в запросе", "doc_id": "32e8e4e6dd68", "source_path": "docs\\tutorial\\request-forms-and-files.md", "source_mtime": "2026-01-12T17:48:13.488576+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-forms-and-files.md"}, "doc_id": "32e8e4e6dd68", "source_path": "docs\\tutorial\\request-forms-and-files.md", "title": "Файлы и формы в запросе", "chunk_index": 2, "header": "Определите параметры `File` и `Form`", "header_level": 2, "token_count": 255}
{"id": "3b804457952f69bb", "text": "## Резюме { #recap }\n\nИспользуйте `File` и `Form` вместе, когда необходимо получить данные и файлы в одном запросе.\n", "metadata": {"title": "Файлы и формы в запросе", "doc_id": "32e8e4e6dd68", "source_path": "docs\\tutorial\\request-forms-and-files.md", "source_mtime": "2026-01-12T17:48:13.488576+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-forms-and-files.md"}, "doc_id": "32e8e4e6dd68", "source_path": "docs\\tutorial\\request-forms-and-files.md", "title": "Файлы и формы в запросе", "chunk_index": 3, "header": "Резюме", "header_level": 2, "token_count": 46}
{"id": "4b19193e8a48145b", "text": "# Данные формы { #form-data }\n\nКогда вам нужно получить поля формы вместо JSON, вы можете использовать `Form`.\n\n/// info | Дополнительная информация\n\nЧтобы использовать формы, сначала установите <a href=\"https://github.com/Kludex/python-multipart\" class=\"external-link\" target=\"_blank\">`python-multipart`</a>.\n\nУбедитесь, что вы создали [виртуальное окружение](../virtual-environments.md){.internal-link target=_blank}, активировали его, а затем установили пакет, например:\n\n```console\n$ pip install python-multipart\n```\n\n///\n\n", "metadata": {"title": "Данные формы", "doc_id": "8a8a0760ea71", "source_path": "docs\\tutorial\\request-forms.md", "source_mtime": "2026-01-12T17:48:13.496682+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-forms.md"}, "doc_id": "8a8a0760ea71", "source_path": "docs\\tutorial\\request-forms.md", "title": "Данные формы", "chunk_index": 0, "header": "Данные формы", "header_level": 1, "token_count": 164}
{"id": "45f0e264e93e8846", "text": "## Импорт `Form` { #import-form }\n\nИмпортируйте `Form` из `fastapi`:\n\n{* ../../docs_src/request_forms/tutorial001_an_py39.py hl[3] *}\n\n", "metadata": {"title": "Данные формы", "doc_id": "8a8a0760ea71", "source_path": "docs\\tutorial\\request-forms.md", "source_mtime": "2026-01-12T17:48:13.496682+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-forms.md"}, "doc_id": "8a8a0760ea71", "source_path": "docs\\tutorial\\request-forms.md", "title": "Данные формы", "chunk_index": 1, "header": "Импорт `Form`", "header_level": 2, "token_count": 48}
{"id": "6072d2694cbfa884", "text": "## Определение параметров `Form` { #define-form-parameters }\n\nСоздайте параметры формы так же, как это делается для `Body` или `Query`:\n\n{* ../../docs_src/request_forms/tutorial001_an_py39.py hl[9] *}\n\nНапример, в одном из способов использования спецификации OAuth2 (называемом «потоком пароля») требуется отправить `username` и `password` в виде полей формы.\n\n<abbr title=\"specification – спецификация\">spec</abbr> требует, чтобы поля были строго названы `username` и `password` и отправлялись как поля формы, а не JSON.\n\nС помощью `Form` вы можете объявить те же настройки, что и с `Body` (и `Query`, `Path`, `Cookie`), включая валидацию, примеры, псевдоним (например, `user-name` вместо `username`) и т.д.\n\n/// info | Дополнительная информация\n\n`Form` — это класс, который наследуется непосредственно от `Body`.\n\n///\n\n/// tip | Подсказка\n\nЧтобы объявлять данные формы, вам нужно явно использовать `Form`, иначе параметры будут интерпретированы как параметры запроса или параметры тела (JSON).\n\n///\n\n", "metadata": {"title": "Данные формы", "doc_id": "8a8a0760ea71", "source_path": "docs\\tutorial\\request-forms.md", "source_mtime": "2026-01-12T17:48:13.496682+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-forms.md"}, "doc_id": "8a8a0760ea71", "source_path": "docs\\tutorial\\request-forms.md", "title": "Данные формы", "chunk_index": 2, "header": "Определение параметров `Form`", "header_level": 2, "token_count": 350}
{"id": "30dc7c7082a6ea04", "text": "## О «полях формы» { #about-form-fields }\n\nОбычно способ, которым HTML-формы (`<form></form>`) отправляют данные на сервер, использует «специальное» кодирование для этих данных, отличное от JSON.\n\n**FastAPI** гарантирует, что эти данные будут прочитаны из нужного места, а не из JSON.\n\n/// note | Технические детали\n\nДанные из форм обычно кодируются с использованием «типа содержимого» `application/x-www-form-urlencoded`.\n\nНо когда форма содержит файлы, она кодируется как `multipart/form-data`. О работе с файлами вы прочтёте в следующей главе.\n\nЕсли вы хотите узнать больше про эти кодировки и поля формы, обратитесь к <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST\" class=\"external-link\" target=\"_blank\"><abbr title=\"Mozilla Developer Network – Сеть разработчиков Mozilla\">MDN</abbr> веб-документации для `POST`</a>.\n\n///\n\n/// warning | Предупреждение\n\nВы можете объявлять несколько параметров `Form` в *операции пути*, но вы не можете одновременно объявлять поля `Body`, которые вы ожидаете получить в виде JSON, так как запрос будет иметь тело, закодированное с использованием `application/x-www-form-urlencoded`, а не `application/json`.\n\nЭто не ограничение **FastAPI**, это часть протокола HTTP.\n\n///\n\n", "metadata": {"title": "Данные формы", "doc_id": "8a8a0760ea71", "source_path": "docs\\tutorial\\request-forms.md", "source_mtime": "2026-01-12T17:48:13.496682+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-forms.md"}, "doc_id": "8a8a0760ea71", "source_path": "docs\\tutorial\\request-forms.md", "title": "Данные формы", "chunk_index": 3, "header": "О «полях формы»", "header_level": 2, "token_count": 415}
{"id": "7b266a647c51475d", "text": "## Резюме { #recap }\n\nИспользуйте `Form` для объявления входных параметров данных формы.\n", "metadata": {"title": "Данные формы", "doc_id": "8a8a0760ea71", "source_path": "docs\\tutorial\\request-forms.md", "source_mtime": "2026-01-12T17:48:13.496682+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\request-forms.md"}, "doc_id": "8a8a0760ea71", "source_path": "docs\\tutorial\\request-forms.md", "title": "Данные формы", "chunk_index": 4, "header": "Резюме", "header_level": 2, "token_count": 33}
{"id": "4277b562736440db", "text": "# Модель ответа — Возвращаемый тип { #response-model-return-type }\n\nВы можете объявить тип, используемый для ответа, указав аннотацию **возвращаемого значения** для *функции-обработчика пути*.\n\nВы можете использовать **аннотации типов** так же, как и для входных данных в **параметрах** функции: Pydantic-модели, списки, словари, скалярные значения (целые числа, булевы и т.д.).\n\n{* ../../docs_src/response_model/tutorial001_01_py310.py hl[16,21] *}\n\nFastAPI будет использовать этот тип ответа для:\n\n* **Валидации** возвращаемых данных.\n    * Если данные невалидны (например, отсутствует поле), это означает, что код *вашего* приложения работает некорректно и возвращает не то, что должен. В таком случае будет возвращена ошибка сервера вместо неправильных данных. Так вы и ваши клиенты можете быть уверены, что получите ожидаемые данные и ожидаемую структуру.\n* Добавления **JSON Schema** для ответа в OpenAPI *операции пути*.\n    * Это будет использовано **автоматической документацией**.\n    * Это также будет использовано инструментами автоматической генерации клиентского кода.\n\nНо самое главное:\n\n* Выходные данные будут **ограничены и отфильтрованы** в соответствии с тем, что определено в возвращаемом типе.\n    * Это особенно важно для **безопасности**, ниже мы рассмотрим это подробнее.\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 0, "header": "Модель ответа — Возвращаемый тип", "header_level": 1, "token_count": 464}
{"id": "4277b562736440db", "text": "## Параметр `response_model` { #response-model-parameter }\n\nБывают случаи, когда вам нужно или хочется возвращать данные, которые не в точности соответствуют объявленному типу.\n\nНапример, вы можете хотеть **возвращать словарь (dict)** или объект из базы данных, но **объявить его как Pydantic-модель**. Тогда Pydantic-модель выполнит документирование данных, валидацию и т.п. для объекта, который вы вернули (например, словаря или объекта из базы данных).\n\nЕсли вы добавите аннотацию возвращаемого типа, инструменты и редакторы кода начнут жаловаться (и будут правы), что функция возвращает тип (например, dict), отличный от объявленного (например, Pydantic-модель).\n\nВ таких случаях вместо аннотации возвращаемого типа можно использовать параметр `response_model` у *декоратора операции пути*.\n\nПараметр `response_model` можно указать у любой *операции пути*:\n\n* `@app.get()`\n* `@app.post()`\n* `@app.put()`\n* `@app.delete()`\n* и т.д.\n\n{* ../../docs_src/response_model/tutorial001_py310.py hl[17,22,24:27] *}\n\n/// note | Примечание\n\nОбратите внимание, что `response_model` — это параметр метода «декоратора» (`get`, `post` и т.д.), а не вашей *функции-обработчика пути*, в которой указываются параметры и тело запроса.\n\n///", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md", "section_header": "Параметр `response_model`", "section_header_level": 2}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 1, "header": "Параметр `response_model`", "header_level": 2, "token_count": 446}
{"id": "81496accb49f70b1", "text": "что `response_model` — это параметр метода «декоратора» (`get`, `post` и т.д.), а не вашей *функции-обработчика пути*, в которой указываются параметры и тело запроса.\n\n///\n\n`response_model` принимает тот же тип, что вы бы объявили для поля Pydantic-модели, то есть это может быть одна Pydantic-модель, а может быть, например, `list` Pydantic-моделей, как `List[Item]`.\n\nFastAPI будет использовать `response_model` для документации, валидации и т. п., а также для **конвертации и фильтрации выходных данных** к объявленному типу.\n\n/// tip | Совет\n\nЕсли у вас в редакторе кода, mypy и т. п. включены строгие проверки типов, вы можете объявить возвращаемый тип функции как `Any`.\n\nТак вы сообщите редактору, что намеренно возвращаете что угодно. Но FastAPI всё равно выполнит документацию данных, валидацию, фильтрацию и т.д. с помощью `response_model`.\n\n///", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md", "section_header": "Параметр `response_model`", "section_header_level": 2}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 2, "header": "Параметр `response_model`", "header_level": 2, "token_count": 317}
{"id": "d3cd67755a12bc3a", "text": "### Приоритет `response_model` { #response-model-priority }\n\nЕсли вы объявите и возвращаемый тип, и `response_model`, приоритет будет у `response_model`, именно его использует FastAPI.\n\nТак вы можете добавить корректные аннотации типов к своим функциям, даже если фактически возвращаете тип, отличный от модели ответа, чтобы ими пользовались редактор и инструменты вроде mypy. И при этом FastAPI продолжит выполнять валидацию данных, документацию и т.д. с использованием `response_model`.\n\nВы также можете указать `response_model=None`, чтобы отключить создание модели ответа для данной *операции пути*. Это может понадобиться, если вы добавляете аннотации типов для вещей, не являющихся валидными полями Pydantic. Пример вы увидите ниже.\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 3, "header": "Приоритет `response_model`", "header_level": 3, "token_count": 256}
{"id": "e785b1b75c192b53", "text": "## Вернуть те же входные данные { #return-the-same-input-data }\n\nЗдесь мы объявляем модель `UserIn`, она будет содержать пароль в открытом виде:\n\n{* ../../docs_src/response_model/tutorial002_py310.py hl[7,9] *}\n\n/// info | Информация\n\nЧтобы использовать `EmailStr`, сначала установите <a href=\"https://github.com/JoshData/python-email-validator\" class=\"external-link\" target=\"_blank\">`email-validator`</a>.\n\nСоздайте [виртуальное окружение](../virtual-environments.md){.internal-link target=_blank}, активируйте его и затем установите пакет, например:\n\n```console\n$ pip install email-validator\n```\n\nили так:\n\n```console\n$ pip install \"pydantic[email]\"\n```\n\n///\n\nИ мы используем эту модель для объявления входных данных, и ту же модель — для объявления выходных данных:\n\n{* ../../docs_src/response_model/tutorial002_py310.py hl[16] *}\n\nТеперь, когда браузер создаёт пользователя с паролем, API вернёт тот же пароль в ответе.\n\nВ этом случае это может быть не проблемой, так как пароль отправляет тот же пользователь.\n\nНо если мы используем ту же модель в другой *операции пути*, мы можем начать отправлять пароли пользователей каждому клиенту.\n\n/// danger | Осторожно\n\nНикогда не храните пароль пользователя в открытом виде и не отправляйте его в ответе подобным образом, если только вы не понимаете всех рисков и точно знаете, что делаете.\n\n///\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 4, "header": "Вернуть те же входные данные", "header_level": 2, "token_count": 437}
{"id": "6752ca2dcf3a7216", "text": "## Добавить модель для ответа { #add-an-output-model }\n\nВместо этого мы можем создать входную модель с паролем в открытом виде и выходную модель без него:\n\n{* ../../docs_src/response_model/tutorial003_py310.py hl[9,11,16] *}\n\nЗдесь, хотя *функция-обработчик пути* возвращает тот же входной объект пользователя, содержащий пароль:\n\n{* ../../docs_src/response_model/tutorial003_py310.py hl[24] *}\n\n...мы объявили `response_model` как модель `UserOut`, в которой нет пароля:\n\n{* ../../docs_src/response_model/tutorial003_py310.py hl[22] *}\n\nТаким образом, **FastAPI** позаботится о том, чтобы отфильтровать все данные, не объявленные в выходной модели (используя Pydantic).\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 5, "header": "Добавить модель для ответа", "header_level": 2, "token_count": 221}
{"id": "d8d39036cab35c4e", "text": "### `response_model` или возвращаемый тип { #response-model-or-return-type }\n\nВ этом случае, поскольку две модели различаются, если бы мы аннотировали возвращаемый тип функции как `UserOut`, редактор и инструменты пожаловались бы, что мы возвращаем неверный тип, так как это разные классы.\n\nПоэтому в этом примере мы должны объявить тип ответа в параметре `response_model`.\n\n...но читайте дальше, чтобы узнать, как это обойти.\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 6, "header": "`response_model` или возвращаемый тип", "header_level": 3, "token_count": 149}
{"id": "d600227afae6dd19", "text": "## Возвращаемый тип и фильтрация данных { #return-type-and-data-filtering }\n\nПродолжим предыдущий пример. Мы хотели **аннотировать функцию одним типом**, но при этом иметь возможность вернуть из функции что-то, что фактически включает **больше данных**.\n\nМы хотим, чтобы FastAPI продолжал **фильтровать** данные с помощью модели ответа. Так что, даже если функция возвращает больше данных, в ответ будут включены только поля, объявленные в модели ответа.\n\nВ предыдущем примере, поскольку классы были разными, нам пришлось использовать параметр `response_model`. Но это также означает, что мы теряем поддержку от редактора и инструментов, проверяющих возвращаемый тип функции.\n\nОднако в большинстве таких случаев нам нужно лишь **отфильтровать/убрать** некоторые данные, как в этом примере.\n\nИ в этих случаях мы можем использовать классы и наследование, чтобы воспользоваться **аннотациями типов** функций для лучшей поддержки в редакторе и инструментах и при этом получить **фильтрацию данных** от FastAPI.\n\n{* ../../docs_src/response_model/tutorial003_01_py310.py hl[7:10,13:14,18] *}\n\nТак мы получаем поддержку инструментов (редакторы, mypy) — код корректен с точки зрения типов — и одновременно получаем фильтрацию данных от FastAPI.\n\nКак это работает? Давайте разберёмся. \n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 7, "header": "Возвращаемый тип и фильтрация данных", "header_level": 2, "token_count": 465}
{"id": "1e6cfc9e71af960f", "text": "### Аннотации типов и инструменты { #type-annotations-and-tooling }\n\nСначала посмотрим, как это увидят редакторы, mypy и другие инструменты.\n\n`BaseUser` содержит базовые поля. Затем `UserIn` наследуется от `BaseUser` и добавляет поле `password`, то есть он включает все поля обеих моделей.\n\nМы аннотируем возвращаемый тип функции как `BaseUser`, но фактически возвращаем экземпляр `UserIn`.\n\nРедактор, mypy и другие инструменты не будут возражать, потому что с точки зрения типов `UserIn` — подкласс `BaseUser`, что означает, что это *валидный* тип везде, где ожидается что-то, являющееся `BaseUser`.\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 8, "header": "Аннотации типов и инструменты", "header_level": 3, "token_count": 232}
{"id": "7540bf13d2e2706b", "text": "### Фильтрация данных FastAPI { #fastapi-data-filtering }\n\nТеперь, для FastAPI: он увидит возвращаемый тип и убедится, что то, что вы возвращаете, включает **только** поля, объявленные в этом типе.\n\nFastAPI делает несколько вещей внутри вместе с Pydantic, чтобы гарантировать, что те же правила наследования классов не используются для фильтрации возвращаемых данных, иначе вы могли бы вернуть гораздо больше данных, чем ожидали.\n\nТаким образом вы получаете лучшее из обоих миров: аннотации типов с **поддержкой инструментов** и **фильтрацию данных**.\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 9, "header": "Фильтрация данных FastAPI", "header_level": 3, "token_count": 214}
{"id": "d0d6078b78c1419d", "text": "## Посмотреть в документации { #see-it-in-the-docs }\n\nВ автоматической документации вы увидите, что у входной и выходной моделей есть свои JSON Schema:\n\n<img src=\"/img/tutorial/response-model/image01.png\">\n\nИ обе модели используются в интерактивной документации API:\n\n<img src=\"/img/tutorial/response-model/image02.png\">\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 10, "header": "Посмотреть в документации", "header_level": 2, "token_count": 95}
{"id": "490af7f55468f65d", "text": "## Другие аннотации возвращаемых типов { #other-return-type-annotations }\n\nБывают случаи, когда вы возвращаете что-то, что не является валидным полем Pydantic, и аннотируете это в функции только ради поддержки инструментов (редактор, mypy и т. д.).\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 11, "header": "Другие аннотации возвращаемых типов", "header_level": 2, "token_count": 97}
{"id": "a337519613a18272", "text": "### Возврат Response напрямую { #return-a-response-directly }\n\nСамый распространённый случай — [возвращать Response напрямую, как описано далее в разделах для продвинутых](../advanced/response-directly.md){.internal-link target=_blank}.\n\n{* ../../docs_src/response_model/tutorial003_02_py39.py hl[8,10:11] *}\n\nЭтот простой случай обрабатывается FastAPI автоматически, потому что аннотация возвращаемого типа — это класс (или подкласс) `Response`.\n\nИ инструменты тоже будут довольны, потому что и `RedirectResponse`, и `JSONResponse` являются подклассами `Response`, так что аннотация типа корректна.\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 12, "header": "Возврат Response напрямую", "header_level": 3, "token_count": 206}
{"id": "18513a7b2be1b647", "text": "### Аннотировать подкласс Response { #annotate-a-response-subclass }\n\nВы также можете использовать подкласс `Response` в аннотации типа:\n\n{* ../../docs_src/response_model/tutorial003_03_py39.py hl[8:9] *}\n\nЭто тоже сработает, так как `RedirectResponse` — подкласс `Response`, и FastAPI автоматически обработает этот случай.\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 13, "header": "Аннотировать подкласс Response", "header_level": 3, "token_count": 102}
{"id": "a24d424a248f51d8", "text": "### Некорректные аннотации возвращаемых типов { #invalid-return-type-annotations }\n\nНо когда вы возвращаете произвольный объект, не являющийся валидным типом Pydantic (например, объект базы данных), и аннотируете его таким образом в функции, FastAPI попытается создать модель ответа Pydantic из этой аннотации типа и потерпит неудачу.\n\nТо же произойдёт, если у вас будет что-то вроде <abbr title='Объединение нескольких типов означает «любой из этих типов».'>union</abbr> разных типов, где один или несколько не являются валидными типами Pydantic, например, это приведёт к ошибке :\n\n{* ../../docs_src/response_model/tutorial003_04_py310.py hl[8] *}\n\n...это не сработает, потому что аннотация типа не является типом Pydantic и это не единственный класс `Response` или его подкласс, а объединение (`union`) из `Response` и `dict`.\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 14, "header": "Некорректные аннотации возвращаемых типов", "header_level": 3, "token_count": 310}
{"id": "81cfe6bbb3a761e1", "text": "### Отключить модель ответа { #disable-response-model }\n\nПродолжая пример выше, вы можете не хотеть использовать стандартную валидацию данных, документацию, фильтрацию и т.д., выполняемые FastAPI.\n\nНо при этом вы можете хотеть сохранить аннотацию возвращаемого типа в функции, чтобы пользоваться поддержкой инструментов (редакторы, проверки типов вроде mypy).\n\nВ этом случае вы можете отключить генерацию модели ответа, установив `response_model=None`:\n\n{* ../../docs_src/response_model/tutorial003_05_py310.py hl[7] *}\n\nТак FastAPI пропустит генерацию модели ответа, и вы сможете использовать любые аннотации возвращаемых типов, не влияя на ваше приложение FastAPI. \n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 15, "header": "Отключить модель ответа", "header_level": 3, "token_count": 235}
{"id": "271aab231ff416cc", "text": "## Параметры кодирования модели ответа { #response-model-encoding-parameters }\n\nУ вашей модели ответа могут быть значения по умолчанию, например:\n\n{* ../../docs_src/response_model/tutorial004_py310.py hl[9,11:12] *}\n\n* `description: Union[str, None] = None` (или `str | None = None` в Python 3.10) имеет значение по умолчанию `None`.\n* `tax: float = 10.5` имеет значение по умолчанию `10.5`.\n* `tags: List[str] = []` имеет значение по умолчанию пустого списка: `[]`.\n\nно вы можете захотеть опустить их в результате, если они фактически не были сохранены.\n\nНапример, если у вас есть модели с множеством необязательных атрибутов в NoSQL-базе данных, но вы не хотите отправлять очень длинные JSON-ответы, заполненные значениями по умолчанию.\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 16, "header": "Параметры кодирования модели ответа", "header_level": 2, "token_count": 265}
{"id": "4277b562736440db", "text": "### Используйте параметр `response_model_exclude_unset` { #use-the-response-model-exclude-unset-parameter }\n\nВы можете установить у *декоратора операции пути* параметр `response_model_exclude_unset=True`:\n\n{* ../../docs_src/response_model/tutorial004_py310.py hl[22] *}\n\nи эти значения по умолчанию не будут включены в ответ — только те значения, которые действительно были установлены.\n\nИтак, если вы отправите запрос к этой *операции пути* для элемента с ID `foo`, ответ (без значений по умолчанию) будет таким:\n\n```JSON\n{\n    \"name\": \"Foo\",\n    \"price\": 50.2\n}\n```\n\n/// info | Информация\n\nВ Pydantic v1 метод назывался `.dict()`, в Pydantic v2 он был помечен как устаревший (но всё ещё поддерживается) и переименован в `.model_dump()`.\n\nПримеры здесь используют `.dict()` для совместимости с Pydantic v1, но если вы используете Pydantic v2, применяйте `.model_dump()`.\n\n///\n\n/// info | Информация\n\nFastAPI использует метод `.dict()` у Pydantic-моделей с <a href=\"https://docs.pydantic.dev/1.10/usage/exporting_models/#modeldict\" class=\"external-link\" target=\"_blank\">параметром `exclude_unset`</a>, чтобы добиться такого поведения.\n\n///\n\n/// info | Информация\n\nВы также можете использовать:\n\n* `response_model_exclude_defaults=True`\n* `response_model_exclude_none=True`\n\nкак описано в <a href=\"https://docs.pydantic.dev/1.10/usage/exporting_models/#modeldict\" class=\"external-link\" target=\"_blank\">документации Pydantic</a> для `exclude_defaults` и `exclude_none`.\n\n///\n\n#### Данные со значениями для полей, имеющих значения по умолчанию { #data-with-values-for-fields-with-defaults }", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md", "section_header": "Используйте параметр `response_model_exclude_unset`", "section_header_level": 3}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 17, "header": "Используйте параметр `response_model_exclude_unset`", "header_level": 3, "token_count": 503}
{"id": "81496accb49f70b1", "text": "dict\" class=\"external-link\" target=\"_blank\">документации Pydantic</a> для `exclude_defaults` и `exclude_none`.\n\n///\n\n#### Данные со значениями для полей, имеющих значения по умолчанию { #data-with-values-for-fields-with-defaults }\n\nНо если в ваших данных есть значения для полей модели, для которых указаны значения по умолчанию, как у элемента с ID `bar`:\n\n```Python hl_lines=\"3  5\"\n{\n    \"name\": \"Bar\",\n    \"description\": \"The bartenders\",\n    \"price\": 62,\n    \"tax\": 20.2\n}\n```\n\nони будут включены в ответ.\n\n#### Данные с такими же значениями, как значения по умолчанию { #data-with-the-same-values-as-the-defaults }\n\nЕсли данные имеют те же значения, что и значения по умолчанию, как у элемента с ID `baz`:\n\n```Python hl_lines=\"3  5-6\"\n{\n    \"name\": \"Baz\",\n    \"description\": None,\n    \"price\": 50.2,\n    \"tax\": 10.5,\n    \"tags\": []\n}\n```\n\nFastAPI достаточно умен (на самом деле, это Pydantic), чтобы понять, что хотя `description`, `tax` и `tags` совпадают со значениями по умолчанию, они были установлены явно (а не взяты из значений по умолчанию).\n\nПоэтому они тоже будут включены в JSON-ответ.\n\n/// tip | Совет\n\nОбратите внимание, что значения по умолчанию могут быть любыми, не только `None`.\n\nЭто может быть список (`[]`), число с плавающей точкой `10.5` и т. д.\n\n///", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md", "section_header": "Используйте параметр `response_model_exclude_unset`", "section_header_level": 3}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 18, "header": "Используйте параметр `response_model_exclude_unset`", "header_level": 3, "token_count": 451}
{"id": "ca6ad049a5564b20", "text": "### `response_model_include` и `response_model_exclude` { #response-model-include-and-response-model-exclude }\n\nВы также можете использовать параметры *декоратора операции пути* `response_model_include` и `response_model_exclude`.\n\nОни принимают `set` из `str` с именами атрибутов, которые нужно включить (исключив остальные) или исключить (оставив остальные).\n\nЭто можно использовать как быстрый способ, если у вас только одна Pydantic-модель и вы хотите убрать часть данных из ответа.\n\n/// tip | Совет\n\nНо всё же рекомендуется использовать подходы выше — несколько классов — вместо этих параметров.\n\nПотому что JSON Schema, генерируемая в OpenAPI вашего приложения (и документации), всё равно будет соответствовать полной модели, даже если вы используете `response_model_include` или `response_model_exclude`, чтобы опустить некоторые атрибуты.\n\nТо же относится к `response_model_by_alias`, который работает аналогично.\n\n///\n\n{* ../../docs_src/response_model/tutorial005_py310.py hl[29,35] *}\n\n/// tip | Совет\n\nСинтаксис `{\"name\", \"description\"}` создаёт `set` с этими двумя значениями.\n\nЭто эквивалентно `set([\"name\", \"description\"])`.\n\n///\n\n#### Использование `list` вместо `set` { #using-lists-instead-of-sets }\n\nЕсли вы забыли использовать `set` и применили `list` или `tuple`, FastAPI всё равно преобразует это в `set`, и всё будет работать корректно:\n\n{* ../../docs_src/response_model/tutorial006_py310.py hl[29,35] *}\n\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 19, "header": "`response_model_include` и `response_model_exclude`", "header_level": 3, "token_count": 473}
{"id": "c5985c5e937ff5c5", "text": "## Резюме { #recap }\n\nИспользуйте параметр `response_model` у *декоратора операции пути*, чтобы задавать модели ответа, и особенно — чтобы приватные данные отфильтровывались.\n\nИспользуйте `response_model_exclude_unset`, чтобы возвращать только те значения, которые были установлены явно.\n", "metadata": {"title": "Модель ответа — Возвращаемый тип", "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "source_mtime": "2026-01-12T17:48:13.502134+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-model.md"}, "doc_id": "3c9571fb89b2", "source_path": "docs\\tutorial\\response-model.md", "title": "Модель ответа — Возвращаемый тип", "chunk_index": 20, "header": "Резюме", "header_level": 2, "token_count": 98}
{"id": "6ec7df6a9d154fbc", "text": "# Статус-код ответа { #response-status-code }\n\nПодобно тому, как вы можете задать модель/схему ответа, вы можете объявить HTTP статус-код, используемый для ответа, с помощью параметра `status_code` в любой из *операций пути*:\n\n* `@app.get()`\n* `@app.post()`\n* `@app.put()`\n* `@app.delete()`\n* и других.\n\n{* ../../docs_src/response_status_code/tutorial001_py39.py hl[6] *}\n\n/// note | Примечание\n\nОбратите внимание, что `status_code` — это параметр метода-декоратора (`get`, `post` и т.д.), а не вашей *функции-обработчика пути*, в отличие от всех остальных параметров и тела запроса.\n\n///\n\nПараметр `status_code` принимает число, обозначающее HTTP статус-код.\n\n/// info | Информация\n\nВ качестве значения параметра `status_code` также может использоваться `IntEnum`, например, из библиотеки <a href=\"https://docs.python.org/3/library/http.html#http.HTTPStatus\" class=\"external-link\" target=\"_blank\">`http.HTTPStatus`</a> в Python.\n\n///\n\nЭто позволит:\n\n* Возвращать указанный код статуса в ответе.\n* Документировать его как код статуса ответа в OpenAPI схеме (а значит, и в пользовательских интерфейсах):\n\n<img src=\"/img/tutorial/response-status-code/image01.png\">\n\n/// note | Примечание\n\nНекоторые коды статуса ответа (см. следующий раздел) указывают на то, что ответ не имеет тела.\n\nFastAPI знает об этом и создаст документацию OpenAPI, в которой будет указано, что тело ответа отсутствует.\n\n///\n\n", "metadata": {"title": "Статус-код ответа", "doc_id": "6d16b17a09b7", "source_path": "docs\\tutorial\\response-status-code.md", "source_mtime": "2026-01-12T17:48:13.510370+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-status-code.md"}, "doc_id": "6d16b17a09b7", "source_path": "docs\\tutorial\\response-status-code.md", "title": "Статус-код ответа", "chunk_index": 0, "header": "Статус-код ответа", "header_level": 1, "token_count": 486}
{"id": "6ec7df6a9d154fbc", "text": "## Об HTTP статус-кодах { #about-http-status-codes }\n\n/// note | Примечание\n\nЕсли вы уже знаете, что представляют собой HTTP статус-коды, можете перейти к следующему разделу.\n\n///\n\nВ протоколе HTTP числовой код состояния из 3 цифр отправляется как часть ответа.\n\nУ кодов статуса есть названия, чтобы упростить их распознавание, но важны именно числовые значения.\n\nКратко:", "metadata": {"title": "Статус-код ответа", "doc_id": "6d16b17a09b7", "source_path": "docs\\tutorial\\response-status-code.md", "source_mtime": "2026-01-12T17:48:13.510370+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-status-code.md", "section_header": "Об HTTP статус-кодах", "section_header_level": 2}, "doc_id": "6d16b17a09b7", "source_path": "docs\\tutorial\\response-status-code.md", "title": "Статус-код ответа", "chunk_index": 1, "header": "Об HTTP статус-кодах", "header_level": 2, "token_count": 144}
{"id": "db74a41d3600c0a8", "text": "ояния из 3 цифр отправляется как часть ответа.\n\nУ кодов статуса есть названия, чтобы упростить их распознавание, но важны именно числовые значения.\n\nКратко:\n\n* `100 - 199` – статус-коды информационного типа. Они редко используются разработчиками напрямую. Ответы с этими кодами не могут иметь тела.\n* **`200 - 299`** – статус-коды, сообщающие об успешной обработке запроса. Они используются чаще всего.\n    * `200` – это код статуса ответа по умолчанию, который означает, что все прошло \"OK\".\n    * Другим примером может быть статус `201`, \"Created\". Он обычно используется после создания новой записи в базе данных.\n    * Особый случай – `204`, \"No Content\". Этот статус ответа используется, когда нет содержимого для возврата клиенту, и поэтому ответ не должен иметь тела.\n* **`300 - 399`** – статус-коды, сообщающие о перенаправлениях. Ответы с этими кодами статуса могут иметь или не иметь тело, за исключением ответов со статусом `304`, \"Not Modified\", у которых не должно быть тела.\n* **`400 - 499`** – статус-коды, сообщающие о клиентской ошибке. Это ещё одна наиболее часто используемая категория.\n    * Пример – код `404` для статуса \"Not Found\".\n    * Для общих ошибок со стороны клиента можно просто использовать код `400`.\n* `500 - 599` – статус-коды, сообщающие о серверной ошибке. Они почти никогда не используются разработчиками напрямую. Когда что-то идет не так в какой-то части кода вашего приложения или на сервере, он автоматически вернёт один из этих кодов статуса.", "metadata": {"title": "Статус-код ответа", "doc_id": "6d16b17a09b7", "source_path": "docs\\tutorial\\response-status-code.md", "source_mtime": "2026-01-12T17:48:13.510370+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-status-code.md", "section_header": "Об HTTP статус-кодах", "section_header_level": 2}, "doc_id": "6d16b17a09b7", "source_path": "docs\\tutorial\\response-status-code.md", "title": "Статус-код ответа", "chunk_index": 2, "header": "Об HTTP статус-кодах", "header_level": 2, "token_count": 599}
{"id": "9e19853a6f1e5481", "text": "работчиками напрямую. Когда что-то идет не так в какой-то части кода вашего приложения или на сервере, он автоматически вернёт один из этих кодов статуса.\n\n/// tip | Подсказка\n\nЧтобы узнать больше о HTTP кодах статуса и о том, для чего каждый из них предназначен, ознакомьтесь с <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\" class=\"external-link\" target=\"_blank\"><abbr title=\"Mozilla Developer Network – Сеть разработчиков Mozilla\">MDN</abbr> документацией об HTTP статус-кодах</a>.\n\n///", "metadata": {"title": "Статус-код ответа", "doc_id": "6d16b17a09b7", "source_path": "docs\\tutorial\\response-status-code.md", "source_mtime": "2026-01-12T17:48:13.510370+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-status-code.md", "section_header": "Об HTTP статус-кодах", "section_header_level": 2}, "doc_id": "6d16b17a09b7", "source_path": "docs\\tutorial\\response-status-code.md", "title": "Статус-код ответа", "chunk_index": 3, "header": "Об HTTP статус-кодах", "header_level": 2, "token_count": 185}
{"id": "1087a82897d6330e", "text": "## Краткие обозначения для запоминания названий кодов { #shortcut-to-remember-the-names }\n\nРассмотрим предыдущий пример еще раз:\n\n{* ../../docs_src/response_status_code/tutorial001_py39.py hl[6] *}\n\n`201` – это код статуса \"Создано\".\n\nНо вам не обязательно запоминать, что означает каждый из этих кодов.\n\nДля удобства вы можете использовать переменные из `fastapi.status`.\n\n{* ../../docs_src/response_status_code/tutorial002_py39.py hl[1,6] *}\n\nОни содержат те же числовые значения, но позволяют использовать автозавершение редактора кода для выбора кода статуса:\n\n<img src=\"/img/tutorial/response-status-code/image02.png\">\n\n/// note | Технические детали\n\nВы также можете использовать `from starlette import status` вместо `from fastapi import status`.\n\n**FastAPI** позволяет использовать как `starlette.status`, так и `fastapi.status` исключительно для удобства разработчиков. Но поставляется fastapi.status непосредственно из Starlette.\n\n///\n\n", "metadata": {"title": "Статус-код ответа", "doc_id": "6d16b17a09b7", "source_path": "docs\\tutorial\\response-status-code.md", "source_mtime": "2026-01-12T17:48:13.510370+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-status-code.md"}, "doc_id": "6d16b17a09b7", "source_path": "docs\\tutorial\\response-status-code.md", "title": "Статус-код ответа", "chunk_index": 4, "header": "Краткие обозначения для запоминания названий кодов", "header_level": 2, "token_count": 301}
{"id": "f9f23d7ffcf30488", "text": "## Изменение кода статуса по умолчанию { #changing-the-default }\n\nПозже, в [Руководстве для продвинутых пользователей](../advanced/response-change-status-code.md){.internal-link target=_blank}, вы узнаете, как возвращать HTTP статус-код, отличный от значения по умолчанию, которое вы объявляете здесь.\n", "metadata": {"title": "Статус-код ответа", "doc_id": "6d16b17a09b7", "source_path": "docs\\tutorial\\response-status-code.md", "source_mtime": "2026-01-12T17:48:13.510370+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\response-status-code.md"}, "doc_id": "6d16b17a09b7", "source_path": "docs\\tutorial\\response-status-code.md", "title": "Статус-код ответа", "chunk_index": 5, "header": "Изменение кода статуса по умолчанию", "header_level": 2, "token_count": 104}
{"id": "c77f3855eecbc991", "text": "# Объявление примеров данных запроса { #declare-request-example-data }\n\nВы можете объявлять примеры данных, которые ваше приложение может получать.\n\nВот несколько способов, как это сделать.\n\n", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md"}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 0, "header": "Объявление примеров данных запроса", "header_level": 1, "token_count": 59}
{"id": "c77f3855eecbc991", "text": "## Дополнительные данные JSON Schema в моделях Pydantic { #extra-json-schema-data-in-pydantic-models }\n\nВы можете объявить `examples` для модели Pydantic, которые будут добавлены в сгенерированную JSON Schema.\n\n//// tab | Pydantic v2\n\n{* ../../docs_src/schema_extra_example/tutorial001_py310.py hl[13:24] *}\n\n////\n\n//// tab | Pydantic v1\n\n{* ../../docs_src/schema_extra_example/tutorial001_pv1_py310.py hl[13:23] *}\n\n////\n\nЭта дополнительная информация будет добавлена как есть в выходную **JSON Schema** этой модели и будет использоваться в документации API.\n\n//// tab | Pydantic v2\n\nВ Pydantic версии 2 вы будете использовать атрибут `model_config`, который принимает `dict`, как описано в <a href=\"https://docs.pydantic.dev/latest/api/config/\" class=\"external-link\" target=\"_blank\">Документации Pydantic: Конфигурация</a>.\n\nВы можете задать `\"json_schema_extra\"` с `dict`, содержащим любые дополнительные данные, которые вы хотите видеть в сгенерированной JSON Schema, включая `examples`.\n\n////\n\n//// tab | Pydantic v1\n\nВ Pydantic версии 1 вы будете использовать внутренний класс `Config` и `schema_extra`, как описано в <a href=\"https://docs.pydantic.dev/1.10/usage/schema/#schema-customization\" class=\"external-link\" target=\"_blank\">Документации Pydantic: Настройка схемы</a>.\n\nВы можете задать `schema_extra` со `dict`, содержащим любые дополнительные данные, которые вы хотите видеть в сгенерированной JSON Schema, включая `examples`.\n\n////\n\n/// tip | Подсказка\n\nВы можете использовать тот же приём, чтобы расширить JSON Schema и добавить свою собственную дополнительную информацию.", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md", "section_header": "Дополнительные данные JSON Schema в моделях Pydantic", "section_header_level": 2}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 1, "header": "Дополнительные данные JSON Schema в моделях Pydantic", "header_level": 2, "token_count": 505}
{"id": "6f7c73f004c884b0", "text": "ерированной JSON Schema, включая `examples`.\n\n////\n\n/// tip | Подсказка\n\nВы можете использовать тот же приём, чтобы расширить JSON Schema и добавить свою собственную дополнительную информацию.\n\nНапример, вы можете использовать это, чтобы добавить метаданные для фронтенд‑пользовательского интерфейса и т.д.\n\n///\n\n/// info | Информация\n\nOpenAPI 3.1.0 (используется начиная с FastAPI 0.99.0) добавил поддержку `examples`, который является частью стандарта **JSON Schema**.\n\nДо этого поддерживалось только ключевое слово `example` с одним примером. Оно всё ещё поддерживается в OpenAPI 3.1.0, но помечено как устаревшее и не является частью стандарта JSON Schema. Поэтому рекомендуется мигрировать `example` на `examples`. \n\nПодробнее — в конце этой страницы.\n\n///", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md", "section_header": "Дополнительные данные JSON Schema в моделях Pydantic", "section_header_level": 2}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 2, "header": "Дополнительные данные JSON Schema в моделях Pydantic", "header_level": 2, "token_count": 289}
{"id": "be181a049a465b0d", "text": "## Дополнительные аргументы `Field` { #field-additional-arguments }\n\nПри использовании `Field()` с моделями Pydantic вы также можете объявлять дополнительные `examples`:\n\n{* ../../docs_src/schema_extra_example/tutorial002_py310.py hl[2,8:11] *}\n\n", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md"}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 3, "header": "Дополнительные аргументы `Field`", "header_level": 2, "token_count": 76}
{"id": "8e67bb2b4d5aabb7", "text": "## `examples` в JSON Schema — OpenAPI { #examples-in-json-schema-openapi }\n\nПри использовании любой из функций:\n\n* `Path()`\n* `Query()`\n* `Header()`\n* `Cookie()`\n* `Body()`\n* `Form()`\n* `File()`\n\nвы также можете объявить набор `examples` с дополнительной информацией, которая будет добавлена в их **JSON Schema** внутри **OpenAPI**.\n\n", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md"}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 4, "header": "`examples` в JSON Schema — OpenAPI", "header_level": 2, "token_count": 114}
{"id": "b0f1bb032154db2c", "text": "### `Body` с `examples` { #body-with-examples }\n\nЗдесь мы передаём `examples`, содержащий один пример данных, ожидаемых в `Body()`:\n\n{* ../../docs_src/schema_extra_example/tutorial003_an_py310.py hl[22:29] *}\n\n", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md"}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 5, "header": "`Body` с `examples`", "header_level": 3, "token_count": 66}
{"id": "6e2855603cc803ce", "text": "### Пример в UI документации { #example-in-the-docs-ui }\n\nС любым из перечисленных выше методов это будет выглядеть так в `/docs`:\n\n<img src=\"/img/tutorial/body-fields/image01.png\">\n\n", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md"}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 6, "header": "Пример в UI документации", "header_level": 3, "token_count": 57}
{"id": "7f294f1ea8a97bff", "text": "### `Body` с несколькими `examples` { #body-with-multiple-examples }\n\nКонечно, вы можете передать и несколько `examples`:\n\n{* ../../docs_src/schema_extra_example/tutorial004_an_py310.py hl[23:38] *}\n\nКогда вы делаете это, примеры становятся частью внутренней **JSON Schema** для данных тела запроса.\n\nТем не менее, на <abbr title=\"2023-08-26\">момент написания этого</abbr> Swagger UI, инструмент, отвечающий за отображение UI документации, не поддерживает показ нескольких примеров для данных в **JSON Schema**. Но ниже есть обходной путь.\n\n", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md"}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 7, "header": "`Body` с несколькими `examples`", "header_level": 3, "token_count": 189}
{"id": "1f863210d6956ed5", "text": "### Специфические для OpenAPI `examples` { #openapi-specific-examples }\n\nЕщё до того как **JSON Schema** поддержала `examples`, в OpenAPI была поддержка другого поля, также называемого `examples`.\n\nЭти **специфические для OpenAPI** `examples` находятся в другой секции спецификации OpenAPI. Они находятся в **подробностях для каждой операции пути (обработчика пути)**, а не внутри каждого объекта Schema.\n\nИ Swagger UI уже какое‑то время поддерживает именно это поле `examples`. Поэтому вы можете использовать его, чтобы **отобразить** разные **примеры в UI документации**.\n\nСтруктура этого специфичного для OpenAPI поля `examples` — это `dict` с **несколькими примерами** (вместо `list`), каждый с дополнительной информацией, которая также будет добавлена в **OpenAPI**.\n\nЭто не помещается внутрь каждого объекта Schema в OpenAPI, это находится снаружи, непосредственно на уровне самой *операции пути*.\n\n", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md"}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 8, "header": "Специфические для OpenAPI `examples`", "header_level": 3, "token_count": 325}
{"id": "f7f4047449017901", "text": "### Использование параметра `openapi_examples` { #using-the-openapi-examples-parameter }\n\nВы можете объявлять специфические для OpenAPI `examples` в FastAPI с помощью параметра `openapi_examples` для:\n\n* `Path()`\n* `Query()`\n* `Header()`\n* `Cookie()`\n* `Body()`\n* `Form()`\n* `File()`\n\nКлючи `dict` идентифицируют каждый пример, а каждое значение — это ещё один `dict`.\n\nКаждый конкретный пример‑`dict` в `examples` может содержать:\n\n* `summary`: Краткое описание примера.\n* `description`: Подробное описание, которое может содержать текст в Markdown.\n* `value`: Это фактический пример, который отображается, например, `dict`.\n* `externalValue`: альтернатива `value`, URL, указывающий на пример. Хотя это может поддерживаться не так многими инструментами, как `value`.\n\nИспользовать это можно так:\n\n{* ../../docs_src/schema_extra_example/tutorial005_an_py310.py hl[23:49] *}\n\n", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md"}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 9, "header": "Использование параметра `openapi_examples`", "header_level": 3, "token_count": 294}
{"id": "b6ec5f651253d495", "text": "### OpenAPI-примеры  в UI документации { #openapi-examples-in-the-docs-ui }\n\nС `openapi_examples`, добавленным в `Body()`, страница `/docs` будет выглядеть так:\n\n<img src=\"/img/tutorial/body-fields/image02.png\">\n\n", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md"}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 10, "header": "OpenAPI-примеры  в UI документации", "header_level": 3, "token_count": 66}
{"id": "c77f3855eecbc991", "text": "## Технические детали { #technical-details }\n\n/// tip | Подсказка\n\nЕсли вы уже используете **FastAPI** версии **0.99.0 или выше**, вы, вероятно, можете **пропустить** эти подробности.\n\nОни более актуальны для старых версий, до того как стала доступна OpenAPI 3.1.0.\n\nСчитайте это кратким **уроком истории** про OpenAPI и JSON Schema. \n\n///\n\n/// warning | Внимание\n\nДалее идут очень технические подробности о стандартах **JSON Schema** и **OpenAPI**.\n\nЕсли идеи выше уже работают для вас, этого может быть достаточно, и, вероятно, вам не нужны эти детали — смело пропускайте их.\n\n///\n\nДо OpenAPI 3.1.0 OpenAPI использовала более старую и модифицированную версию **JSON Schema**.\n\nВ JSON Schema не было `examples`, поэтому OpenAPI добавила собственное поле `example` в свою модифицированную версию.\n\nOpenAPI также добавила поля `example` и `examples` в другие части спецификации:", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md", "section_header": "Технические детали", "section_header_level": 2}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 11, "header": "Технические детали", "header_level": 2, "token_count": 341}
{"id": "6f7c73f004c884b0", "text": "`, поэтому OpenAPI добавила собственное поле `example` в свою модифицированную версию.\n\nOpenAPI также добавила поля `example` и `examples` в другие части спецификации:\n\n* <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#parameter-object\" class=\"external-link\" target=\"_blank\">`Parameter Object` (в спецификации)</a>, которое использовалось в FastAPI:\n    * `Path()`\n    * `Query()`\n    * `Header()`\n    * `Cookie()`\n* <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#media-type-object\" class=\"external-link\" target=\"_blank\">`Request Body Object`, в поле `content`, в `Media Type Object` (в спецификации)</a>, которое использовалось в FastAPI:\n    * `Body()`\n    * `File()`\n    * `Form()`\n\n/// info | Информация\n\nЭтот старый специфичный для OpenAPI параметр `examples` теперь называется `openapi_examples`, начиная с FastAPI `0.103.0`.\n\n///", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md", "section_header": "Технические детали", "section_header_level": 2}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 12, "header": "Технические детали", "header_level": 2, "token_count": 303}
{"id": "a646c7ae8b9a3e6b", "text": "### Поле `examples` в JSON Schema { #json-schemas-examples-field }\n\nПозже в новой версии спецификации JSON Schema было добавлено поле <a href=\"https://json-schema.org/draft/2019-09/json-schema-validation.html#rfc.section.9.5\" class=\"external-link\" target=\"_blank\">`examples`</a>.\n\nА затем новый OpenAPI 3.1.0 был основан на последней версии (JSON Schema 2020-12), которая включала это новое поле `examples`.\n\nИ теперь это новое поле `examples` имеет приоритет над старым одиночным (и кастомным) полем `example`, которое теперь устарело.\n\nЭто новое поле `examples` в JSON Schema — это **просто `list`** примеров, а не dict с дополнительными метаданными, как в других местах OpenAPI (описанных выше).\n\n/// info | Информация\n\nДаже после того как OpenAPI 3.1.0 была выпущена с этой новой, более простой интеграцией с JSON Schema, какое‑то время Swagger UI, инструмент, предоставляющий автоматическую документацию, не поддерживал OpenAPI 3.1.0 (поддержка появилась начиная с версии 5.0.0 ).\n\nИз‑за этого версии FastAPI до 0.99.0 всё ещё использовали версии OpenAPI ниже 3.1.0.\n\n///\n\n", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md"}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 13, "header": "Поле `examples` в JSON Schema", "header_level": 3, "token_count": 416}
{"id": "d2492c8fb5b6cff1", "text": "### `examples` в Pydantic и FastAPI { #pydantic-and-fastapi-examples }\n\nКогда вы добавляете `examples` внутри модели Pydantic, используя `schema_extra` или `Field(examples=[\"something\"])`, этот пример добавляется в **JSON Schema** для этой модели Pydantic.\n\nИ эта **JSON Schema** модели Pydantic включается в **OpenAPI** вашего API, а затем используется в UI документации.\n\nВ версиях FastAPI до 0.99.0 (0.99.0 и выше используют новый OpenAPI 3.1.0), когда вы использовали `example` или `examples` с любыми другими утилитами (`Query()`, `Body()`, и т.д.), эти примеры не добавлялись в JSON Schema, описывающую эти данные (даже в собственную версию JSON Schema OpenAPI), они добавлялись непосредственно в объявление *операции пути* в OpenAPI (вне частей OpenAPI, использующих JSON Schema).\n\nНо теперь, когда FastAPI 0.99.0 и выше используют OpenAPI 3.1.0, который использует JSON Schema 2020-12, а также Swagger UI 5.0.0 и выше, всё стало более последовательным, и примеры включаются в JSON Schema.\n\n", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md"}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 14, "header": "`examples` в Pydantic и FastAPI", "header_level": 3, "token_count": 367}
{"id": "f8d519675ef32927", "text": "### Swagger UI и специфичные для OpenAPI `examples` { #swagger-ui-and-openapi-specific-examples }\n\nРаньше, поскольку Swagger UI не поддерживал несколько примеров JSON Schema (по состоянию на 2023-08-26), у пользователей не было способа показать несколько примеров в документации.\n\nЧтобы решить это, FastAPI `0.103.0` **добавил поддержку** объявления того же старого, **специфичного для OpenAPI**, поля `examples` с новым параметром `openapi_examples`. \n\n", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md"}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 15, "header": "Swagger UI и специфичные для OpenAPI `examples`", "header_level": 3, "token_count": 159}
{"id": "a0fc06bf3bb6464e", "text": "### Итог { #summary }\n\nРаньше я говорил, что не очень люблю историю... а теперь вот рассказываю «уроки технической истории». \n\nКоротко: **обновитесь до FastAPI 0.99.0 или выше** — так всё будет значительно **проще, последовательнее и интуитивнее**, и вам не придётся знать все эти исторические подробности.\n", "metadata": {"title": "Объявление примеров данных запроса", "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "source_mtime": "2026-01-12T17:48:13.518265+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\schema-extra-example.md"}, "doc_id": "b3d6de617785", "source_path": "docs\\tutorial\\schema-extra-example.md", "title": "Объявление примеров данных запроса", "chunk_index": 16, "header": "Итог", "header_level": 3, "token_count": 137}
{"id": "7933cd1b67cfd069", "text": "# SQL (реляционные) базы данных { #sql-relational-databases }\n\n**FastAPI** не требует использовать SQL (реляционную) базу данных. Но вы можете использовать любую базу данных, которую хотите.\n\nЗдесь мы рассмотрим пример с использованием <a href=\"https://sqlmodel.tiangolo.com/\" class=\"external-link\" target=\"_blank\">SQLModel</a>.\n\n**SQLModel** построен поверх <a href=\"https://www.sqlalchemy.org/\" class=\"external-link\" target=\"_blank\">SQLAlchemy</a> и Pydantic. Его создал тот же автор, что и **FastAPI**, чтобы он идеально подходил для приложений FastAPI, которым нужны **SQL базы данных**.\n\n/// tip | Подсказка\n\nВы можете использовать любую другую библиотеку для работы с SQL или NoSQL базами данных (иногда их называют <abbr title=\"Object Relational Mapper – Объектно-реляционный маппер: термин для библиотеки, где некоторые классы представляют SQL-таблицы, а экземпляры представляют строки в этих таблицах\">\"ORMs\"</abbr>), FastAPI ничего не навязывает. \n\n///\n\nТак как SQLModel основан на SQLAlchemy, вы можете легко использовать **любую поддерживаемую** SQLAlchemy базу данных (а значит, и поддерживаемую SQLModel), например:\n\n* PostgreSQL\n* MySQL\n* SQLite\n* Oracle\n* Microsoft SQL Server, и т.д.\n\nВ этом примере мы будем использовать **SQLite**, потому что она использует один файл и имеет встроенную поддержку в Python. Так что вы можете скопировать этот пример и запустить его как есть.\n\nПозже, для продакшн-приложения, возможно, вы захотите использовать серверную базу данных, например **PostgreSQL**.", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md", "section_header": "SQL (реляционные) базы данных", "section_header_level": 1}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 0, "header": "SQL (реляционные) базы данных", "header_level": 1, "token_count": 509}
{"id": "d9e65ccf4aa04a2c", "text": "Python. Так что вы можете скопировать этот пример и запустить его как есть.\n\nПозже, для продакшн-приложения, возможно, вы захотите использовать серверную базу данных, например **PostgreSQL**.\n\n/// tip | Подсказка\n\nСуществует официальный генератор проектов на **FastAPI** и **PostgreSQL**, включающий frontend и другие инструменты: <a href=\"https://github.com/fastapi/full-stack-fastapi-template\" class=\"external-link\" target=\"_blank\">https://github.com/fastapi/full-stack-fastapi-template</a>\n\n///\n\nЭто очень простое и короткое руководство. Если вы хотите узнать больше о базах данных в целом, об SQL или о более продвинутых возможностях, обратитесь к <a href=\"https://sqlmodel.tiangolo.com/\" class=\"external-link\" target=\"_blank\">документации SQLModel</a>.", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md", "section_header": "SQL (реляционные) базы данных", "section_header_level": 1}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 1, "header": "SQL (реляционные) базы данных", "header_level": 1, "token_count": 248}
{"id": "167a46ae7e25fa75", "text": "## Установка `SQLModel` { #install-sqlmodel }\n\nСначала убедитесь, что вы создали [виртуальное окружение](../virtual-environments.md){.internal-link target=_blank}, активировали его и затем установили `sqlmodel`:\n\n<div class=\"termy\">\n\n```console\n$ pip install sqlmodel\n---> 100%\n```\n\n</div>\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 2, "header": "Установка `SQLModel`", "header_level": 2, "token_count": 95}
{"id": "c7925fa01fa4c8bc", "text": "## Создание приложения с единственной моделью { #create-the-app-with-a-single-model }\n\nСначала мы создадим самую простую первую версию приложения с одной моделью **SQLModel**.\n\nПозже мы улучшим его, повысив безопасность и универсальность, добавив **несколько моделей**. \n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 3, "header": "Создание приложения с единственной моделью", "header_level": 2, "token_count": 97}
{"id": "7933cd1b67cfd069", "text": "### Создание моделей { #create-models }\n\nИмпортируйте `SQLModel` и создайте модель базы данных:\n\n{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[1:11] hl[7:11] *}\n\nКласс `Hero` очень похож на модель Pydantic (фактически, под капотом, *это и есть модель Pydantic*).\n\nЕсть несколько отличий:\n\n* `table=True` сообщает SQLModel, что это *модель-таблица*, она должна представлять **таблицу** в SQL базе данных, это не просто *модель данных* (как обычный класс Pydantic).\n\n* `Field(primary_key=True)` сообщает SQLModel, что `id` — это **первичный ключ** в SQL базе данных (подробнее о первичных ключах SQL можно узнать в документации SQLModel).\n\n    **Примечание:** Мы используем `int | None` для поля первичного ключа, чтобы в Python-коде можно было *создать объект без `id`* (`id=None`), предполагая, что база данных *сгенерирует его при сохранении*. SQLModel понимает, что база данных предоставит `id`, и *определяет столбец как `INTEGER` (не `NULL`)* в схеме базы данных. См. <a href=\"https://sqlmodel.tiangolo.com/tutorial/create-db-and-table/#primary-key-id\" class=\"external-link\" target=\"_blank\">документацию SQLModel о первичных ключах</a> для подробностей.\n\n* `Field(index=True)` сообщает SQLModel, что нужно создать **SQL индекс** для этого столбца, что позволит быстрее выполнять выборки при чтении данных, отфильтрованных по этому столбцу.", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md", "section_header": "Создание моделей", "section_header_level": 3}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 4, "header": "Создание моделей", "header_level": 3, "token_count": 478}
{"id": "d9e65ccf4aa04a2c", "text": "Field(index=True)` сообщает SQLModel, что нужно создать **SQL индекс** для этого столбца, что позволит быстрее выполнять выборки при чтении данных, отфильтрованных по этому столбцу.\n\n    SQLModel будет знать, что объявленное как `str` станет SQL-столбцом типа `TEXT` (или `VARCHAR`, в зависимости от базы данных).", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md", "section_header": "Создание моделей", "section_header_level": 3}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 5, "header": "Создание моделей", "header_level": 3, "token_count": 113}
{"id": "67728c5a3027fc33", "text": "### Создание Engine { #create-an-engine }\n\nОбъект `engine` в SQLModel (под капотом это `engine` из SQLAlchemy) **удерживает соединения** с базой данных.\n\nУ вас должен быть **один объект `engine`** для всей кодовой базы, чтобы подключаться к одной и той же базе данных.\n\n{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[14:18] hl[14:15,17:18] *}\n\nПараметр `check_same_thread=False` позволяет FastAPI использовать одну и ту же базу данных SQLite в разных потоках. Это необходимо, так как **один запрос** может использовать **больше одного потока** (например, в зависимостях).\n\nНе волнуйтесь, с такой структурой кода мы позже обеспечим использование **одной *сессии* SQLModel на запрос**, по сути именно этого и добивается `check_same_thread`.\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 6, "header": "Создание Engine", "header_level": 3, "token_count": 252}
{"id": "5269e7e9499ec722", "text": "### Создание таблиц { #create-the-tables }\n\nДалее мы добавим функцию, которая использует `SQLModel.metadata.create_all(engine)`, чтобы **создать таблицы** для всех *моделей-таблиц*.\n\n{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[21:22] hl[21:22] *}\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 7, "header": "Создание таблиц", "header_level": 3, "token_count": 79}
{"id": "6daa445949bd5763", "text": "### Создание зависимости Session { #create-a-session-dependency }\n\n**`Session`** хранит **объекты в памяти** и отслеживает необходимые изменения в данных, затем **использует `engine`** для общения с базой данных.\n\nМы создадим **зависимость** FastAPI с `yield`, которая будет предоставлять новую `Session` для каждого запроса. Это и обеспечивает использование одной сессии на запрос. \n\nЗатем мы создадим объявленную (`Annotated`) зависимость `SessionDep`, чтобы упростить остальной код, который будет использовать эту зависимость.\n\n{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[25:30]  hl[25:27,30] *}\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 8, "header": "Создание зависимости Session", "header_level": 3, "token_count": 203}
{"id": "a6dff54357240f87", "text": "### Создание таблиц базы данных при старте { #create-database-tables-on-startup }\n\nМы создадим таблицы базы данных при запуске приложения.\n\n{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[32:37] hl[35:37] *}\n\nЗдесь мы создаём таблицы в обработчике события запуска приложения.\n\nДля продакшн вы, вероятно, будете использовать скрипт миграций, который выполняется до запуска приложения. \n\n/// tip | Подсказка\n\nВ SQLModel появятся утилиты миграций - обёртки над Alembic, но пока вы можете использовать <a href=\"https://alembic.sqlalchemy.org/en/latest/\" class=\"external-link\" target=\"_blank\">Alembic</a> напрямую.\n\n///\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 9, "header": "Создание таблиц базы данных при старте", "header_level": 3, "token_count": 218}
{"id": "54f1aea53bc734f4", "text": "### Создание героя (Hero) { #create-a-hero }\n\nТак как каждая модель SQLModel также является моделью Pydantic, вы можете использовать её в тех же **аннотациях типов**, в которых используете модели Pydantic.\n\nНапример, если вы объявите параметр типа `Hero`, он будет прочитан из **JSON body (тела запроса)**.\n\nАналогично вы можете объявить её как **тип возвращаемого значения** функции, и тогда форма данных отобразится в автоматически сгенерированном UI документации API.\n\n{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[40:45] hl[40:45] *}\n\nЗдесь мы используем зависимость `SessionDep` (это `Session`), чтобы добавить нового `Hero` в экземпляр `Session`, зафиксировать изменения в базе данных, обновить данные в `hero` и затем вернуть его.\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 10, "header": "Создание героя (Hero)", "header_level": 3, "token_count": 260}
{"id": "5f78467160b8cb5c", "text": "### Чтение героев { #read-heroes }\n\nМы можем **читать** записи `Hero` из базы данных с помощью `select()`. Можно добавить `limit` и `offset` для постраничного вывода результатов.\n\n{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[48:55] hl[51:52,54] *}\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 11, "header": "Чтение героев", "header_level": 3, "token_count": 91}
{"id": "f7f277fd09737651", "text": "### Чтение одного героя { #read-one-hero }\n\nМы можем **прочитать** одного `Hero`.\n\n{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[58:63] hl[60] *}\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 12, "header": "Чтение одного героя", "header_level": 3, "token_count": 56}
{"id": "8a4584a2ef6918e2", "text": "### Удаление героя { #delete-a-hero }\n\nМы также можем **удалить** `Hero`.\n\n{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[66:73] hl[71] *}\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 13, "header": "Удаление героя", "header_level": 3, "token_count": 51}
{"id": "13eaba8c74cb4fc3", "text": "### Запуск приложения { #run-the-app }\n\nВы можете запустить приложение:\n\n<div class=\"termy\">\n\n```console\n$ fastapi dev main.py\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n</div>\n\nЗатем перейдите в UI `/docs`. Вы увидите, что **FastAPI** использует эти **модели** для **документирования** API, а также для **сериализации** и **валидации** данных.\n\n<div class=\"screenshot\">\n<img src=\"/img/tutorial/sql-databases/image01.png\">\n</div>\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 14, "header": "Запуск приложения", "header_level": 3, "token_count": 163}
{"id": "ccfbd0c95d171da9", "text": "## Обновление приложения с несколькими моделями { #update-the-app-with-multiple-models }\n\nТеперь давайте немного **отрефакторим** приложение, чтобы повысить **безопасность** и **универсальность**.\n\nЕсли вы посмотрите на предыдущую версию, в UI видно, что до сих пор клиент мог сам задавать `id` создаваемого `Hero`. \n\nТак делать нельзя, иначе они могли бы перезаписать `id`, который уже присвоен в БД. Решение по `id` должно приниматься **бэкендом** или **базой данных**, а **не клиентом**.\n\nКроме того, мы создаём для героя `secret_name`, но пока что возвращаем его повсюду — это не очень **секретно**... \n\nМы исправим это, добавив несколько **дополнительных моделей**. Здесь SQLModel раскроется во всей красе. \n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 15, "header": "Обновление приложения с несколькими моделями", "header_level": 2, "token_count": 285}
{"id": "7933cd1b67cfd069", "text": "### Создание нескольких моделей { #create-multiple-models }\n\nВ **SQLModel** любая модель с `table=True` — это **модель-таблица**.\n\nЛюбая модель без `table=True` — это **модель данных**, по сути обычная модель Pydantic (с парой небольших дополнений). \n\nС SQLModel мы можем использовать **наследование**, чтобы **избежать дублирования** полей.\n\n#### `HeroBase` — базовый класс { #herobase-the-base-class }\n\nНачнём с модели `HeroBase`, которая содержит **общие поля** для всех моделей:\n\n* `name`\n* `age`\n\n{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:9] hl[7:9] *}\n\n#### `Hero` — *модель-таблица* { #hero-the-table-model }\n\nДалее создадим `Hero`, фактическую *модель-таблицу*, с **дополнительными полями**, которых может не быть в других моделях:\n\n* `id`\n* `secret_name`\n\nТак как `Hero` наследуется от `HeroBase`, он **также** имеет **поля**, объявленные в `HeroBase`, поэтому все поля `Hero`:\n\n* `id`\n* `name`\n* `age`\n* `secret_name`\n\n{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:14] hl[12:14] *}\n\n#### `HeroPublic` — публичная *модель данных* { #heropublic-the-public-data-model }\n\nДалее мы создадим модель `HeroPublic`, именно она будет **возвращаться** клиентам API.\n\nУ неё те же поля, что и у `HeroBase`, поэтому она не включает `secret_name`.\n\nНаконец-то личность наших героев защищена!", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md", "section_header": "Создание нескольких моделей", "section_header_level": 3}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 16, "header": "Создание нескольких моделей", "header_level": 3, "token_count": 481}
{"id": "d9e65ccf4aa04a2c", "text": "**возвращаться** клиентам API.\n\nУ неё те же поля, что и у `HeroBase`, поэтому она не включает `secret_name`.\n\nНаконец-то личность наших героев защищена! \n\nТакже здесь заново объявляется `id: int`. Тем самым мы заключаем **контракт** с клиентами API: они всегда могут рассчитывать, что поле `id` присутствует и это `int` (никогда не `None`).\n\n/// tip | Подсказка\n\nГарантия того, что в модели ответа значение всегда присутствует и это `int` (не `None`), очень полезна для клиентов API — так можно писать гораздо более простой код.\n\nКроме того, **автоматически сгенерированные клиенты** будут иметь более простые интерфейсы, и разработчикам, взаимодействующим с вашим API, будет работать значительно комфортнее. \n\n///\n\nВсе поля `HeroPublic` такие же, как в `HeroBase`, а `id` объявлен как `int` (не `None`):\n\n* `id`\n* `name`\n* `age`\n\n{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:18] hl[17:18] *}\n\n#### `HeroCreate` — *модель данных* для создания героя { #herocreate-the-data-model-to-create-a-hero }\n\nТеперь создадим модель `HeroCreate`, она будет **валидировать** данные от клиентов.\n\nУ неё те же поля, что и у `HeroBase`, а также есть `secret_name`.\n\nТеперь, когда клиенты **создают нового героя**, они будут отправлять `secret_name`, он сохранится в базе данных, но не будет возвращаться клиентам в API.", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md", "section_header": "Создание нескольких моделей", "section_header_level": 3}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 17, "header": "Создание нескольких моделей", "header_level": 3, "token_count": 505}
{"id": "167a46ae7e25fa75", "text": "Base`, а также есть `secret_name`.\n\nТеперь, когда клиенты **создают нового героя**, они будут отправлять `secret_name`, он сохранится в базе данных, но не будет возвращаться клиентам в API.\n\n/// tip | Подсказка\n\nТак следует обрабатывать **пароли**: принимать их, но не возвращать в API.\n\nТакже перед сохранением значения паролей нужно **хэшировать**, **никогда не храните их в открытом виде**.\n\n///\n\nПоля `HeroCreate`:\n\n* `name`\n* `age`\n* `secret_name`\n\n{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:22] hl[21:22] *}\n\n#### `HeroUpdate` — *модель данных* для обновления героя { #heroupdate-the-data-model-to-update-a-hero }\n\nВ предыдущей версии приложения у нас не было способа **обновлять героя**, но теперь, с **несколькими моделями**, мы можем это сделать. \n\n*Модель данных* `HeroUpdate` особенная: у неё **те же поля**, что и для создания нового героя, но все поля **необязательные** (у всех есть значение по умолчанию). Таким образом, при обновлении героя можно отправлять только те поля, которые нужно изменить.\n\nПоскольку **фактически меняются все поля** (их тип теперь включает `None`, и по умолчанию они равны `None`), нам нужно **переобъявить** их.\n\nНаследоваться от `HeroBase` не обязательно, так как мы заново объявляем все поля. Я оставлю наследование для единообразия, но это не необходимо. Скорее дело вкуса.", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md", "section_header": "Создание нескольких моделей", "section_header_level": 3}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 18, "header": "Создание нескольких моделей", "header_level": 3, "token_count": 505}
{"id": "c7925fa01fa4c8bc", "text": "от `HeroBase` не обязательно, так как мы заново объявляем все поля. Я оставлю наследование для единообразия, но это не необходимо. Скорее дело вкуса. \n\nПоля `HeroUpdate`:\n\n* `name`\n* `age`\n* `secret_name`\n\n{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:28] hl[25:28] *}", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md", "section_header": "Создание нескольких моделей", "section_header_level": 3}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 19, "header": "Создание нескольких моделей", "header_level": 3, "token_count": 110}
{"id": "d966588eb1e44949", "text": "### Создание с `HeroCreate` и возврат `HeroPublic` { #create-with-herocreate-and-return-a-heropublic }\n\nТеперь, когда у нас есть **несколько моделей**, мы можем обновить части приложения, которые их используют.\n\nМы получаем в запросе *модель данных* `HeroCreate` и на её основе создаём *модель-таблицу* `Hero`.\n\nНовая *модель-таблица* `Hero` будет иметь поля, отправленные клиентом, а также `id`, сгенерированный базой данных.\n\nЗатем возвращаем из функции ту же *модель-таблицу* `Hero` как есть. Но так как мы объявили `response_model` с *моделью данных* `HeroPublic`, **FastAPI** использует `HeroPublic` для валидации и сериализации данных.\n\n{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[56:62] hl[56:58] *}\n\n/// tip | Подсказка\n\nТеперь мы используем `response_model=HeroPublic` вместо **аннотации типа возвращаемого значения** `-> HeroPublic`, потому что фактически возвращаемое значение — это *не* `HeroPublic`.\n\nЕсли бы мы объявили `-> HeroPublic`, ваш редактор кода и линтер справедливо пожаловались бы, что вы возвращаете `Hero`, а не `HeroPublic`.\n\nОбъявляя модель в `response_model`, мы говорим **FastAPI** сделать своё дело, не вмешиваясь в аннотации типов и работу редактора кода и других инструментов.\n\n///\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 20, "header": "Создание с `HeroCreate` и возврат `HeroPublic`", "header_level": 3, "token_count": 449}
{"id": "8e017ea1cf150771", "text": "### Чтение героев с `HeroPublic` { #read-heroes-with-heropublic }\n\nАналогично мы можем **читать** `Hero` — снова используем `response_model=list[HeroPublic]`, чтобы данные валидировались и сериализовались корректно.\n\n{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[65:72] hl[65] *}\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 21, "header": "Чтение героев с `HeroPublic`", "header_level": 3, "token_count": 103}
{"id": "df33348a3a785a65", "text": "### Чтение одного героя с `HeroPublic` { #read-one-hero-with-heropublic }\n\nМы можем **прочитать** одного героя:\n\n{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[75:80] hl[77] *}\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 22, "header": "Чтение одного героя с `HeroPublic`", "header_level": 3, "token_count": 67}
{"id": "e377576eb51ef42c", "text": "### Обновление героя с `HeroUpdate` { #update-a-hero-with-heroupdate }\n\nМы можем **обновить героя**. Для этого используем HTTP операцию `PATCH`.\n\nВ коде мы получаем `dict` со всеми данными, отправленными клиентом — **только с данными, отправленными клиентом**, исключая любые значения, которые были бы там лишь как значения по умолчанию. Для этого мы используем `exclude_unset=True`. Это главный трюк. \n\nЗатем мы используем `hero_db.sqlmodel_update(hero_data)`, чтобы обновить `hero_db` данными из `hero_data`.\n\n{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[83:93] hl[83:84,88:89] *}\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 23, "header": "Обновление героя с `HeroUpdate`", "header_level": 3, "token_count": 202}
{"id": "bd99d6f1aac440ef", "text": "### Снова удаление героя { #delete-a-hero-again }\n\nОперация **удаления** героя остаётся практически прежней.\n\nЖелание *«отрефакторить всё»* на этот раз останется неудовлетворённым. \n\n{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[96:103] hl[101] *}\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 24, "header": "Снова удаление героя", "header_level": 3, "token_count": 108}
{"id": "8baf658931e99ccf", "text": "### Снова запустим приложение { #run-the-app-again }\n\nВы можете снова запустить приложение:\n\n<div class=\"termy\">\n\n```console\n$ fastapi dev main.py\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n</div>\n\nЕсли вы перейдёте в UI API `/docs`, вы увидите, что он обновился: теперь при создании героя он не ожидает получить `id` от клиента и т. д.\n\n<div class=\"screenshot\">\n<img src=\"/img/tutorial/sql-databases/image02.png\">\n</div>\n\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 25, "header": "Снова запустим приложение", "header_level": 3, "token_count": 166}
{"id": "696898571dda9e11", "text": "## Резюме { #recap }\n\nВы можете использовать <a href=\"https://sqlmodel.tiangolo.com/\" class=\"external-link\" target=\"_blank\">**SQLModel**</a> для взаимодействия с SQL базой данных и упростить код с помощью *моделей данных* и *моделей-таблиц*.\n\nГораздо больше вы можете узнать в документации **SQLModel**, там есть более подробный мини-<a href=\"https://sqlmodel.tiangolo.com/tutorial/fastapi/\" class=\"external-link\" target=\"_blank\">туториал по использованию SQLModel с **FastAPI**</a>.\n", "metadata": {"title": "SQL (реляционные) базы данных", "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "source_mtime": "2026-01-12T17:48:13.525303+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\sql-databases.md"}, "doc_id": "507bc331f995", "source_path": "docs\\tutorial\\sql-databases.md", "title": "SQL (реляционные) базы данных", "chunk_index": 26, "header": "Резюме", "header_level": 2, "token_count": 164}
{"id": "56d8ea88adc8e5a1", "text": "# Статические Файлы { #static-files }\n\nВы можете предоставлять статические файлы автоматически из директории, используя `StaticFiles`.\n\n", "metadata": {"title": "Статические Файлы", "doc_id": "52095ccdb8b1", "source_path": "docs\\tutorial\\static-files.md", "source_mtime": "2026-01-12T17:48:13.531314+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\static-files.md"}, "doc_id": "52095ccdb8b1", "source_path": "docs\\tutorial\\static-files.md", "title": "Статические Файлы", "chunk_index": 0, "header": "Статические Файлы", "header_level": 1, "token_count": 50}
{"id": "691a182e68966b1d", "text": "## Использование `StaticFiles` { #use-staticfiles }\n\n* Импортируйте `StaticFiles`.\n* \"Примонтируйте\" экземпляр `StaticFiles()` к определённому пути.\n\n{* ../../docs_src/static_files/tutorial001_py39.py hl[2,6] *}\n\n/// note | Технические детали\n\nВы также можете использовать `from starlette.staticfiles import StaticFiles`.\n\n**FastAPI** предоставляет `starlette.staticfiles` под псевдонимом `fastapi.staticfiles`, просто для вашего удобства, как разработчика. Но на самом деле это берётся напрямую из библиотеки Starlette.\n\n///\n\n", "metadata": {"title": "Статические Файлы", "doc_id": "52095ccdb8b1", "source_path": "docs\\tutorial\\static-files.md", "source_mtime": "2026-01-12T17:48:13.531314+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\static-files.md"}, "doc_id": "52095ccdb8b1", "source_path": "docs\\tutorial\\static-files.md", "title": "Статические Файлы", "chunk_index": 1, "header": "Использование `StaticFiles`", "header_level": 2, "token_count": 184}
{"id": "11474200c1a13eb8", "text": "### Что такое \"Монтирование\" { #what-is-mounting }\n\n\"Монтирование\" означает добавление полноценного \"независимого\" приложения на определённый путь, которое затем обрабатывает все подпути.\n\nЭто отличается от использования `APIRouter`, так как примонтированное приложение является полностью независимым.\nOpenAPI и документация из вашего главного приложения не будут содержать ничего из примонтированного приложения, и т.д.\n\nВы можете прочитать больше об этом в [Расширенном руководстве пользователя](../advanced/index.md){.internal-link target=_blank}.\n\n", "metadata": {"title": "Статические Файлы", "doc_id": "52095ccdb8b1", "source_path": "docs\\tutorial\\static-files.md", "source_mtime": "2026-01-12T17:48:13.531314+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\static-files.md"}, "doc_id": "52095ccdb8b1", "source_path": "docs\\tutorial\\static-files.md", "title": "Статические Файлы", "chunk_index": 2, "header": "Что такое \"Монтирование\"", "header_level": 3, "token_count": 191}
{"id": "450a0143ed77eff2", "text": "## Детали { #details }\n\nПервый параметр `\"/static\"` относится к подпути, по которому это \"подприложение\" будет \"примонтировано\". Таким образом, любой путь начинающийся со `\"/static\"` будет обработан этим приложением.\n\nПараметр `directory=\"static\"` относится к имени директории, которая содержит ваши статические файлы.\n\n`name=\"static\"` даёт имя маршруту, которое может быть использовано внутри **FastAPI**.\n\nВсе эти параметры могут отличаться от \"`static`\", настройте их в соответствии с вашими нуждами и конкретными деталями вашего собственного приложения.\n\n", "metadata": {"title": "Статические Файлы", "doc_id": "52095ccdb8b1", "source_path": "docs\\tutorial\\static-files.md", "source_mtime": "2026-01-12T17:48:13.531314+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\static-files.md"}, "doc_id": "52095ccdb8b1", "source_path": "docs\\tutorial\\static-files.md", "title": "Статические Файлы", "chunk_index": 3, "header": "Детали", "header_level": 2, "token_count": 208}
{"id": "54bc68532a619b9e", "text": "## Больше информации { #more-info }\n\nДля получения дополнительной информации о деталях и настройках ознакомьтесь с <a href=\"https://www.starlette.dev/staticfiles/\" class=\"external-link\" target=\"_blank\">Документацией Starlette о статических файлах</a>.\n", "metadata": {"title": "Статические Файлы", "doc_id": "52095ccdb8b1", "source_path": "docs\\tutorial\\static-files.md", "source_mtime": "2026-01-12T17:48:13.531314+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\static-files.md"}, "doc_id": "52095ccdb8b1", "source_path": "docs\\tutorial\\static-files.md", "title": "Статические Файлы", "chunk_index": 4, "header": "Больше информации", "header_level": 2, "token_count": 81}
{"id": "c2ac8c07127ede66", "text": "# Тестирование { #testing }\n\nБлагодаря <a href=\"https://www.starlette.dev/testclient/\" class=\"external-link\" target=\"_blank\">Starlette</a>, тестировать приложения **FastAPI** легко и приятно.\n\nТестирование основано на библиотеке <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">HTTPX</a>, которая в свою очередь основана на библиотеке Requests, так что все действия знакомы и интуитивно понятны.\n\nИспользуя эти инструменты, Вы можете напрямую задействовать <a href=\"https://docs.pytest.org/\" class=\"external-link\" target=\"_blank\">pytest</a> с **FastAPI**.\n\n", "metadata": {"title": "Тестирование", "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "source_mtime": "2026-01-12T17:48:13.540219+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\testing.md"}, "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "title": "Тестирование", "chunk_index": 0, "header": "Тестирование", "header_level": 1, "token_count": 204}
{"id": "c2ac8c07127ede66", "text": "## Использование класса `TestClient` { #using-testclient }\n\n/// info | Информация\n\nДля использования класса `TestClient` сначала установите <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">`httpx`</a>.\n\nУбедитесь, что Вы создали [виртуальное окружение](../virtual-environments.md){.internal-link target=_blank}, активировали его, а затем установили пакет, например:\n\n```console\n$ pip install httpx\n```\n\n///\n\nИмпортируйте `TestClient`.\n\nСоздайте объект `TestClient`, передав ему в качестве параметра Ваше приложение **FastAPI**.\n\nСоздайте функцию, название которой должно начинаться с `test_` (это стандарт из соглашений `pytest`).\n\nИспользуйте объект `TestClient` так же, как Вы используете `httpx`.\n\nНапишите простое утверждение с `assert` дабы проверить истинность Python-выражения (это тоже стандарт `pytest`).\n\n{* ../../docs_src/app_testing/tutorial001_py39.py hl[2,12,15:18] *}\n\n/// tip | Подсказка\n\nОбратите внимание, что тестирующая функция является обычной `def`, а не асинхронной `async def`.\n\nИ вызов клиента также осуществляется без `await`.\n\nЭто позволяет вам использовать `pytest` без лишних усложнений.\n\n///\n\n/// note | Технические детали\n\nТакже можно написать `from starlette.testclient import TestClient`.\n\n**FastAPI** предоставляет тот же самый `starlette.testclient` как `fastapi.testclient`. Это всего лишь небольшое удобство для Вас, как разработчика. Но он берётся напрямую из Starlette.\n\n///\n\n/// tip | Подсказка", "metadata": {"title": "Тестирование", "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "source_mtime": "2026-01-12T17:48:13.540219+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\testing.md", "section_header": "Использование класса `TestClient`", "section_header_level": 2}, "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "title": "Тестирование", "chunk_index": 1, "header": "Использование класса `TestClient`", "header_level": 2, "token_count": 510}
{"id": "eb2380e29dc435c8", "text": ".testclient` как `fastapi.testclient`. Это всего лишь небольшое удобство для Вас, как разработчика. Но он берётся напрямую из Starlette.\n\n///\n\n/// tip | Подсказка\n\nЕсли для тестирования Вам, помимо запросов к приложению FastAPI, необходимо вызывать асинхронные функции (например, для подключения к базе данных с помощью асинхронного драйвера), то ознакомьтесь со страницей [Асинхронное тестирование](../advanced/async-tests.md){.internal-link target=_blank} в расширенном руководстве.\n\n///", "metadata": {"title": "Тестирование", "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "source_mtime": "2026-01-12T17:48:13.540219+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\testing.md", "section_header": "Использование класса `TestClient`", "section_header_level": 2}, "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "title": "Тестирование", "chunk_index": 2, "header": "Использование класса `TestClient`", "header_level": 2, "token_count": 186}
{"id": "1e352925d9bfbbbe", "text": "## Разделение тестов { #separating-tests }\n\nВ реальном приложении Вы, вероятно, разместите тесты в отдельном файле.\n\nКроме того, Ваше приложение **FastAPI** может состоять из нескольких файлов, модулей и т.п.\n\n", "metadata": {"title": "Тестирование", "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "source_mtime": "2026-01-12T17:48:13.540219+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\testing.md"}, "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "title": "Тестирование", "chunk_index": 3, "header": "Разделение тестов", "header_level": 2, "token_count": 84}
{"id": "4291461738220960", "text": "### Файл приложения **FastAPI** { #fastapi-app-file }\n\nДопустим, структура файлов Вашего приложения похожа на ту, что описана на странице [Более крупные приложения](bigger-applications.md){.internal-link target=_blank}:\n\n```\n.\n├── app\n│   ├── __init__.py\n│   └── main.py\n```\n\nВ файле `main.py` находится Ваше приложение **FastAPI**:\n\n{* ../../docs_src/app_testing/app_a_py39/main.py *}\n\n", "metadata": {"title": "Тестирование", "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "source_mtime": "2026-01-12T17:48:13.540219+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\testing.md"}, "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "title": "Тестирование", "chunk_index": 4, "header": "Файл приложения **FastAPI**", "header_level": 3, "token_count": 137}
{"id": "341a39352059497b", "text": "### Файл тестов { #testing-file }\n\nТакже у Вас может быть файл `test_main.py` содержащий тесты. Можно разместить тестовый файл и файл приложения в одной директории (в директориях для Python-кода желательно размещать и файл `__init__.py`):\n\n``` hl_lines=\"5\"\n.\n├── app\n│   ├── __init__.py\n│   ├── main.py\n│   └── test_main.py\n```\n\nТак как оба файла находятся в одной директории, для импорта объекта приложения из файла `main` в файл `test_main` Вы можете использовать относительный импорт:\n\n{* ../../docs_src/app_testing/app_a_py39/test_main.py hl[3] *}\n\n...и писать дальше тесты, как и раньше.\n\n", "metadata": {"title": "Тестирование", "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "source_mtime": "2026-01-12T17:48:13.540219+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\testing.md"}, "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "title": "Тестирование", "chunk_index": 5, "header": "Файл тестов", "header_level": 3, "token_count": 218}
{"id": "df00b590fd160690", "text": "## Тестирование: расширенный пример { #testing-extended-example }\n\nТеперь давайте расширим наш пример и добавим деталей, чтоб посмотреть, как тестировать различные части приложения.\n\n", "metadata": {"title": "Тестирование", "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "source_mtime": "2026-01-12T17:48:13.540219+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\testing.md"}, "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "title": "Тестирование", "chunk_index": 6, "header": "Тестирование: расширенный пример", "header_level": 2, "token_count": 67}
{"id": "575e1b94025e2a5d", "text": "### Расширенный файл приложения **FastAPI** { #extended-fastapi-app-file }\n\nМы продолжим работу с той же файловой структурой, что и ранее:\n\n```\n.\n├── app\n│   ├── __init__.py\n│   ├── main.py\n│   └── test_main.py\n```\n\nПредположим, что в файле `main.py` с приложением **FastAPI** есть несколько **операций пути**.\n\nВ нём описана операция `GET`, которая может вернуть ошибку.\n\nЕщё есть операция `POST`, и она может вернуть несколько ошибок.\n\nОбе *операции пути* требуют наличия в запросе заголовка `X-Token`.\n\n{* ../../docs_src/app_testing/app_b_an_py310/main.py *}\n\n", "metadata": {"title": "Тестирование", "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "source_mtime": "2026-01-12T17:48:13.540219+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\testing.md"}, "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "title": "Тестирование", "chunk_index": 7, "header": "Расширенный файл приложения **FastAPI**", "header_level": 3, "token_count": 206}
{"id": "c2ac8c07127ede66", "text": "### Расширенный файл тестов { #extended-testing-file }\n\nТеперь обновим файл `test_main.py`, добавив в него тестов:\n\n{* ../../docs_src/app_testing/app_b_an_py310/test_main.py *}\n\nЕсли Вы не знаете, как передать информацию в запросе, можете воспользоваться поисковиком (погуглить) и задать вопрос: \"Как передать информацию в запросе с помощью `httpx`\", можно даже спросить: \"Как передать информацию в запросе с помощью `requests`\", поскольку дизайн HTTPX основан на дизайне Requests.\n\nЗатем Вы просто применяете найденные ответы в тестах.\n\nНапример:\n\n* Передаёте *path*-параметры или *query*-параметры, вписав их непосредственно в строку URL.\n* Передаёте JSON в теле запроса, передав Python-объект (например: `dict`) через именованный параметр `json`.\n* Если же Вам необходимо отправить *форму с данными* вместо JSON, то используйте параметр `data` вместо `json`.\n* Для передачи *заголовков*, передайте объект `dict` через параметр `headers`.\n* Для передачи *cookies* также передайте `dict`, но через параметр `cookies`.\n\nДля получения дополнительной информации о передаче данных на бэкенд с помощью `httpx` или `TestClient` ознакомьтесь с <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">документацией HTTPX</a>.\n\n/// info | Информация\n\nОбратите внимание, что `TestClient` принимает данные, которые можно конвертировать в JSON, но не модели Pydantic.", "metadata": {"title": "Тестирование", "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "source_mtime": "2026-01-12T17:48:13.540219+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\testing.md", "section_header": "Расширенный файл тестов", "section_header_level": 3}, "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "title": "Тестирование", "chunk_index": 8, "header": "Расширенный файл тестов", "header_level": 3, "token_count": 487}
{"id": "eb2380e29dc435c8", "text": "class=\"external-link\" target=\"_blank\">документацией HTTPX</a>.\n\n/// info | Информация\n\nОбратите внимание, что `TestClient` принимает данные, которые можно конвертировать в JSON, но не модели Pydantic.\n\nЕсли в Ваших тестах есть модели Pydantic и Вы хотите отправить их в тестируемое приложение, то можете использовать функцию `jsonable_encoder`, описанную на странице [Кодировщик совместимый с JSON](encoder.md){.internal-link target=_blank}.\n\n///", "metadata": {"title": "Тестирование", "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "source_mtime": "2026-01-12T17:48:13.540219+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\testing.md", "section_header": "Расширенный файл тестов", "section_header_level": 3}, "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "title": "Тестирование", "chunk_index": 9, "header": "Расширенный файл тестов", "header_level": 3, "token_count": 146}
{"id": "968726480348d8c4", "text": "## Запуск { #run-it }\n\nДалее Вам нужно установить `pytest`.\n\nУбедитесь, что Вы создали [виртуальное окружение](../virtual-environments.md){.internal-link target=_blank}, активировали его, а затем установили пакет, например:\n\n<div class=\"termy\">\n\n```console\n$ pip install pytest\n\n---> 100%\n```\n\n</div>\n\nОн автоматически найдёт все файлы и тесты, выполнит их и предоставит Вам отчёт о результатах тестирования.\n\nЗапустите тесты:\n\n<div class=\"termy\">\n\n```console\n$ pytest\n\n================ test session starts ================\nplatform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1\nrootdir: /home/user/code/superawesome-cli/app\nplugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1\ncollected 6 items\n\n---> 100%\n\ntest_main.py <span style=\"color: green; white-space: pre;\">......                            [100%]</span>\n\n<span style=\"color: green;\">================= 1 passed in 0.03s =================</span>\n```\n\n</div>\n", "metadata": {"title": "Тестирование", "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "source_mtime": "2026-01-12T17:48:13.540219+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\testing.md"}, "doc_id": "d73eb8a9544b", "source_path": "docs\\tutorial\\testing.md", "title": "Тестирование", "chunk_index": 10, "header": "Запуск", "header_level": 2, "token_count": 311}
{"id": "42e40b82a971ee16", "text": "# Классы как зависимости { #classes-as-dependencies }\n\nПрежде чем углубиться в систему **Внедрения Зависимостей**, давайте обновим предыдущий пример.\n\n", "metadata": {"title": "Классы как зависимости", "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "source_mtime": "2026-01-12T17:48:13.547222+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\classes-as-dependencies.md"}, "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "title": "Классы как зависимости", "chunk_index": 0, "header": "Классы как зависимости", "header_level": 1, "token_count": 59}
{"id": "9d323cc08dd9712a", "text": "## `dict` из предыдущего примера { #a-dict-from-the-previous-example }\n\nВ предыдущем примере мы возвращали `dict` из нашей зависимости:\n\n{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[9] *}\n\nНо затем мы получаем `dict` в параметре `commons` *функции-обработчика пути*.\n\nИ мы знаем, что редакторы кода не могут обеспечить достаточную поддержку (например, автозавершение) для `dict`, поскольку они не могут знать их ключи и типы значений.\n\nМы можем сделать лучше...\n\n", "metadata": {"title": "Классы как зависимости", "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "source_mtime": "2026-01-12T17:48:13.547222+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\classes-as-dependencies.md"}, "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "title": "Классы как зависимости", "chunk_index": 1, "header": "`dict` из предыдущего примера", "header_level": 2, "token_count": 180}
{"id": "48d133dc64d07e57", "text": "## Что делает зависимость { #what-makes-a-dependency }\n\nДо сих пор вы видели зависимости, объявленные как функции.\n\nНо это не единственный способ объявления зависимостей (хотя он, вероятно, более распространенный).\n\nКлючевым фактором является то, что зависимость должна быть «вызываемой».\n\nВ Python «**вызываемый**» — это всё, что Python может «вызвать», как функцию.\n\nТак, если у вас есть объект `something` (который может и _не_ быть функцией) и вы можете «вызвать» его (выполнить) так:\n\n```Python\nsomething()\n```\n\nили\n\n```Python\nsomething(some_argument, some_keyword_argument=\"foo\")\n```\n\nв таком случае он является «вызываемым».\n\n", "metadata": {"title": "Классы как зависимости", "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "source_mtime": "2026-01-12T17:48:13.547222+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\classes-as-dependencies.md"}, "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "title": "Классы как зависимости", "chunk_index": 2, "header": "Что делает зависимость", "header_level": 2, "token_count": 237}
{"id": "42e40b82a971ee16", "text": "## Классы как зависимости { #classes-as-dependencies_1 }\n\nВы можете заметить, что для создания экземпляра класса в Python используется тот же синтаксис.\n\nНапример:\n\n```Python\nclass Cat:\n    def __init__(self, name: str):\n        self.name = name\n\n\nfluffy = Cat(name=\"Mr Fluffy\")\n```\n\nВ данном случае `fluffy` является экземпляром класса `Cat`.\n\nА чтобы создать `fluffy`, вы «вызываете» `Cat`.\n\nТаким образом, класс в Python также является **вызываемым**.\n\nТогда в **FastAPI** в качестве зависимости можно использовать класс Python.\n\nНа самом деле FastAPI проверяет, что переданный объект является «вызываемым» (функция, класс или что-либо еще) и какие параметры у него определены.\n\nЕсли вы передаёте «вызываемый» объект в качестве зависимости в **FastAPI**, он проанализирует параметры, необходимые для этого «вызываемого» объекта, и обработает их так же, как параметры *функции-обработчика пути*. Включая подзависимости.\n\nЭто относится и к вызываемым объектам без параметров. Работа с ними происходит точно так же, как и для *функций-обработчиков пути* без параметров.\n\nТеперь мы можем изменить зависимость `common_parameters`, указанную выше, на класс `CommonQueryParams`:\n\n{* ../../docs_src/dependencies/tutorial002_an_py310.py hl[11:15] *}\n\nОбратите внимание на метод `__init__`, используемый для создания экземпляра класса:\n\n{* ../../docs_src/dependencies/tutorial002_an_py310.py hl[12] *}", "metadata": {"title": "Классы как зависимости", "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "source_mtime": "2026-01-12T17:48:13.547222+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\classes-as-dependencies.md", "section_header": "Классы как зависимости", "section_header_level": 2}, "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "title": "Классы как зависимости", "chunk_index": 3, "header": "Классы как зависимости", "header_level": 2, "token_count": 489}
{"id": "9d323cc08dd9712a", "text": "docs_src/dependencies/tutorial002_an_py310.py hl[11:15] *}\n\nОбратите внимание на метод `__init__`, используемый для создания экземпляра класса:\n\n{* ../../docs_src/dependencies/tutorial002_an_py310.py hl[12] *}\n\n...он имеет те же параметры, что и ранее используемая функция `common_parameters`:\n\n{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[8] *}\n\nЭти параметры и будут использоваться **FastAPI** для «решения» зависимости.\n\nВ обоих случаях она будет иметь:\n\n* Необязательный параметр запроса `q`, представляющий собой `str`.\n* Параметр запроса `skip`, представляющий собой `int`, по умолчанию `0`.\n* Параметр запроса `limit`, представляющий собой `int`, по умолчанию `100`.\n\nВ обоих случаях данные будут конвертированы, валидированы, задокументированы в схеме OpenAPI и т.д.", "metadata": {"title": "Классы как зависимости", "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "source_mtime": "2026-01-12T17:48:13.547222+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\classes-as-dependencies.md", "section_header": "Классы как зависимости", "section_header_level": 2}, "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "title": "Классы как зависимости", "chunk_index": 4, "header": "Классы как зависимости", "header_level": 2, "token_count": 270}
{"id": "764dbfd84297b706", "text": "## Как это использовать { #use-it }\n\nТеперь вы можете объявить свою зависимость, используя этот класс.\n\n{* ../../docs_src/dependencies/tutorial002_an_py310.py hl[19] *}\n\n**FastAPI** вызывает класс `CommonQueryParams`. При этом создается «экземпляр» этого класса, который будет передан в качестве параметра `commons` в вашу функцию.\n\n", "metadata": {"title": "Классы как зависимости", "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "source_mtime": "2026-01-12T17:48:13.547222+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\classes-as-dependencies.md"}, "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "title": "Классы как зависимости", "chunk_index": 5, "header": "Как это использовать", "header_level": 2, "token_count": 107}
{"id": "42e40b82a971ee16", "text": "## Аннотация типа и `Depends` { #type-annotation-vs-depends }\n\nОбратите внимание, что в приведенном выше коде мы два раза пишем `CommonQueryParams`:\n\n//// tab | Python 3.9+\n\n```Python\ncommons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]\n```\n\n////\n\n//// tab | Python 3.9+ non-Annotated\n\n/// tip | Подсказка\n\nРекомендуется использовать версию с `Annotated`, если возможно.\n\n///\n\n```Python\ncommons: CommonQueryParams = Depends(CommonQueryParams)\n```\n\n////\n\nПоследний `CommonQueryParams`, в:\n\n```Python\n... Depends(CommonQueryParams)\n```\n\n...это то, что **FastAPI** будет использовать, чтобы узнать, что является зависимостью.\n\nИз него FastAPI извлечёт объявленные параметры, и именно его FastAPI будет вызывать.\n\n---\n\nВ этом случае первый `CommonQueryParams`, в:\n\n//// tab | Python 3.9+\n\n```Python\ncommons: Annotated[CommonQueryParams, ...\n```\n\n////\n\n//// tab | Python 3.9+ non-Annotated\n\n/// tip | Подсказка\n\nРекомендуется использовать версию с `Annotated`, если возможно.\n\n///\n\n```Python\ncommons: CommonQueryParams ...\n```\n\n////\n\n...не имеет никакого специального значения для **FastAPI**. FastAPI не будет использовать его для преобразования данных, валидации и т.д. (поскольку для этого используется `Depends(CommonQueryParams)`).\n\nНа самом деле можно написать просто:\n\n//// tab | Python 3.9+\n\n```Python\ncommons: Annotated[Any, Depends(CommonQueryParams)]\n```\n\n////\n\n//// tab | Python 3.9+ non-Annotated\n\n/// tip | Подсказка\n\nРекомендуется использовать версию с `Annotated`, если возможно.\n\n///\n\n```Python\ncommons = Depends(CommonQueryParams)\n```\n\n////\n\n...как тут:", "metadata": {"title": "Классы как зависимости", "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "source_mtime": "2026-01-12T17:48:13.547222+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\classes-as-dependencies.md", "section_header": "Аннотация типа и `Depends`", "section_header_level": 2}, "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "title": "Классы как зависимости", "chunk_index": 6, "header": "Аннотация типа и `Depends`", "header_level": 2, "token_count": 511}
{"id": "9d323cc08dd9712a", "text": "| Python 3.9+ non-Annotated\n\n/// tip | Подсказка\n\nРекомендуется использовать версию с `Annotated`, если возможно.\n\n///\n\n```Python\ncommons = Depends(CommonQueryParams)\n```\n\n////\n\n...как тут:\n\n{* ../../docs_src/dependencies/tutorial003_an_py310.py hl[19] *}\n\nНо объявление типа приветствуется, так как в этом случае ваш редактор кода будет знать, что будет передано в качестве параметра `commons`, и тогда он сможет помочь вам с автозавершением, проверкой типов и т.д.:\n\n<img src=\"/img/tutorial/dependencies/image02.png\">", "metadata": {"title": "Классы как зависимости", "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "source_mtime": "2026-01-12T17:48:13.547222+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\classes-as-dependencies.md", "section_header": "Аннотация типа и `Depends`", "section_header_level": 2}, "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "title": "Классы как зависимости", "chunk_index": 7, "header": "Аннотация типа и `Depends`", "header_level": 2, "token_count": 175}
{"id": "42e40b82a971ee16", "text": "## Сокращение { #shortcut }\n\nНо вы видите, что здесь мы имеем некоторое повторение кода, дважды написав `CommonQueryParams`:\n\n//// tab | Python 3.9+\n\n```Python\ncommons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]\n```\n\n////\n\n//// tab | Python 3.9+ non-Annotated\n\n/// tip | Подсказка\n\nРекомендуется использовать версию с `Annotated`, если возможно.\n\n///\n\n```Python\ncommons: CommonQueryParams = Depends(CommonQueryParams)\n```\n\n////\n\n**FastAPI** предоставляет сокращение для таких случаев, когда зависимость — это *конкретный* класс, который **FastAPI** будет «вызывать» для создания экземпляра этого класса.\n\nДля этих конкретных случаев вы можете сделать следующее.\n\nВместо того чтобы писать:\n\n//// tab | Python 3.9+\n\n```Python\ncommons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]\n```\n\n////\n\n//// tab | Python 3.9+ non-Annotated\n\n/// tip | Подсказка\n\nРекомендуется использовать версию с `Annotated`, если возможно.\n\n///\n\n```Python\ncommons: CommonQueryParams = Depends(CommonQueryParams)\n```\n\n////\n\n...следует написать:\n\n//// tab | Python 3.9+\n\n```Python\ncommons: Annotated[CommonQueryParams, Depends()]\n```\n\n////\n\n//// tab | Python 3.9+ non-Annotated\n\n/// tip | Подсказка\n\nРекомендуется использовать версию с `Annotated`, если возможно.\n\n///\n\n```Python\ncommons: CommonQueryParams = Depends()\n```\n\n////\n\nВы объявляете зависимость как тип параметра и используете `Depends()` без какого-либо параметра, вместо того чтобы *снова* писать полный класс внутри `Depends(CommonQueryParams)`.", "metadata": {"title": "Классы как зависимости", "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "source_mtime": "2026-01-12T17:48:13.547222+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\classes-as-dependencies.md", "section_header": "Сокращение", "section_header_level": 2}, "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "title": "Классы как зависимости", "chunk_index": 8, "header": "Сокращение", "header_level": 2, "token_count": 492}
{"id": "9d323cc08dd9712a", "text": "Вы объявляете зависимость как тип параметра и используете `Depends()` без какого-либо параметра, вместо того чтобы *снова* писать полный класс внутри `Depends(CommonQueryParams)`.\n\nАналогичный пример будет выглядеть следующим образом:\n\n{* ../../docs_src/dependencies/tutorial004_an_py310.py hl[19] *}\n\n...и **FastAPI** будет знать, что делать.\n\n/// tip | Подсказка\n\nЕсли это покажется вам более запутанным, чем полезным, не обращайте внимания — это вам не *нужно*.\n\nЭто просто сокращение. Потому что **FastAPI** заботится о том, чтобы помочь вам свести к минимуму повторение кода.\n\n///", "metadata": {"title": "Классы как зависимости", "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "source_mtime": "2026-01-12T17:48:13.547222+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\classes-as-dependencies.md", "section_header": "Сокращение", "section_header_level": 2}, "doc_id": "d23d01739d9c", "source_path": "docs\\tutorial\\dependencies\\classes-as-dependencies.md", "title": "Классы как зависимости", "chunk_index": 9, "header": "Сокращение", "header_level": 2, "token_count": 216}
{"id": "4e4fef6500820a96", "text": "# Зависимости в декораторах операции пути { #dependencies-in-path-operation-decorators }\n\nВ некоторых случаях, возвращаемое значение зависимости не используется внутри *функции операции пути*.\n\nИли же зависимость не возвращает никакого значения.\n\nНо вам всё-таки нужно, чтобы она выполнилась.\n\nДля таких ситуаций, вместо объявления *функции операции пути* с параметром `Depends`, вы можете добавить список зависимостей `dependencies` в *декоратор операции пути*.\n\n", "metadata": {"title": "Зависимости в декораторах операции пути", "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "source_mtime": "2026-01-12T17:48:13.564963+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md"}, "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "title": "Зависимости в декораторах операции пути", "chunk_index": 0, "header": "Зависимости в декораторах операции пути", "header_level": 1, "token_count": 168}
{"id": "282b1770609bb18e", "text": "## Добавление `dependencies` (зависимостей) в *декоратор операции пути* { #add-dependencies-to-the-path-operation-decorator }\n\n*Декоратор операции пути* получает необязательный аргумент `dependencies`.\n\nЭто должен быть `list` состоящий из `Depends()`:\n\n{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[19] *}\n\nЗависимости из dependencies выполнятся так же, как и обычные зависимости. Но их значения (если они были) не будут переданы в *функцию операции пути*.\n\n/// tip | Подсказка\n\nНекоторые редакторы кода определяют неиспользуемые параметры функций и подсвечивают их как ошибку.\n\nИспользование `dependencies` в *декораторе операции пути* гарантирует выполнение зависимостей, избегая при этом предупреждений редактора кода и других инструментов.\n\nЭто также должно помочь предотвратить путаницу у начинающих разработчиков, которые видят неиспользуемые параметры в коде и могут подумать что в них нет необходимости.\n\n///\n\n/// info | Примечание\n\nВ этом примере мы используем выдуманные пользовательские заголовки `X-Key` и `X-Token`.\n\nНо в реальных проектах, при внедрении системы безопасности, вы получите больше пользы используя интегрированные [средства защиты (следующая глава)](../security/index.md){.internal-link target=_blank}.\n\n///\n\n", "metadata": {"title": "Зависимости в декораторах операции пути", "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "source_mtime": "2026-01-12T17:48:13.564963+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md"}, "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "title": "Зависимости в декораторах операции пути", "chunk_index": 1, "header": "Добавление `dependencies` (зависимостей) в *декоратор операции пути*", "header_level": 2, "token_count": 443}
{"id": "d9ef96810f8f60c2", "text": "## Исключения в Зависимостях и возвращаемые значения { #dependencies-errors-and-return-values }\n\nВы можете использовать те же *функции* зависимостей, что и обычно.\n\n", "metadata": {"title": "Зависимости в декораторах операции пути", "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "source_mtime": "2026-01-12T17:48:13.564963+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md"}, "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "title": "Зависимости в декораторах операции пути", "chunk_index": 2, "header": "Исключения в Зависимостях и возвращаемые значения", "header_level": 2, "token_count": 54}
{"id": "33deda6ce11ba3dd", "text": "### Требования к зависимостям { #dependency-requirements }\n\nОни могут объявлять требования к запросу (например заголовки) или другие подзависимости:\n\n{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[8,13] *}\n\n", "metadata": {"title": "Зависимости в декораторах операции пути", "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "source_mtime": "2026-01-12T17:48:13.564963+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md"}, "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "title": "Зависимости в декораторах операции пути", "chunk_index": 3, "header": "Требования к зависимостям", "header_level": 3, "token_count": 74}
{"id": "29ea8a1c7f61b76d", "text": "### Вызов исключений { #raise-exceptions }\n\nЗависимости из dependencies могут вызывать исключения с помощью `raise`, как и обычные зависимости:\n\n{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[10,15] *}\n\n", "metadata": {"title": "Зависимости в декораторах операции пути", "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "source_mtime": "2026-01-12T17:48:13.564963+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md"}, "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "title": "Зависимости в декораторах операции пути", "chunk_index": 4, "header": "Вызов исключений", "header_level": 3, "token_count": 68}
{"id": "2caf8df9a48ca3b2", "text": "### Возвращаемые значения { #return-values }\n\nИ они могут возвращать значения или нет, эти значения использоваться не будут.\n\nТаким образом, вы можете переиспользовать обычную зависимость (возвращающую значение), которую вы уже используете где-то в другом месте, и хотя значение не будет использоваться, зависимость будет выполнена:\n\n{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[11,16] *}\n\n", "metadata": {"title": "Зависимости в декораторах операции пути", "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "source_mtime": "2026-01-12T17:48:13.564963+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md"}, "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "title": "Зависимости в декораторах операции пути", "chunk_index": 5, "header": "Возвращаемые значения", "header_level": 3, "token_count": 120}
{"id": "b1b254498605cd67", "text": "## Зависимости для группы *операций путей* { #dependencies-for-a-group-of-path-operations }\n\nПозже, читая о том как структурировать большие приложения ([Большие приложения — несколько файлов](../../tutorial/bigger-applications.md){.internal-link target=_blank}), возможно, многофайловые, вы узнаете как объявить единый параметр `dependencies` для всей группы *операций путей*.\n\n", "metadata": {"title": "Зависимости в декораторах операции пути", "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "source_mtime": "2026-01-12T17:48:13.564963+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md"}, "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "title": "Зависимости в декораторах операции пути", "chunk_index": 6, "header": "Зависимости для группы *операций путей*", "header_level": 2, "token_count": 131}
{"id": "8195edb9225aaf36", "text": "## Глобальные Зависимости { #global-dependencies }\n\nДалее мы увидим, как можно добавить dependencies для всего `FastAPI` приложения, так чтобы они применялись к каждой *операции пути*.\n", "metadata": {"title": "Зависимости в декораторах операции пути", "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "source_mtime": "2026-01-12T17:48:13.564963+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md"}, "doc_id": "c58a2a74ce38", "source_path": "docs\\tutorial\\dependencies\\dependencies-in-path-operation-decorators.md", "title": "Зависимости в декораторах операции пути", "chunk_index": 7, "header": "Глобальные Зависимости", "header_level": 2, "token_count": 65}
{"id": "86854c76506176b7", "text": "# Зависимости с yield { #dependencies-with-yield }\n\nFastAPI поддерживает зависимости, которые выполняют некоторые <abbr title='иногда также называемые \"exit code\", \"cleanup code\", \"teardown code\", \"closing code\", \"context manager exit code\" и т.п.'>дополнительные шаги после завершения</abbr>.\n\nДля этого используйте `yield` вместо `return`, а дополнительные шаги (код) напишите после него.\n\n/// tip | Подсказка\n\nУбедитесь, что используете `yield` только один раз на одну зависимость.\n\n///\n\n/// note | Технические детали\n\nЛюбая функция, с которой можно корректно использовать:\n\n* <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager\" class=\"external-link\" target=\"_blank\">`@contextlib.contextmanager`</a> или\n* <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager\" class=\"external-link\" target=\"_blank\">`@contextlib.asynccontextmanager`</a>\n\nбудет корректной для использования в качестве зависимости **FastAPI**.\n\nНа самом деле, FastAPI использует эти два декоратора внутренне.\n\n///\n\n", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md"}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 0, "header": "Зависимости с yield", "header_level": 1, "token_count": 340}
{"id": "d30117d6a073ddfb", "text": "## Зависимость базы данных с помощью `yield` { #a-database-dependency-with-yield }\n\nНапример, с его помощью можно создать сессию работы с базой данных и закрыть её после завершения.\n\nПеред созданием ответа будет выполнен только код до и включая оператор `yield`:\n\n{* ../../docs_src/dependencies/tutorial007_py39.py hl[2:4] *}\n\nЗначение, полученное из `yield`, внедряется в *операции пути* и другие зависимости:\n\n{* ../../docs_src/dependencies/tutorial007_py39.py hl[4] *}\n\nКод, следующий за оператором `yield`, выполняется после ответа:\n\n{* ../../docs_src/dependencies/tutorial007_py39.py hl[5:6] *}\n\n/// tip | Подсказка\n\nМожно использовать как `async`, так и обычные функции.\n\n**FastAPI** корректно обработает каждый вариант, так же как и с обычными зависимостями.\n\n///\n\n", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md"}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 1, "header": "Зависимость базы данных с помощью `yield`", "header_level": 2, "token_count": 258}
{"id": "a9285203dc889f36", "text": "## Зависимость с `yield` и `try` { #a-dependency-with-yield-and-try }\n\nЕсли использовать блок `try` в зависимости с `yield`, то вы получите любое исключение, которое было выброшено при использовании зависимости.\n\nНапример, если какой-то код в какой-то момент в середине, в другой зависимости или в *операции пути*, сделал \"откат\" транзакции базы данных или создал любую другую ошибку, то вы получите это исключение в своей зависимости.\n\nТаким образом, можно искать конкретное исключение внутри зависимости с помощью `except SomeException`.\n\nТочно так же можно использовать `finally`, чтобы убедиться, что обязательные шаги при выходе выполнены независимо от того, было ли исключение или нет.\n\n{* ../../docs_src/dependencies/tutorial007_py39.py hl[3,5] *}\n\n", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md"}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 2, "header": "Зависимость с `yield` и `try`", "header_level": 2, "token_count": 269}
{"id": "86854c76506176b7", "text": "## Подзависимости с `yield` { #sub-dependencies-with-yield }\n\nВы можете иметь подзависимости и \"деревья\" подзависимостей любого размера и формы, и любая из них или все они могут использовать `yield`.\n\n**FastAPI** проследит за тем, чтобы «код выхода» в каждой зависимости с `yield` выполнялся в правильном порядке.\n\nНапример, `dependency_c` может зависеть от `dependency_b`, а `dependency_b` — от `dependency_a`:\n\n{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[6,14,22] *}\n\nИ все они могут использовать `yield`.\n\nВ этом случае `dependency_c` для выполнения своего кода выхода нуждается в том, чтобы значение из `dependency_b` (здесь `dep_b`) всё ещё было доступно.\n\nИ, в свою очередь, `dependency_b` нуждается в том, чтобы значение из `dependency_a` (здесь `dep_a`) было доступно для её кода выхода.\n\n{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[18:19,26:27] *}\n\nТочно так же можно иметь часть зависимостей с `yield`, часть — с `return`, и какие-то из них могут зависеть друг от друга.\n\nЛибо у вас может быть одна зависимость, которая требует несколько других зависимостей с `yield` и т.д.\n\nКомбинации зависимостей могут быть какими угодно.\n\n**FastAPI** проследит за тем, чтобы всё выполнялось в правильном порядке.\n\n/// note | Технические детали", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md", "section_header": "Подзависимости с `yield`", "section_header_level": 2}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 3, "header": "Подзависимости с `yield`", "header_level": 2, "token_count": 465}
{"id": "d30117d6a073ddfb", "text": "омбинации зависимостей могут быть какими угодно.\n\n**FastAPI** проследит за тем, чтобы всё выполнялось в правильном порядке.\n\n/// note | Технические детали\n\nЭто работает благодаря <a href=\"https://docs.python.org/3/library/contextlib.html\" class=\"external-link\" target=\"_blank\">менеджерам контекста</a> в Python.\n\n**FastAPI** использует их внутренне для достижения этого.\n\n///", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md", "section_header": "Подзависимости с `yield`", "section_header_level": 2}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 4, "header": "Подзависимости с `yield`", "header_level": 2, "token_count": 136}
{"id": "d5d091518685a23f", "text": "## Зависимости с `yield` и `HTTPException` { #dependencies-with-yield-and-httpexception }\n\nВы видели, что можно использовать зависимости с `yield` и иметь блоки `try`, которые пытаются выполнить некоторый код, а затем запускают код выхода в `finally`.\n\nТакже вы можете использовать `except`, чтобы поймать вызванное исключение и что-то с ним сделать.\n\nНапример, вы можете <abbr title=\"«raise» дословно - «поднять», но «вызвать», «сгенерировать» или «выбросить» употребляется чаще\">вызвать</abbr> другое исключение, например `HTTPException`.\n\n/// tip | Подсказка\n\nЭто довольно продвинутая техника, и в большинстве случаев она вам не понадобится, так как вы можете вызывать исключения (включая `HTTPException`) в остальном коде вашего приложения, например, в *функции-обработчике пути*.\n\nНо если понадобится — возможность есть. \n\n///\n\n{* ../../docs_src/dependencies/tutorial008b_an_py39.py hl[18:22,31] *}\n\nЕсли вы хотите перехватывать исключения и формировать на их основе пользовательский ответ, создайте [Пользовательский обработчик исключений](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}.\n\n", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md"}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 5, "header": "Зависимости с `yield` и `HTTPException`", "header_level": 2, "token_count": 409}
{"id": "e4ac13bdad4f260e", "text": "## Зависимости с `yield` и `except` { #dependencies-with-yield-and-except }\n\nЕсли вы ловите исключение с помощью `except` в зависимости с `yield` и не вызываете его снова (или не вызываете новое исключение), FastAPI не сможет заметить, что было исключение — так же, как это происходит в обычном Python:\n\n{* ../../docs_src/dependencies/tutorial008c_an_py39.py hl[15:16] *}\n\nВ этом случае клиент получит *HTTP 500 Internal Server Error*, как и должно быть, поскольку мы не вызываем `HTTPException` или что-то подобное, но на сервере **не будет никаких логов** или других указаний на то, какая была ошибка. \n\n", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md"}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 6, "header": "Зависимости с `yield` и `except`", "header_level": 2, "token_count": 208}
{"id": "dc2aeb31f2a230ee", "text": "### Всегда делайте `raise` в зависимостях с `yield` и `except` { #always-raise-in-dependencies-with-yield-and-except }\n\nЕсли вы ловите исключение в зависимости с `yield`, то, если вы не вызываете другой `HTTPException` или что-то подобное, вам следует повторно вызвать исходное исключение.\n\nВы можете повторно вызвать то же самое исключение с помощью `raise`:\n\n{* ../../docs_src/dependencies/tutorial008d_an_py39.py hl[17] *}\n\nТеперь клиент получит тот же *HTTP 500 Internal Server Error*, но на сервере в логах будет наше пользовательское `InternalError`. \n\n", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md"}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 7, "header": "Всегда делайте `raise` в зависимостях с `yield` и `except`", "header_level": 3, "token_count": 188}
{"id": "86854c76506176b7", "text": "## Выполнение зависимостей с `yield` { #execution-of-dependencies-with-yield }\n\nПоследовательность выполнения примерно такая, как на этой схеме. Время течёт сверху вниз. А каждый столбец — это одна из частей, взаимодействующих с кодом или выполняющих код.\n\n```mermaid\nsequenceDiagram\n\nparticipant client as Client\nparticipant handler as Exception handler\nparticipant dep as Dep with yield\nparticipant operation as Path Operation\nparticipant tasks as Background tasks\n\n    Note over client,operation: Can raise exceptions, including HTTPException\n    client ->> dep: Start request\n    Note over dep: Run code up to yield\n    opt raise Exception\n        dep -->> handler: Raise Exception\n        handler -->> client: HTTP error response\n    end\n    dep ->> operation: Run dependency, e.g. DB session\n    opt raise\n        operation -->> dep: Raise Exception (e.g. HTTPException)\n        opt handle\n            dep -->> dep: Can catch exception, raise a new HTTPException, raise other exception\n        end\n        handler -->> client: HTTP error response\n    end\n\n    operation ->> client: Return response to client\n    Note over client,operation: Response is already sent, can't change it anymore\n    opt Tasks\n        operation -->> tasks: Send background tasks\n    end\n    opt Raise other exception\n        tasks -->> tasks: Handle exceptions in the background task code\n    end\n```\n\n/// info | Дополнительная информация\n\nКлиенту будет отправлен только **один ответ**. Это может быть один из ответов об ошибке или ответ от *операции пути*.\n\nПосле отправки одного из этих ответов никакой другой ответ отправить нельзя.\n\n///\n\n/// tip | Подсказка", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md", "section_header": "Выполнение зависимостей с `yield`", "section_header_level": 2}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 8, "header": "Выполнение зависимостей с `yield`", "header_level": 2, "token_count": 429}
{"id": "d30117d6a073ddfb", "text": "**. Это может быть один из ответов об ошибке или ответ от *операции пути*.\n\nПосле отправки одного из этих ответов никакой другой ответ отправить нельзя.\n\n///\n\n/// tip | Подсказка\n\nЕсли вы вызовете какое-либо исключение в коде из *функции-обработчика пути*, оно будет передано зависимостям с `yield`, включая `HTTPException`. В большинстве случаев вы захотите повторно вызвать то же самое исключение или новое из зависимости с `yield`, чтобы убедиться, что оно корректно обработано.\n\n///", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md", "section_header": "Выполнение зависимостей с `yield`", "section_header_level": 2}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 9, "header": "Выполнение зависимостей с `yield`", "header_level": 2, "token_count": 182}
{"id": "258dbb3b6945f67f", "text": "## Ранний выход и `scope` { #early-exit-and-scope }\n\nОбычно «код выхода» зависимостей с `yield` выполняется **после того, как ответ** отправлен клиенту.\n\nНо если вы знаете, что не будете использовать зависимость после возврата из *функции-обработчика пути*, вы можете использовать `Depends(scope=\"function\")`, чтобы сообщить FastAPI, что он должен закрыть зависимость после возврата из *функции-обработчика пути*, но **до того**, как **ответ будет отправлен**.\n\n{* ../../docs_src/dependencies/tutorial008e_an_py39.py hl[12,16] *}\n\n`Depends()` принимает параметр `scope`, который может быть:\n\n* `\"function\"`: начать зависимость до *функции-обработчика пути*, которая обрабатывает запрос, завершить зависимость после окончания *функции-обработчика пути*, но **до того**, как ответ будет отправлен обратно клиенту. То есть функция зависимости будет выполнена **вокруг** *функции-обработчика пути*.\n* `\"request\"`: начать зависимость до *функции-обработчика пути*, которая обрабатывает запрос (как и при использовании `\"function\"`), но завершить **после** того, как ответ будет отправлен обратно клиенту. То есть функция зависимости будет выполнена **вокруг** цикла запроса (**request**) и ответа.\n\nЕсли не указано и в зависимости есть `yield`, по умолчанию будет `scope` со значением `\"request\"`.\n\n", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md"}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 10, "header": "Ранний выход и `scope`", "header_level": 2, "token_count": 453}
{"id": "890e1cf52028627c", "text": "### `scope` для подзависимостей { #scope-for-sub-dependencies }\n\nКогда вы объявляете зависимость с `scope=\"request\"` (значение по умолчанию), любая подзависимость также должна иметь `scope` равный `\"request\"`.\n\nНо зависимость со `scope` равным `\"function\"` может иметь зависимости со `scope` `\"function\"` и со `scope` `\"request\"`.\n\nЭто потому, что любая зависимость должна иметь возможность выполнить свой код выхода раньше подзависимостей, так как ей может понадобиться использовать их во время своего кода выхода.\n\n```mermaid\nsequenceDiagram\n\nparticipant client as Client\nparticipant dep_req as Зависимость scope=\"request\"\nparticipant dep_func as Зависимость scope=\"function\"\nparticipant operation as Функция-обработчик пути\n\n    client ->> dep_req: Запрос\n    Note over dep_req: Выполнить код до yield\n    dep_req ->> dep_func: Передать значение\n    Note over dep_func: Выполнить код до yield\n    dep_func ->> operation: Выполнить функцию-обработчик пути\n    operation ->> dep_func: Выход из функции-обработчика пути\n    Note over dep_func: Выполнить код после yield\n    Note over dep_func: ✅ Зависимость закрыта\n    dep_func ->> client: Отправить ответ клиенту\n    Note over client: Ответ отправлен\n    Note over dep_req: Выполнить код после yield\n    Note over dep_req: ✅ Зависимость закрыта\n```\n\n", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md"}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 11, "header": "`scope` для подзависимостей", "header_level": 3, "token_count": 428}
{"id": "5d3bbf2defcda3d1", "text": "## Зависимости с `yield`, `HTTPException`, `except` и фоновыми задачами { #dependencies-with-yield-httpexception-except-and-background-tasks }\n\nЗависимости с `yield` со временем эволюционировали, чтобы покрыть разные сценарии и исправить некоторые проблемы.\n\nЕсли вы хотите посмотреть, что менялось в разных версиях FastAPI, вы можете прочитать об этом подробнее в продвинутом руководстве: [Продвинутые зависимости — зависимости с `yield`, `HTTPException`, `except` и фоновыми задачами](../../advanced/advanced-dependencies.md#dependencies-with-yield-httpexception-except-and-background-tasks){.internal-link target=_blank}.\n", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md"}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 12, "header": "Зависимости с `yield`, `HTTPException`, `except` и фоновыми задачами", "header_level": 2, "token_count": 208}
{"id": "aa10a0b1d972e839", "text": "## Контекстные менеджеры { #context-managers }\n\n", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md"}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 13, "header": "Контекстные менеджеры", "header_level": 2, "token_count": 17}
{"id": "8e2e039443a97549", "text": "### Что такое «контекстные менеджеры» { #what-are-context-managers }\n\n«Контекстные менеджеры» — это любые объекты Python, которые можно использовать в операторе `with`.\n\nНапример, <a href=\"https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files\" class=\"external-link\" target=\"_blank\">можно использовать `with` для чтения файла</a>:\n\n```Python\nwith open(\"./somefile.txt\") as f:\n    contents = f.read()\n    print(contents)\n```\n\nПод капотом вызов `open(\"./somefile.txt\")` создаёт объект, называемый «контекстным менеджером».\n\nКогда блок `with` завершается, он обязательно закрывает файл, даже если были исключения.\n\nКогда вы создаёте зависимость с `yield`, **FastAPI** внутренне создаёт для неё менеджер контекста и сочетает его с некоторыми другими связанными инструментами.\n\n", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md"}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 14, "header": "Что такое «контекстные менеджеры»", "header_level": 3, "token_count": 275}
{"id": "ce1b7ed8ae998dae", "text": "### Использование менеджеров контекста в зависимостях с `yield` { #using-context-managers-in-dependencies-with-yield }\n\n/// warning | Внимание\n\nЭто, более или менее, «продвинутая» идея.\n\nЕсли вы только начинаете работать с **FastAPI**, то лучше пока пропустить этот пункт.\n\n///\n\nВ Python можно создавать менеджеры контекста, <a href=\"https://docs.python.org/3/reference/datamodel.html#context-managers\" class=\"external-link\" target=\"_blank\">создав класс с двумя методами: `__enter__()` и `__exit__()`</a>.\n\nИх также можно использовать внутри зависимостей **FastAPI** с `yield`, применяя операторы\n`with` или `async with` внутри функции зависимости:\n\n{* ../../docs_src/dependencies/tutorial010_py39.py hl[1:9,13] *}\n\n/// tip | Подсказка\n\nДругой способ создания менеджера контекста — с помощью:\n\n* <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager\" class=\"external-link\" target=\"_blank\">`@contextlib.contextmanager`</a> или\n* <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager\" class=\"external-link\" target=\"_blank\">`@contextlib.asynccontextmanager`</a>\n\nоформив ими функцию с одним `yield`.\n\nИменно это **FastAPI** использует внутренне для зависимостей с `yield`.\n\nНо использовать эти декораторы для зависимостей FastAPI не обязательно (и не стоит).\n\nFastAPI сделает это за вас на внутреннем уровне.\n\n///\n", "metadata": {"title": "Зависимости с yield", "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "source_mtime": "2026-01-12T17:48:13.572419+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\dependencies-with-yield.md"}, "doc_id": "580bd44ac830", "source_path": "docs\\tutorial\\dependencies\\dependencies-with-yield.md", "title": "Зависимости с yield", "chunk_index": 15, "header": "Использование менеджеров контекста в зависимостях с `yield`", "header_level": 3, "token_count": 453}
{"id": "a795d22cf3d0f18e", "text": "# Глобальные зависимости { #global-dependencies }\n\nДля некоторых типов приложений может потребоваться добавить зависимости ко всему приложению.\n\nПодобно тому, как вы можете [добавлять `dependencies` (зависимости) в *декораторах операций пути*](dependencies-in-path-operation-decorators.md){.internal-link target=_blank}, вы можете добавлять зависимости сразу ко всему `FastAPI` приложению.\n\nВ этом случае они будут применяться ко всем *операциям пути* в приложении:\n\n{* ../../docs_src/dependencies/tutorial012_an_py39.py hl[17] *}\n\nВсе способы [добавления `dependencies` (зависимостей) в *декораторах операций пути*](dependencies-in-path-operation-decorators.md){.internal-link target=_blank} по-прежнему применимы, но в данном случае зависимости применяются ко всем *операциям пути* приложения.\n\n", "metadata": {"title": "Глобальные зависимости", "doc_id": "c039e112d220", "source_path": "docs\\tutorial\\dependencies\\global-dependencies.md", "source_mtime": "2026-01-12T17:48:13.578688+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\global-dependencies.md"}, "doc_id": "c039e112d220", "source_path": "docs\\tutorial\\dependencies\\global-dependencies.md", "title": "Глобальные зависимости", "chunk_index": 0, "header": "Глобальные зависимости", "header_level": 1, "token_count": 282}
{"id": "1b696792b0989ce3", "text": "## Зависимости для групп *операций пути* { #dependencies-for-groups-of-path-operations }\n\nПозднее, читая о том, как структурировать более крупные [приложения, содержащие много файлов](../../tutorial/bigger-applications.md){.internal-link target=_blank}, вы узнаете, как объявить один параметр `dependencies` для целой группы *операций пути*.\n", "metadata": {"title": "Глобальные зависимости", "doc_id": "c039e112d220", "source_path": "docs\\tutorial\\dependencies\\global-dependencies.md", "source_mtime": "2026-01-12T17:48:13.578688+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\global-dependencies.md"}, "doc_id": "c039e112d220", "source_path": "docs\\tutorial\\dependencies\\global-dependencies.md", "title": "Глобальные зависимости", "chunk_index": 1, "header": "Зависимости для групп *операций пути*", "header_level": 2, "token_count": 120}
{"id": "a8adab76f0c06eae", "text": "# Зависимости { #dependencies }\n\n**FastAPI** имеет очень мощную, но интуитивную систему **<abbr title=\"также известно как: компоненты, ресурсы, провайдеры, сервисы, внедряемые зависимости\">Инъекция зависимостей</abbr>**.\n\nОна спроектирована так, чтобы быть очень простой в использовании и облегчать любому разработчику интеграцию других компонентов с **FastAPI**.\n\n", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md"}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 0, "header": "Зависимости", "header_level": 1, "token_count": 146}
{"id": "f091927d4a1f9f03", "text": "## Что такое инъекция зависимостей («Dependency Injection») { #what-is-dependency-injection }\n\nВ программировании **«Dependency Injection»** означает, что у вашего кода (в данном случае у ваших *функций обработки пути*) есть способ объявить вещи, которые требуются для его работы и использования: «зависимости».\n\nИ затем эта система (в нашем случае **FastAPI**) позаботится о том, чтобы сделать всё необходимое для предоставления вашему коду этих зависимостей (сделать «инъекцию» зависимостей).\n\nЭто очень полезно, когда вам нужно:\n\n* Обеспечить общую логику (один и тот же алгоритм снова и снова).\n* Разделять соединения с базой данных.\n* Обеспечить безопасность, аутентификацию, требования к ролям и т. п.\n* И многое другое...\n\nВсё это при минимизации повторения кода.\n\n", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md"}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 1, "header": "Что такое инъекция зависимостей («Dependency Injection»)", "header_level": 2, "token_count": 303}
{"id": "a80845a6bbf4980a", "text": "## Первые шаги { #first-steps }\n\nДавайте рассмотрим очень простой пример. Он настолько простой, что пока не очень полезен.\n\nНо так мы сможем сосредоточиться на том, как работает система **Dependency Injection**.\n\n", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md"}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 2, "header": "Первые шаги", "header_level": 2, "token_count": 77}
{"id": "b534c3ab389d0bd8", "text": "### Создайте зависимость, или «dependable» (от чего что-то зависит) { #create-a-dependency-or-dependable }\n\nСначала сосредоточимся на зависимости.\n\nЭто просто функция, которая может принимать те же параметры, что и *функция обработки пути*:\n\n{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[8:9] *}\n\nИ всё.\n\n**2 строки.**\n\nИ она имеет ту же форму и структуру, что и все ваши *функции обработки пути*.\n\nМожно думать о ней как о *функции обработки пути* без «декоратора» (без `@app.get(\"/some-path\")`).\n\nИ она может возвращать что угодно.\n\nВ этом случае эта зависимость ожидает:\n\n* Необязательный query-параметр `q` типа `str`.\n* Необязательный query-параметр `skip` типа `int`, по умолчанию `0`.\n* Необязательный query-параметр `limit` типа `int`, по умолчанию `100`.\n\nА затем просто возвращает `dict`, содержащий эти значения.\n\n/// info | Информация\n\nFastAPI добавил поддержку `Annotated` (и начал рекомендовать его использование) в версии 0.95.0.\n\nЕсли у вас более старая версия, вы получите ошибки при попытке использовать `Annotated`.\n\nУбедитесь, что вы [обновили версию FastAPI](../../deployment/versions.md#upgrading-the-fastapi-versions){.internal-link target=_blank} как минимум до 0.95.1, прежде чем использовать `Annotated`.\n\n///\n\n", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md"}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 3, "header": "Создайте зависимость, или «dependable» (от чего что-то зависит)", "header_level": 3, "token_count": 465}
{"id": "d4a1e64df7104421", "text": "### Импорт `Depends` { #import-depends }\n\n{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[3] *}\n\n", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md"}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 4, "header": "Импорт `Depends`", "header_level": 3, "token_count": 34}
{"id": "a8adab76f0c06eae", "text": "### Объявите зависимость в «зависимом» { #declare-the-dependency-in-the-dependant }\n\nТочно так же, как вы используете `Body`, `Query` и т. д. с параметрами вашей *функции обработки пути*, используйте `Depends` с новым параметром:\n\n{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[13,18] *}\n\nХотя вы используете `Depends` в параметрах вашей функции так же, как `Body`, `Query` и т. д., `Depends` работает немного иначе.\n\nВ `Depends` вы передаёте только один параметр.\n\nЭтот параметр должен быть чем-то вроде функции.\n\nВы **не вызываете её** напрямую (не добавляйте круглые скобки в конце), просто передаёте её как параметр в `Depends()`.\n\nИ эта функция принимает параметры так же, как *функции обработки пути*.\n\n/// tip | Подсказка\n\nВ следующей главе вы увидите, какие ещё «вещи», помимо функций, можно использовать в качестве зависимостей.\n\n///\n\nКаждый раз, когда приходит новый запрос, **FastAPI** позаботится о:\n\n* Вызове вашей зависимости («dependable») с корректными параметрами.\n* Получении результата из вашей функции.\n* Присваивании этого результата параметру в вашей *функции обработки пути*.\n\n```mermaid\ngraph TB\n\ncommon_parameters([\"common_parameters\"])\nread_items[\"/items/\"]\nread_users[\"/users/\"]\n\ncommon_parameters --> read_items\ncommon_parameters --> read_users\n```\n\nТаким образом, вы пишете общий код один раз, а **FastAPI** позаботится о его вызове для ваших *операций пути*.\n\n/// check | Проверка", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md", "section_header": "Объявите зависимость в «зависимом»", "section_header_level": 3}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 5, "header": "Объявите зависимость в «зависимом»", "header_level": 3, "token_count": 511}
{"id": "f091927d4a1f9f03", "text": "--> read_users\n```\n\nТаким образом, вы пишете общий код один раз, а **FastAPI** позаботится о его вызове для ваших *операций пути*.\n\n/// check | Проверка\n\nОбратите внимание, что вам не нужно создавать специальный класс и передавать его куда-то в **FastAPI**, чтобы «зарегистрировать» его или что-то подобное.\n\nВы просто передаёте его в `Depends`, и **FastAPI** знает, что делать дальше.\n\n///", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md", "section_header": "Объявите зависимость в «зависимом»", "section_header_level": 3}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 6, "header": "Объявите зависимость в «зависимом»", "header_level": 3, "token_count": 151}
{"id": "7066564f61c24186", "text": "## Использование зависимости с `Annotated` в нескольких местах { #share-annotated-dependencies }\n\nВ приведённых выше примерах есть небольшое **повторение кода**.\n\nКогда вам нужно использовать зависимость `common_parameters()`, вы должны написать весь параметр с аннотацией типа и `Depends()`:\n\n```Python\ncommons: Annotated[dict, Depends(common_parameters)]\n```\n\nНо поскольку мы используем `Annotated`, мы можем сохранить это значение `Annotated` в переменную и использовать его в нескольких местах:\n\n{* ../../docs_src/dependencies/tutorial001_02_an_py310.py hl[12,16,21] *}\n\n/// tip | Подсказка\n\nЭто стандартный Python, это называется «type alias», и это не особенность **FastAPI**.\n\nНо поскольку **FastAPI** основан на стандартах Python, включая `Annotated`, вы можете использовать этот трюк в своём коде. \n\n///\n\nЗависимости продолжат работать как ожидалось, и **лучшая часть** в том, что **информация о типах будет сохранена**, а значит, ваш редактор кода продолжит предоставлять **автозавершение**, **встроенные ошибки** и т.д. То же относится и к другим инструментам, таким как `mypy`.\n\nЭто особенно полезно, когда вы используете это в **большой кодовой базе**, где вы используете **одни и те же зависимости** снова и снова во **многих *операциях пути***.\n\n", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md"}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 7, "header": "Использование зависимости с `Annotated` в нескольких местах", "header_level": 2, "token_count": 455}
{"id": "f5e7675d30cef61f", "text": "## Использовать `async` или не `async` { #to-async-or-not-to-async }\n\nПоскольку зависимости также вызываются **FastAPI** (как и ваши *функции обработки пути*), применяются те же правила при определении ваших функций.\n\nВы можете использовать `async def` или обычное `def`.\n\nИ вы можете объявлять зависимости с `async def` внутри обычных *функций обработки пути* `def`, или зависимости `def` внутри *функций обработки пути* `async def` и т. д.\n\nЭто не важно. **FastAPI** знает, что делать.\n\n/// note | Примечание\n\nЕсли вы не уверены, посмотрите раздел [Async: *\"In a hurry?\"*](../../async.md#in-a-hurry){.internal-link target=_blank} о `async` и `await` в документации.\n\n///\n\n", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md"}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 8, "header": "Использовать `async` или не `async`", "header_level": 2, "token_count": 257}
{"id": "b81491f4789a1326", "text": "## Интеграция с OpenAPI { #integrated-with-openapi }\n\nВсе объявления запросов, проверки и требования ваших зависимостей (и подзависимостей) будут интегрированы в ту же схему OpenAPI.\n\nПоэтому в интерактивной документации будет вся информация и из этих зависимостей:\n\n<img src=\"/img/tutorial/dependencies/image01.png\">\n\n", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md"}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 9, "header": "Интеграция с OpenAPI", "header_level": 2, "token_count": 115}
{"id": "1a3f02ed1ad3b211", "text": "## Простое использование { #simple-usage }\n\nЕсли посмотреть, *функции обработки пути* объявляются для использования всякий раз, когда *путь* и *операция* совпадают, и тогда **FastAPI** заботится о вызове функции с корректными параметрами, извлекая данные из запроса.\n\nНа самом деле все (или большинство) веб-фреймворков работают таким же образом.\n\nВы никогда не вызываете эти функции напрямую. Их вызывает ваш фреймворк (в нашем случае **FastAPI**).\n\nС системой **Dependency Injection** вы также можете сообщить **FastAPI**, что ваша *функция обработки пути* «зависит» от чего-то, что должно быть выполнено перед вашей *функцией обработки пути*, и **FastAPI** позаботится о его выполнении и «инъекции» результатов.\n\nДругие распространённые термины для описания той же идеи «dependency injection»:\n\n* ресурсы\n* провайдеры\n* сервисы\n* внедряемые зависимости\n* компоненты\n\n", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md"}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 10, "header": "Простое использование", "header_level": 2, "token_count": 341}
{"id": "b6bacaae4f8c1727", "text": "## Плагины **FastAPI** { #fastapi-plug-ins }\n\nИнтеграции и «плагины» могут быть построены с использованием системы **Dependency Injection**. Но на самом деле **нет необходимости создавать «плагины»**, так как, используя зависимости, можно объявить бесконечное количество интеграций и взаимодействий, которые становятся доступными вашим *функциям обработки пути*.\n\nИ зависимости можно создавать очень простым и интуитивным способом, который позволяет просто импортировать нужные пакеты Python и интегрировать их с вашими API-функциями в пару строк кода, *буквально*.\n\nВы увидите примеры этого в следующих главах о реляционных и NoSQL базах данных, безопасности и т.д.\n\n", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md"}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 11, "header": "Плагины **FastAPI**", "header_level": 2, "token_count": 260}
{"id": "410f3c0b627c5584", "text": "## Совместимость с **FastAPI** { #fastapi-compatibility }\n\nПростота системы **Dependency Injection** делает **FastAPI** совместимым с:\n\n* всеми реляционными базами данных\n* NoSQL базами данных\n* внешними пакетами\n* внешними API\n* системами аутентификации и авторизации\n* системами мониторинга использования API\n* системами инъекции данных в ответы\n* и т.д.\n\n", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md"}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 12, "header": "Совместимость с **FastAPI**", "header_level": 2, "token_count": 133}
{"id": "433135c7ce00071f", "text": "## Просто и мощно { #simple-and-powerful }\n\nХотя иерархическая система dependency injection очень проста для определения и использования, она по-прежнему очень мощная.\n\nВы можете определять зависимости, которые, в свою очередь, могут иметь собственные зависимости.\n\nВ итоге строится иерархическое дерево зависимостей, и система **Dependency Injection** берёт на себя решение всех этих зависимостей (и их подзависимостей) и предоставляет (инъектирует) результаты на каждом шаге.\n\nНапример, у вас есть 4 API-эндпоинта (*операции пути*):\n\n* `/items/public/`\n* `/items/private/`\n* `/users/{user_id}/activate`\n* `/items/pro/`\n\nтогда вы можете добавить разные требования к правам для каждого из них только с помощью зависимостей и подзависимостей:\n\n```mermaid\ngraph TB\n\ncurrent_user([\"current_user\"])\nactive_user([\"active_user\"])\nadmin_user([\"admin_user\"])\npaying_user([\"paying_user\"])\n\npublic[\"/items/public/\"]\nprivate[\"/items/private/\"]\nactivate_user[\"/users/{user_id}/activate\"]\npro_items[\"/items/pro/\"]\n\ncurrent_user --> active_user\nactive_user --> admin_user\nactive_user --> paying_user\n\ncurrent_user --> public\nactive_user --> private\nadmin_user --> activate_user\npaying_user --> pro_items\n```\n\n", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md"}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 13, "header": "Просто и мощно", "header_level": 2, "token_count": 393}
{"id": "843bb8def92d00fa", "text": "## Интегрировано с **OpenAPI** { #integrated-with-openapi_1 }\n\nВсе эти зависимости, объявляя свои требования, также добавляют параметры, проверки и т.д. к вашим *операциям пути*.\n\n**FastAPI** позаботится о добавлении всего этого в схему OpenAPI, чтобы это отображалось в системах интерактивной документации.\n", "metadata": {"title": "Зависимости", "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "source_mtime": "2026-01-12T17:48:13.586737+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\index.md"}, "doc_id": "8c047a37ede7", "source_path": "docs\\tutorial\\dependencies\\index.md", "title": "Зависимости", "chunk_index": 14, "header": "Интегрировано с **OpenAPI**", "header_level": 2, "token_count": 118}
{"id": "d4b79e49b237fcb5", "text": "# Подзависимости { #sub-dependencies }\n\nВы можете создавать зависимости, которые имеют **подзависимости**.\n\nИх **вложенность** может быть любой глубины.\n\n**FastAPI** сам займётся их управлением.\n\n", "metadata": {"title": "Подзависимости", "doc_id": "fa5d4b624e34", "source_path": "docs\\tutorial\\dependencies\\sub-dependencies.md", "source_mtime": "2026-01-12T17:48:13.594783+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\sub-dependencies.md"}, "doc_id": "fa5d4b624e34", "source_path": "docs\\tutorial\\dependencies\\sub-dependencies.md", "title": "Подзависимости", "chunk_index": 0, "header": "Подзависимости", "header_level": 1, "token_count": 78}
{"id": "8e29c0e601a555e1", "text": "## Первая зависимость { #first-dependency-dependable }\n\nМожно создать первую зависимость следующим образом:\n\n{* ../../docs_src/dependencies/tutorial005_an_py310.py hl[8:9] *}\n\nОна объявляет необязательный параметр запроса `q` как строку, а затем возвращает его.\n\nЭто довольно просто (хотя и не очень полезно), но поможет нам сосредоточиться на том, как работают подзависимости.\n\n", "metadata": {"title": "Подзависимости", "doc_id": "fa5d4b624e34", "source_path": "docs\\tutorial\\dependencies\\sub-dependencies.md", "source_mtime": "2026-01-12T17:48:13.594783+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\sub-dependencies.md"}, "doc_id": "fa5d4b624e34", "source_path": "docs\\tutorial\\dependencies\\sub-dependencies.md", "title": "Подзависимости", "chunk_index": 1, "header": "Первая зависимость", "header_level": 2, "token_count": 135}
{"id": "b5b5f84479a5517b", "text": "## Вторая зависимость, «зависимость» и «зависимая» { #second-dependency-dependable-and-dependant }\n\nЗатем можно создать еще одну функцию зависимости, которая одновременно объявляет свою собственную зависимость (таким образом, она тоже является «зависимой»):\n\n{* ../../docs_src/dependencies/tutorial005_an_py310.py hl[13] *}\n\nОстановимся на объявленных параметрах:\n\n* Несмотря на то, что эта функция сама является зависимостью, она также является зависимой от чего-то другого.\n    * Она зависит от `query_extractor` и присваивает возвращаемое ей значение параметру `q`.\n* Она также объявляет необязательный куки-параметр `last_query` в виде строки.\n    * Если пользователь не указал параметр `q` в запросе, то мы используем последний использованный запрос, который мы ранее сохранили в куки-параметре `last_query`.\n\n", "metadata": {"title": "Подзависимости", "doc_id": "fa5d4b624e34", "source_path": "docs\\tutorial\\dependencies\\sub-dependencies.md", "source_mtime": "2026-01-12T17:48:13.594783+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\sub-dependencies.md"}, "doc_id": "fa5d4b624e34", "source_path": "docs\\tutorial\\dependencies\\sub-dependencies.md", "title": "Подзависимости", "chunk_index": 2, "header": "Вторая зависимость, «зависимость» и «зависимая»", "header_level": 2, "token_count": 293}
{"id": "0d16b16de1a6b95a", "text": "## Использование зависимости { #use-the-dependency }\n\nЗатем мы можем использовать зависимость вместе с:\n\n{* ../../docs_src/dependencies/tutorial005_an_py310.py hl[23] *}\n\n/// info | Дополнительная информация\n\nОбратите внимание, что мы объявляем только одну зависимость в *функции операции пути* - `query_or_cookie_extractor`.\n\nНо **FastAPI** будет знать, что сначала он должен выполнить `query_extractor`, чтобы передать результаты этого в `query_or_cookie_extractor` при его вызове.\n\n///\n\n```mermaid\ngraph TB\n\nquery_extractor([\"query_extractor\"])\nquery_or_cookie_extractor([\"query_or_cookie_extractor\"])\n\nread_query[\"/items/\"]\n\nquery_extractor --> query_or_cookie_extractor --> read_query\n```\n\n", "metadata": {"title": "Подзависимости", "doc_id": "fa5d4b624e34", "source_path": "docs\\tutorial\\dependencies\\sub-dependencies.md", "source_mtime": "2026-01-12T17:48:13.594783+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\sub-dependencies.md"}, "doc_id": "fa5d4b624e34", "source_path": "docs\\tutorial\\dependencies\\sub-dependencies.md", "title": "Подзависимости", "chunk_index": 3, "header": "Использование зависимости", "header_level": 2, "token_count": 190}
{"id": "3f2299b4b08ea1dd", "text": "## Использование одной и той же зависимости несколько раз { #using-the-same-dependency-multiple-times }\n\nЕсли одна из ваших зависимостей объявлена несколько раз для одной и той же *функции операции пути*, например, несколько зависимостей имеют общую подзависимость, **FastAPI** будет знать, что вызывать эту подзависимость нужно только один раз за запрос.\n\nПри этом возвращаемое значение будет сохранено в <abbr title=\"Система для хранения значений, сгенерированных компьютером, для их повторного использования вместо повторного вычисления.\">\"кэш\"</abbr> и будет передано всем \"зависимым\" функциям, которые нуждаются в нем внутри этого конкретного запроса, вместо того, чтобы вызывать зависимость несколько раз для одного и того же запроса.\n\nВ расширенном сценарии, когда вы знаете, что вам нужно, чтобы зависимость вызывалась на каждом шаге (возможно, несколько раз) в одном и том же запросе, вместо использования \"кэшированного\" значения, вы можете установить параметр `use_cache=False` при использовании `Depends`:\n\n//// tab | Python 3.9+\n\n```Python hl_lines=\"1\"\nasync def needy_dependency(fresh_value: Annotated[str, Depends(get_value, use_cache=False)]):\n    return {\"fresh_value\": fresh_value}\n```\n\n////\n\n//// tab | Python 3.9+ без Annotated\n\n/// tip | Подсказка\n\nПредпочтительнее использовать версию с аннотацией, если это возможно.\n\n///\n\n```Python hl_lines=\"1\"\nasync def needy_dependency(fresh_value: str = Depends(get_value, use_cache=False)):\n    return {\"fresh_value\": fresh_value}\n```\n\n////\n\n", "metadata": {"title": "Подзависимости", "doc_id": "fa5d4b624e34", "source_path": "docs\\tutorial\\dependencies\\sub-dependencies.md", "source_mtime": "2026-01-12T17:48:13.594783+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\sub-dependencies.md"}, "doc_id": "fa5d4b624e34", "source_path": "docs\\tutorial\\dependencies\\sub-dependencies.md", "title": "Подзависимости", "chunk_index": 4, "header": "Использование одной и той же зависимости несколько раз", "header_level": 2, "token_count": 509}
{"id": "2a80f2ac14d138cf", "text": "## Резюме { #recap }\n\nПомимо всех этих умных слов, используемых здесь, система внедрения зависимостей довольно проста.\n\nЭто просто функции, которые выглядят так же, как *функции операций путей*.\n\nНо, тем не менее, эта система очень мощная и позволяет вам объявлять вложенные графы (деревья) зависимостей сколь угодно глубоко.\n\n/// tip | Подсказка\n\nВсе это может показаться не столь полезным на этих простых примерах.\n\nНо вы увидите как это пригодится в главах посвященных безопасности.\n\nИ вы также увидите, сколько кода это вам сэкономит.\n\n///\n", "metadata": {"title": "Подзависимости", "doc_id": "fa5d4b624e34", "source_path": "docs\\tutorial\\dependencies\\sub-dependencies.md", "source_mtime": "2026-01-12T17:48:13.594783+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\dependencies\\sub-dependencies.md"}, "doc_id": "fa5d4b624e34", "source_path": "docs\\tutorial\\dependencies\\sub-dependencies.md", "title": "Подзависимости", "chunk_index": 5, "header": "Резюме", "header_level": 2, "token_count": 236}
{"id": "3aff31f723c3d241", "text": "# Безопасность — первые шаги { #security-first-steps }\n\nПредставим, что у вас есть **бэкенд** API на некотором домене.\n\nИ у вас есть **фронтенд** на другом домене или на другом пути того же домена (или в мобильном приложении).\n\nИ вы хотите, чтобы фронтенд мог аутентифицироваться на бэкенде, используя **имя пользователя** и **пароль**.\n\nМы можем использовать **OAuth2**, чтобы построить это с **FastAPI**.\n\nНо давайте сэкономим вам время на чтение всей длинной спецификации в поисках тех небольших фрагментов информации, которые вам нужны.\n\nВоспользуемся инструментами, предоставленными **FastAPI**, чтобы работать с безопасностью.\n\n", "metadata": {"title": "Безопасность — первые шаги", "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.610809+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\first-steps.md"}, "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "title": "Безопасность — первые шаги", "chunk_index": 0, "header": "Безопасность — первые шаги", "header_level": 1, "token_count": 248}
{"id": "247077d9bd328e5d", "text": "## Как это выглядит { #how-it-looks }\n\nСначала просто воспользуемся кодом и посмотрим, как он работает, а затем вернемся и разберемся, что происходит.\n\n", "metadata": {"title": "Безопасность — первые шаги", "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.610809+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\first-steps.md"}, "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "title": "Безопасность — первые шаги", "chunk_index": 1, "header": "Как это выглядит", "header_level": 2, "token_count": 63}
{"id": "612ae48c0dcfaf2d", "text": "## Создание `main.py` { #create-main-py }\n\nСкопируйте пример в файл `main.py`:\n\n{* ../../docs_src/security/tutorial001_an_py39.py *}\n\n", "metadata": {"title": "Безопасность — первые шаги", "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.610809+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\first-steps.md"}, "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "title": "Безопасность — первые шаги", "chunk_index": 2, "header": "Создание `main.py`", "header_level": 2, "token_count": 42}
{"id": "8122e014bdeb53d3", "text": "## Запуск { #run-it }\n\n/// info | Дополнительная информация\n\nПакет <a href=\"https://github.com/Kludex/python-multipart\" class=\"external-link\" target=\"_blank\">`python-multipart`</a> автоматически устанавливается вместе с **FastAPI**, если вы запускаете команду `pip install \"fastapi[standard]\"`.\n\nОднако, если вы используете команду `pip install fastapi`, пакет `python-multipart` по умолчанию не включается.\n\nЧтобы установить его вручную, убедитесь, что вы создали [виртуальное окружение](../../virtual-environments.md){.internal-link target=_blank}, активировали его и затем установили пакет:\n\n```console\n$ pip install python-multipart\n```\n\nЭто связано с тем, что **OAuth2** использует «данные формы» для отправки `username` и `password`.\n\n///\n\nЗапустите пример командой:\n\n<div class=\"termy\">\n\n```console\n$ fastapi dev main.py\n\n<span style=\"color: green;\">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n</div>\n\n", "metadata": {"title": "Безопасность — первые шаги", "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.610809+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\first-steps.md"}, "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "title": "Безопасность — первые шаги", "chunk_index": 3, "header": "Запуск", "header_level": 2, "token_count": 313}
{"id": "eb5ce070fdffd99f", "text": "## Проверка { #check-it }\n\nПерейдите к интерактивной документации по адресу: <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a>.\n\nВы увидите примерно следующее:\n\n<img src=\"/img/tutorial/security/image01.png\">\n\n/// check | Кнопка авторизации!\n\nУ вас уже появилась новая кнопка «Authorize».\n\nА у вашей *операции пути* в правом верхнем углу есть маленький замочек, на который можно нажать.\n\n///\n\nЕсли нажать на нее, появится небольшая форма авторизации, в которую нужно ввести `username` и `password` (и другие необязательные поля):\n\n<img src=\"/img/tutorial/security/image02.png\">\n\n/// note | Примечание\n\nНеважно, что вы введете в форму — пока это не будет работать. Но мы скоро до этого дойдем.\n\n///\n\nКонечно, это не фронтенд для конечных пользователей, но это отличный автоматический инструмент для интерактивного документирования всего вашего API.\n\nИм может пользоваться команда фронтенда (которой можете быть и вы сами).\n\nИм могут пользоваться сторонние приложения и системы.\n\nИ им также можете пользоваться вы сами, чтобы отлаживать, проверять и тестировать то же самое приложение.\n\n", "metadata": {"title": "Безопасность — первые шаги", "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.610809+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\first-steps.md"}, "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "title": "Безопасность — первые шаги", "chunk_index": 4, "header": "Проверка", "header_level": 2, "token_count": 401}
{"id": "3aff31f723c3d241", "text": "## «`password` flow» (аутентификация по паролю) { #the-password-flow }\n\nТеперь давайте немного вернемся и разберемся, что это все такое.\n\n«`password` flow» — это один из способов («flows»), определенных в OAuth2, для обеспечения безопасности и аутентификации.\n\nOAuth2 был спроектирован так, чтобы бэкенд или API были независимы от сервера, который аутентифицирует пользователя.\n\nНо в нашем случае одно и то же приложение **FastAPI** будет работать и с API, и с аутентификацией.\n\nИтак, рассмотрим это с упрощенной точки зрения:", "metadata": {"title": "Безопасность — первые шаги", "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.610809+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\first-steps.md", "section_header": "«`password` flow» (аутентификация по паролю)", "section_header_level": 2}, "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "title": "Безопасность — первые шаги", "chunk_index": 5, "header": "«`password` flow» (аутентификация по паролю)", "header_level": 2, "token_count": 203}
{"id": "247077d9bd328e5d", "text": "ет пользователя.\n\nНо в нашем случае одно и то же приложение **FastAPI** будет работать и с API, и с аутентификацией.\n\nИтак, рассмотрим это с упрощенной точки зрения:\n\n* Пользователь вводит на фронтенде `username` и `password` и нажимает `Enter`.\n* Фронтенд (работающий в браузере пользователя) отправляет эти `username` и `password` на конкретный URL в нашем API (объявленный с `tokenUrl=\"token\"`).\n* API проверяет этот `username` и `password` и отвечает «токеном» (мы еще ничего из этого не реализовали).\n    * «Токен» — это просто строка с некоторым содержимым, которое мы сможем позже использовать для проверки этого пользователя.\n    * Обычно у токена установлен срок действия: он истекает через некоторое время.\n        * Поэтому пользователю придется снова войти в систему в какой‑то момент.\n        * И если токен украдут, риск меньше: это не постоянный ключ, который будет работать вечно (в большинстве случаев).\n* Фронтенд временно где‑то хранит этот токен.\n* Пользователь кликает во фронтенде, чтобы перейти в другой раздел веб‑приложения.\n* Фронтенду нужно получить дополнительные данные из API.\n    * Но для этого для конкретной конечной точки нужна аутентификация.\n    * Поэтому, чтобы аутентифицироваться в нашем API, он отправляет HTTP-заголовок `Authorization` со значением `Bearer ` плюс сам токен.\n    * Если токен содержит `foobar`, то содержимое заголовка `Authorization` будет: `Bearer foobar`.", "metadata": {"title": "Безопасность — первые шаги", "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.610809+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\first-steps.md", "section_header": "«`password` flow» (аутентификация по паролю)", "section_header_level": 2}, "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "title": "Безопасность — первые шаги", "chunk_index": 6, "header": "«`password` flow» (аутентификация по паролю)", "header_level": 2, "token_count": 528}
{"id": "612ae48c0dcfaf2d", "text": "роваться в нашем API, он отправляет HTTP-заголовок `Authorization` со значением `Bearer ` плюс сам токен.\n    * Если токен содержит `foobar`, то содержимое заголовка `Authorization` будет: `Bearer foobar`.", "metadata": {"title": "Безопасность — первые шаги", "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.610809+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\first-steps.md", "section_header": "«`password` flow» (аутентификация по паролю)", "section_header_level": 2}, "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "title": "Безопасность — первые шаги", "chunk_index": 7, "header": "«`password` flow» (аутентификация по паролю)", "header_level": 2, "token_count": 64}
{"id": "3aff31f723c3d241", "text": "## Класс `OAuth2PasswordBearer` в **FastAPI** { #fastapis-oauth2passwordbearer }\n\n**FastAPI** предоставляет несколько средств на разных уровнях абстракции для реализации этих функций безопасности.\n\nВ этом примере мы будем использовать **OAuth2**, с потоком **Password**, используя токен **Bearer**. Для этого мы используем класс `OAuth2PasswordBearer`.\n\n/// info | Дополнительная информация\n\nТокен «bearer» — не единственный вариант.\n\nНо для нашего случая он — лучший.\n\nИ он может быть лучшим для большинства случаев использования, если только вы не являетесь экспертом по OAuth2 и точно знаете, почему другой вариант лучше подходит под ваши нужды.\n\nВ этом случае **FastAPI** также предоставляет инструменты, чтобы его реализовать.\n\n///\n\nПри создании экземпляра класса `OAuth2PasswordBearer` мы передаем параметр `tokenUrl`. Этот параметр содержит URL, который клиент (фронтенд, работающий в браузере пользователя) будет использовать для отправки `username` и `password`, чтобы получить токен.\n\n{* ../../docs_src/security/tutorial001_an_py39.py hl[8] *}\n\n/// tip | Подсказка\n\nЗдесь `tokenUrl=\"token\"` ссылается на относительный URL `token`, который мы еще не создали. Поскольку это относительный URL, он эквивалентен `./token`.\n\nПоскольку мы используем относительный URL, если ваш API расположен по адресу `https://example.com/`, то он будет ссылаться на `https://example.com/token`. А если ваш API расположен по адресу `https://example.com/api/v1/`, то он будет ссылаться на `https://example.com/api/v1/token`.", "metadata": {"title": "Безопасность — первые шаги", "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.610809+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\first-steps.md", "section_header": "Класс `OAuth2PasswordBearer` в **FastAPI**", "section_header_level": 2}, "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "title": "Безопасность — первые шаги", "chunk_index": 8, "header": "Класс `OAuth2PasswordBearer` в **FastAPI**", "header_level": 2, "token_count": 504}
{"id": "247077d9bd328e5d", "text": "оложен по адресу `https://example.com/`, то он будет ссылаться на `https://example.com/token`. А если ваш API расположен по адресу `https://example.com/api/v1/`, то он будет ссылаться на `https://example.com/api/v1/token`.\n\nИспользование относительного URL важно для того, чтобы ваше приложение продолжало работать даже в таком продвинутом случае, как [За прокси-сервером](../../advanced/behind-a-proxy.md){.internal-link target=_blank}.\n\n///\n\nЭтот параметр не создает конечную точку / *операцию пути*, а объявляет, что URL `/token` — это тот, который клиент должен использовать для получения токена. Эта информация используется в OpenAPI, а затем в интерактивных системах документации по API.\n\nСкоро мы также создадим и саму операцию пути.\n\n/// info | Дополнительная информация\n\nЕсли вы очень строгий «питонист», вам может не понравиться стиль имени параметра `tokenUrl` вместо `token_url`.\n\nЭто потому, что используется то же имя, что и в спецификации OpenAPI. Так, если вам нужно разобраться подробнее в какой‑то из этих схем безопасности, вы можете просто скопировать и вставить это имя, чтобы найти больше информации.\n\n///\n\nПеременная `oauth2_scheme` — это экземпляр `OAuth2PasswordBearer`, но она также «вызываемая».\n\nЕе можно вызвать так:\n\n```Python\noauth2_scheme(some, parameters)\n```\n\nПоэтому ее можно использовать вместе с `Depends`.", "metadata": {"title": "Безопасность — первые шаги", "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.610809+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\first-steps.md", "section_header": "Класс `OAuth2PasswordBearer` в **FastAPI**", "section_header_level": 2}, "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "title": "Безопасность — первые шаги", "chunk_index": 9, "header": "Класс `OAuth2PasswordBearer` в **FastAPI**", "header_level": 2, "token_count": 459}
{"id": "14570a60fb8bb843", "text": "### Использование { #use-it }\n\nТеперь вы можете передать `oauth2_scheme` как зависимость с `Depends`.\n\n{* ../../docs_src/security/tutorial001_an_py39.py hl[12] *}\n\nЭта зависимость предоставит `str`, который будет присвоен параметру `token` *функции-обработчика пути*.\n\n**FastAPI** будет знать, что может использовать эту зависимость для определения «схемы безопасности» в схеме OpenAPI (и в автоматической документации по API).\n\n/// info | Технические детали\n\n**FastAPI** будет знать, что может использовать класс `OAuth2PasswordBearer` (объявленный в зависимости) для определения схемы безопасности в OpenAPI, потому что он наследуется от `fastapi.security.oauth2.OAuth2`, который, в свою очередь, наследуется от `fastapi.security.base.SecurityBase`.\n\nВсе утилиты безопасности, интегрируемые с OpenAPI (и автоматической документацией по API), наследуются от `SecurityBase`, — так **FastAPI** понимает, как интегрировать их в OpenAPI.\n\n///\n\n", "metadata": {"title": "Безопасность — первые шаги", "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.610809+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\first-steps.md"}, "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "title": "Безопасность — первые шаги", "chunk_index": 10, "header": "Использование", "header_level": 3, "token_count": 326}
{"id": "e339bcf579c1ed31", "text": "## Что он делает { #what-it-does }\n\nОн будет искать в запросе заголовок `Authorization`, проверять, что его значение — это `Bearer ` плюс некоторый токен, и вернет токен как `str`.\n\nЕсли заголовок `Authorization` отсутствует или его значение не содержит токен `Bearer `, он сразу ответит ошибкой со статус-кодом 401 (`UNAUTHORIZED`).\n\nВам даже не нужно проверять наличие токена, чтобы вернуть ошибку. Вы можете быть уверены: если ваша функция была выполнена, в этом токене будет `str`.\n\nЭто уже можно попробовать в интерактивной документации:\n\n<img src=\"/img/tutorial/security/image03.png\">\n\nМы пока не проверяем валидность токена, но для начала это уже неплохо.\n\n", "metadata": {"title": "Безопасность — первые шаги", "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.610809+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\first-steps.md"}, "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "title": "Безопасность — первые шаги", "chunk_index": 11, "header": "Что он делает", "header_level": 2, "token_count": 221}
{"id": "f7289292e91058a4", "text": "## Резюме { #recap }\n\nТаким образом, всего за 3–4 дополнительные строки у вас уже есть некая примитивная форма защиты.\n", "metadata": {"title": "Безопасность — первые шаги", "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "source_mtime": "2026-01-12T17:48:13.610809+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\first-steps.md"}, "doc_id": "8c73c83a5687", "source_path": "docs\\tutorial\\security\\first-steps.md", "title": "Безопасность — первые шаги", "chunk_index": 12, "header": "Резюме", "header_level": 2, "token_count": 51}
{"id": "4ed5b2523e1a77fd", "text": "# Получить текущего пользователя { #get-current-user }\n\nВ предыдущей главе система безопасности (основанная на системе внедрения зависимостей) передавала *функции-обработчику пути* `token` типа `str`:\n\n{* ../../docs_src/security/tutorial001_an_py39.py hl[12] *}\n\nНо это всё ещё не слишком полезно.\n\nСделаем так, чтобы она возвращала текущего пользователя.\n\n", "metadata": {"title": "Получить текущего пользователя", "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "source_mtime": "2026-01-12T17:48:13.619361+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\get-current-user.md"}, "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "title": "Получить текущего пользователя", "chunk_index": 0, "header": "Получить текущего пользователя", "header_level": 1, "token_count": 121}
{"id": "e2bb579eb480aff4", "text": "## Создать модель пользователя { #create-a-user-model }\n\nСначала создадим Pydantic-модель пользователя.\n\nТочно так же, как мы используем Pydantic для объявления тел запросов, мы можем использовать его где угодно:\n\n{* ../../docs_src/security/tutorial002_an_py310.py hl[5,12:6] *}\n\n", "metadata": {"title": "Получить текущего пользователя", "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "source_mtime": "2026-01-12T17:48:13.619361+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\get-current-user.md"}, "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "title": "Получить текущего пользователя", "chunk_index": 1, "header": "Создать модель пользователя", "header_level": 2, "token_count": 86}
{"id": "e821988e7a0755ec", "text": "## Создать зависимость `get_current_user` { #create-a-get-current-user-dependency }\n\nДавайте создадим зависимость `get_current_user`.\n\nПомните, что у зависимостей могут быть подзависимости?\n\n`get_current_user` будет иметь зависимость от того же `oauth2_scheme`, который мы создали ранее.\n\nАналогично тому, как мы делали ранее прямо в *операции пути*, новая зависимость `get_current_user` получит `token` типа `str` от подзависимости `oauth2_scheme`:\n\n{* ../../docs_src/security/tutorial002_an_py310.py hl[25] *}\n\n", "metadata": {"title": "Получить текущего пользователя", "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "source_mtime": "2026-01-12T17:48:13.619361+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\get-current-user.md"}, "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "title": "Получить текущего пользователя", "chunk_index": 2, "header": "Создать зависимость `get_current_user`", "header_level": 2, "token_count": 171}
{"id": "d3e58387d29ad2da", "text": "## Получить пользователя { #get-the-user }\n\n`get_current_user` будет использовать созданную нами (ненастоящую) служебную функцию, которая принимает токен типа `str` и возвращает нашу Pydantic-модель `User`:\n\n{* ../../docs_src/security/tutorial002_an_py310.py hl[19:22,26:27] *}\n\n", "metadata": {"title": "Получить текущего пользователя", "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "source_mtime": "2026-01-12T17:48:13.619361+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\get-current-user.md"}, "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "title": "Получить текущего пользователя", "chunk_index": 3, "header": "Получить пользователя", "header_level": 2, "token_count": 91}
{"id": "90702dba9175e014", "text": "## Внедрить текущего пользователя { #inject-the-current-user }\n\nТеперь мы можем использовать тот же `Depends` с нашей `get_current_user` в *операции пути*:\n\n{* ../../docs_src/security/tutorial002_an_py310.py hl[31] *}\n\nОбратите внимание, что мы объявляем тип `current_user` как Pydantic-модель `User`.\n\nЭто поможет внутри функции с автозавершением и проверками типов.\n\n/// tip | Подсказка\n\nВозможно, вы помните, что тела запросов также объявляются с помощью Pydantic-моделей.\n\nЗдесь **FastAPI** не запутается, потому что вы используете `Depends`.\n\n///\n\n/// check | Заметка\n\nТо, как устроена эта система зависимостей, позволяет иметь разные зависимости, которые возвращают модель `User`.\n\nМы не ограничены наличием только одной зависимости, которая может возвращать такой тип данных.\n\n///\n\n", "metadata": {"title": "Получить текущего пользователя", "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "source_mtime": "2026-01-12T17:48:13.619361+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\get-current-user.md"}, "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "title": "Получить текущего пользователя", "chunk_index": 4, "header": "Внедрить текущего пользователя", "header_level": 2, "token_count": 279}
{"id": "764b212d60c08b86", "text": "## Другие модели { #other-models }\n\nТеперь вы можете получать текущего пользователя напрямую в *функциях-обработчиках пути* и работать с механизмами безопасности на уровне **внедрения зависимостей**, используя `Depends`.\n\nИ вы можете использовать любую модель или данные для требований безопасности (в данном случае Pydantic-модель `User`).\n\nНо вы не ограничены использованием какой-то конкретной модели данных, класса или типа.\n\nХотите, чтобы в модели были `id` и `email`, но не было `username`? Пожалуйста. Можно использовать те же инструменты.\n\nХотите просто `str`? Или просто `dict`? Или напрямую экземпляр класса модели базы данных? Всё работает одинаково.\n\nУ вас вообще нет пользователей, которые входят в приложение, а есть роботы, боты или другие системы, у которых есть только токен доступа? Снова — всё работает так же.\n\nПросто используйте любую модель, любой класс, любую базу данных, которые нужны вашему приложению. Система внедрения зависимостей **FastAPI** поможет вам в этом.\n\n", "metadata": {"title": "Получить текущего пользователя", "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "source_mtime": "2026-01-12T17:48:13.619361+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\get-current-user.md"}, "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "title": "Получить текущего пользователя", "chunk_index": 5, "header": "Другие модели", "header_level": 2, "token_count": 379}
{"id": "6b37eef0f8908030", "text": "## Размер кода { #code-size }\n\nЭтот пример может показаться многословным. Имейте в виду, что в одном файле мы смешиваем безопасность, модели данных, служебные функции и *операции пути*.\n\nНо вот ключевой момент.\n\nВсё, что касается безопасности и внедрения зависимостей, пишется один раз.\n\nИ вы можете сделать это настолько сложным, насколько захотите. И всё равно это будет написано только один раз, в одном месте. Со всей гибкостью.\n\nПри этом у вас могут быть тысячи эндпоинтов (*операций пути*), использующих одну и ту же систему безопасности.\n\nИ все они (или любая их часть по вашему желанию) могут воспользоваться преимуществами повторного использования этих зависимостей или любых других зависимостей, которые вы создадите.\n\nИ все эти тысячи *операций пути* могут состоять всего из 3 строк:\n\n{* ../../docs_src/security/tutorial002_an_py310.py hl[30:32] *}\n\n", "metadata": {"title": "Получить текущего пользователя", "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "source_mtime": "2026-01-12T17:48:13.619361+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\get-current-user.md"}, "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "title": "Получить текущего пользователя", "chunk_index": 6, "header": "Размер кода", "header_level": 2, "token_count": 343}
{"id": "463aa5896a0a2b85", "text": "## Резюме { #recap }\n\nТеперь вы можете получать текущего пользователя прямо в своей *функции-обработчике пути*.\n\nМы уже на полпути.\n\nНужно лишь добавить *операцию пути*, чтобы пользователь/клиент мог отправить `username` и `password`.\n\nЭто будет дальше.\n", "metadata": {"title": "Получить текущего пользователя", "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "source_mtime": "2026-01-12T17:48:13.619361+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\get-current-user.md"}, "doc_id": "148ad282e3b8", "source_path": "docs\\tutorial\\security\\get-current-user.md", "title": "Получить текущего пользователя", "chunk_index": 7, "header": "Резюме", "header_level": 2, "token_count": 97}
{"id": "fa5b852591d657e4", "text": "# Настройка авторизации { #security }\n\nСуществует множество способов обеспечения безопасности, аутентификации и авторизации.\n\nОбычно эта тема является достаточно сложной и трудной.\n\nВо многих фреймворках и системах только работа с определением доступов к приложению и аутентификацией требует значительных затрат усилий и написания множества кода (во многих случаях его объём может составлять более 50% от всего написанного кода).\n\n**FastAPI** предоставляет несколько инструментов, которые помогут вам настроить **Авторизацию** легко, быстро, стандартным способом, без необходимости изучать все её тонкости.\n\nНо сначала давайте рассмотрим некоторые небольшие концепции.\n\n", "metadata": {"title": "Настройка авторизации", "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "source_mtime": "2026-01-12T17:48:13.628477+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\index.md"}, "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "title": "Настройка авторизации", "chunk_index": 0, "header": "Настройка авторизации", "header_level": 1, "token_count": 270}
{"id": "869d2157f37818ee", "text": "## Куда-то торопишься? { #in-a-hurry }\n\nЕсли вам не нужна информация о каких-либо из следующих терминов и вам просто нужно добавить защиту с аутентификацией на основе логина и пароля *прямо сейчас*, переходите к следующим главам.\n\n", "metadata": {"title": "Настройка авторизации", "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "source_mtime": "2026-01-12T17:48:13.628477+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\index.md"}, "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "title": "Настройка авторизации", "chunk_index": 1, "header": "Куда-то торопишься?", "header_level": 2, "token_count": 101}
{"id": "603626c235ff8539", "text": "## OAuth2 { #oauth2 }\n\nOAuth2 - это протокол, который определяет несколько способов обработки аутентификации и авторизации.\n\nОн довольно обширен и охватывает несколько сложных вариантов использования.\n\nOAuth2 включает в себя способы аутентификации с использованием \"третьей стороны\".\n\nЭто то, что используют под собой все кнопки \"вход с помощью Facebook, Google, X (Twitter), GitHub\" на страницах авторизации.\n\n", "metadata": {"title": "Настройка авторизации", "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "source_mtime": "2026-01-12T17:48:13.628477+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\index.md"}, "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "title": "Настройка авторизации", "chunk_index": 2, "header": "OAuth2", "header_level": 2, "token_count": 150}
{"id": "6dac6516e437d12e", "text": "### OAuth 1 { #oauth-1 }\n\nРанее использовался протокол OAuth 1, который сильно отличается от OAuth2 и является более сложным, поскольку он включал прямые описания того, как шифровать сообщение.\n\nВ настоящее время он не очень популярен и не используется.\n\nOAuth2 не указывает, как шифровать сообщение, он ожидает, что ваше приложение будет обслуживаться по протоколу HTTPS.\n\n/// tip | Подсказка\n\nВ разделе **Развертывание** вы увидите как настроить протокол HTTPS бесплатно, используя Traefik и Let's Encrypt.\n\n///\n\n", "metadata": {"title": "Настройка авторизации", "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "source_mtime": "2026-01-12T17:48:13.628477+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\index.md"}, "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "title": "Настройка авторизации", "chunk_index": 3, "header": "OAuth 1", "header_level": 3, "token_count": 191}
{"id": "3dfcab8be4440955", "text": "## OpenID Connect { #openid-connect }\n\nOpenID Connect - это еще один протокол, основанный на **OAuth2**.\n\nОн просто расширяет OAuth2, уточняя некоторые вещи, не имеющие однозначного определения в OAuth2, в попытке сделать его более совместимым.\n\nНапример, для входа в Google используется OpenID Connect (который под собой использует OAuth2).\n\nНо вход в Facebook не поддерживает OpenID Connect. У него есть собственная вариация OAuth2.\n\n", "metadata": {"title": "Настройка авторизации", "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "source_mtime": "2026-01-12T17:48:13.628477+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\index.md"}, "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "title": "Настройка авторизации", "chunk_index": 4, "header": "OpenID Connect", "header_level": 2, "token_count": 160}
{"id": "532a5292a71bbee6", "text": "### OpenID (не \"OpenID Connect\") { #openid-not-openid-connect }\n\nТакже ранее использовался стандарт \"OpenID\", который пытался решить ту же проблему, что и **OpenID Connect**, но не был основан на OAuth2.\n\nТаким образом, это была полноценная дополнительная система.\n\nВ настоящее время не очень популярен и не используется.\n\n", "metadata": {"title": "Настройка авторизации", "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "source_mtime": "2026-01-12T17:48:13.628477+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\index.md"}, "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "title": "Настройка авторизации", "chunk_index": 5, "header": "OpenID (не \"OpenID Connect\")", "header_level": 3, "token_count": 116}
{"id": "fa5b852591d657e4", "text": "## OpenAPI { #openapi }\n\nOpenAPI (ранее известный как Swagger) - это открытая спецификация для создания API (в настоящее время является частью Linux Foundation).\n\n**FastAPI** основан на **OpenAPI**.\n\nЭто то, что делает возможным наличие множества автоматических интерактивных интерфейсов документирования, сгенерированного кода и т.д.\n\nВ OpenAPI есть способ использовать несколько \"схем\" безопасности.\n\nТаким образом, вы можете воспользоваться преимуществами Всех этих стандартных инструментов, включая интерактивные системы документирования.\n\nOpenAPI может использовать следующие схемы авторизации:", "metadata": {"title": "Настройка авторизации", "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "source_mtime": "2026-01-12T17:48:13.628477+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\index.md", "section_header": "OpenAPI", "section_header_level": 2}, "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "title": "Настройка авторизации", "chunk_index": 6, "header": "OpenAPI", "header_level": 2, "token_count": 210}
{"id": "869d2157f37818ee", "text": "образом, вы можете воспользоваться преимуществами Всех этих стандартных инструментов, включая интерактивные системы документирования.\n\nOpenAPI может использовать следующие схемы авторизации:\n\n* `apiKey`: уникальный идентификатор для приложения, который может быть получен из:\n    * Параметров запроса.\n    * Заголовка.\n    * Cookies.\n* `http`: стандартные системы аутентификации по протоколу HTTP, включая:\n    * `bearer`: заголовок `Authorization` со значением `Bearer {уникальный токен}`. Это унаследовано от OAuth2.\n    * Базовая аутентификация по протоколу HTTP.\n    * HTTP Digest и т.д.\n* `oauth2`: все способы обеспечения безопасности OAuth2 называемые \"потоки\" (англ. \"flows\").\n    * Некоторые из этих \"потоков\" подходят для реализации аутентификации через сторонний сервис использующий OAuth 2.0 (например, Google, Facebook, X (Twitter), GitHub и т.д.):\n        * `implicit`\n        * `clientCredentials`\n        * `authorizationCode`\n    * Но есть один конкретный \"поток\", который может быть идеально использован для обработки аутентификации непосредственно в том же приложении:\n        * `password`: в некоторых следующих главах будут рассмотрены примеры этого.\n* `openIdConnect`: способ определить, как автоматически обнаруживать данные аутентификации OAuth2.\n    * Это автоматическое обнаружение определено в спецификации OpenID Connect.\n\n/// tip | Подсказка", "metadata": {"title": "Настройка авторизации", "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "source_mtime": "2026-01-12T17:48:13.628477+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\index.md", "section_header": "OpenAPI", "section_header_level": 2}, "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "title": "Настройка авторизации", "chunk_index": 7, "header": "OpenAPI", "header_level": 2, "token_count": 483}
{"id": "603626c235ff8539", "text": "определить, как автоматически обнаруживать данные аутентификации OAuth2.\n    * Это автоматическое обнаружение определено в спецификации OpenID Connect.\n\n/// tip | Подсказка\n\nИнтеграция сторонних сервисов для аутентификации/авторизации таких как Google, Facebook, X (Twitter), GitHub и т.д. осуществляется достаточно легко.\n\nСамой сложной проблемой является создание такого провайдера аутентификации/авторизации, но **FastAPI** предоставляет вам инструменты, позволяющие легко это сделать, выполняя при этом всю тяжелую работу за вас.\n\n///", "metadata": {"title": "Настройка авторизации", "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "source_mtime": "2026-01-12T17:48:13.628477+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\index.md", "section_header": "OpenAPI", "section_header_level": 2}, "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "title": "Настройка авторизации", "chunk_index": 8, "header": "OpenAPI", "header_level": 2, "token_count": 206}
{"id": "5d80166d2c8523cc", "text": "## Преимущества **FastAPI** { #fastapi-utilities }\n\nFast API предоставляет несколько инструментов для каждой из этих схем безопасности в модуле `fastapi.security`, которые упрощают использование этих механизмов безопасности.\n\nВ следующих главах вы увидите, как обезопасить свой API, используя инструменты, предоставляемые **FastAPI**.\n\nИ вы также увидите, как он автоматически интегрируется в систему интерактивной документации.\n", "metadata": {"title": "Настройка авторизации", "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "source_mtime": "2026-01-12T17:48:13.628477+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\index.md"}, "doc_id": "86c320589cab", "source_path": "docs\\tutorial\\security\\index.md", "title": "Настройка авторизации", "chunk_index": 9, "header": "Преимущества **FastAPI**", "header_level": 2, "token_count": 156}
{"id": "dcf34938ea5567f8", "text": "# OAuth2 с паролем (и хешированием), Bearer с JWT-токенами { #oauth2-with-password-and-hashing-bearer-with-jwt-tokens }\n\nТеперь, когда у нас определен процесс обеспечения безопасности, давайте сделаем приложение действительно безопасным, используя токены <abbr title=\"JSON Web Tokens – веб‑токены JSON\">JWT</abbr> и безопасное хеширование паролей.\n\nЭтот код можно реально использовать в своем приложении, сохранять хэши паролей в базе данных и т.д.\n\nМы продолжим разбираться, начиная с того места, на котором остановились в предыдущей главе.\n\n", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md"}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 0, "header": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "header_level": 1, "token_count": 204}
{"id": "dcf34938ea5567f8", "text": "## Про JWT { #about-jwt }\n\nJWT означает \"JSON Web Tokens\".\n\nЭто стандарт для кодирования JSON-объекта в виде длинной строки без пробелов. Выглядит это следующим образом:\n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n```\n\nОн не зашифрован, поэтому любой человек может восстановить информацию из его содержимого.\n\nНо он подписан. Следовательно, когда вы получаете токен, который вы эмитировали (выдавали), вы можете убедиться, что это именно вы его эмитировали.\n\nТаким образом, можно создать токен со сроком действия, скажем, 1 неделя. А когда пользователь вернется на следующий день с тем же токеном, вы будете знать, что он все еще авторизирован в вашей системе.\n\nЧерез неделю срок действия токена истечет, пользователь не будет авторизован и ему придется заново входить в систему, чтобы получить новый токен. А если пользователь (или третье лицо) попытается модифицировать токен, чтобы изменить срок действия, вы сможете это обнаружить, поскольку подписи не будут совпадать.", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md", "section_header": "Про JWT", "section_header_level": 2}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 1, "header": "Про JWT", "header_level": 2, "token_count": 476}
{"id": "d8c577293cfdd443", "text": "(или третье лицо) попытается модифицировать токен, чтобы изменить срок действия, вы сможете это обнаружить, поскольку подписи не будут совпадать.\n\nЕсли вы хотите поиграть с JWT-токенами и посмотреть, как они работают, посмотрите <a href=\"https://jwt.io/\" class=\"external-link\" target=\"_blank\">https://jwt.io</a>.", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md", "section_header": "Про JWT", "section_header_level": 2}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 2, "header": "Про JWT", "header_level": 2, "token_count": 124}
{"id": "9d04b68abed903e2", "text": "## Установка `PyJWT` { #install-pyjwt }\n\nНам необходимо установить `pyjwt` для генерации и проверки JWT-токенов на языке Python.\n\nУбедитесь, что вы создали [виртуальное окружение](../../virtual-environments.md){.internal-link target=_blank}, активируйте его, а затем установите `pyjwt`:\n\n<div class=\"termy\">\n\n```console\n$ pip install pyjwt\n\n---> 100%\n```\n\n</div>\n\n/// info | Дополнительная информация\nЕсли вы планируете использовать алгоритмы цифровой подписи, такие как RSA или ECDSA, вам следует установить зависимость библиотеки криптографии `pyjwt[crypto]`.\n\nПодробнее об этом можно прочитать в <a href=\"https://pyjwt.readthedocs.io/en/latest/installation.html\" class=\"external-link\" target=\"_blank\">документации по установке PyJWT</a>.\n///\n\n", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md"}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 3, "header": "Установка `PyJWT`", "header_level": 2, "token_count": 260}
{"id": "004e90963036dccb", "text": "## Хеширование паролей { #password-hashing }\n\n\"Хеширование\" означает преобразование некоторого содержимого (в данном случае пароля) в последовательность байтов (просто строку), которая выглядит как тарабарщина.\n\nКаждый раз, когда вы передаете точно такое же содержимое (точно такой же пароль), вы получаете точно такую же тарабарщину.\n\nНо преобразовать тарабарщину обратно в пароль невозможно.\n\n", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md"}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 4, "header": "Хеширование паролей", "header_level": 2, "token_count": 163}
{"id": "9aa89af23be13107", "text": "### Для чего нужно хеширование паролей { #why-use-password-hashing }\n\nЕсли ваша база данных будет украдена, то вор не получит пароли пользователей в открытом виде, а только их хэши.\n\nТаким образом, вор не сможет использовать этот пароль в другой системе (поскольку многие пользователи везде используют один и тот же пароль, это было бы опасно).\n\n", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md"}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 5, "header": "Для чего нужно хеширование паролей", "header_level": 3, "token_count": 124}
{"id": "f49ead61b87e4011", "text": "## Установка `pwdlib` { #install-pwdlib }\n\npwdlib — это отличный пакет Python для работы с хэшами паролей.\n\nОн поддерживает множество безопасных алгоритмов хеширования и утилит для работы с ними.\n\nРекомендуемый алгоритм — \"Argon2\".\n\nУбедитесь, что вы создали [виртуальное окружение](../../virtual-environments.md){.internal-link target=_blank}, активируйте его, и затем установите pwdlib вместе с Argon2:\n\n<div class=\"termy\">\n\n```console\n$ pip install \"pwdlib[argon2]\"\n\n---> 100%\n```\n\n</div>\n\n/// tip | Подсказка\nС помощью `pwdlib` можно даже настроить его на чтение паролей, созданных **Django**, плагином безопасности **Flask** или многими другими библиотеками.\n\nТаким образом, вы сможете, например, совместно использовать одни и те же данные из приложения Django в базе данных с приложением FastAPI. Или постепенно мигрировать Django-приложение, используя ту же базу данных.\n\nПри этом пользователи смогут одновременно входить в систему как из приложения Django, так и из приложения **FastAPI**.\n///\n\n", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md"}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 6, "header": "Установка `pwdlib`", "header_level": 2, "token_count": 375}
{"id": "dcf34938ea5567f8", "text": "## Хеширование и проверка паролей { #hash-and-verify-the-passwords }\n\nИмпортируйте необходимые инструменты из `pwdlib`.\n\nСоздайте экземпляр PasswordHash с рекомендованными настройками — он будет использоваться для хэширования и проверки паролей.\n\n/// tip | Подсказка\npwdlib также поддерживает алгоритм хеширования bcrypt, но не включает устаревшие алгоритмы — для работы с устаревшими хэшами рекомендуется использовать библиотеку passlib.\n\nНапример, вы можете использовать ее для чтения и проверки паролей, сгенерированных другой системой (например, Django), но хэшировать все новые пароли другим алгоритмом, например Argon2 или Bcrypt.\n\nИ при этом быть совместимым со всеми этими системами.\n///\n\nСоздайте служебную функцию для хэширования пароля, поступающего от пользователя.\n\nА затем создайте другую — для проверки соответствия полученного пароля и хранимого хэша.\n\nИ еще одну — для аутентификации и возврата пользователя.\n\n{* ../../docs_src/security/tutorial004_an_py310.py hl[8,49,56:57,60:61,70:76] *}", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md", "section_header": "Хеширование и проверка паролей", "section_header_level": 2}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 7, "header": "Хеширование и проверка паролей", "header_level": 2, "token_count": 382}
{"id": "d8c577293cfdd443", "text": "оля и хранимого хэша.\n\nИ еще одну — для аутентификации и возврата пользователя.\n\n{* ../../docs_src/security/tutorial004_an_py310.py hl[8,49,56:57,60:61,70:76] *}\n\n/// note | Технические детали\nЕсли проверить новую (фальшивую) базу данных `fake_users_db`, то можно увидеть, как теперь выглядит хэшированный пароль: `\"$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc\"`.\n///", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md", "section_header": "Хеширование и проверка паролей", "section_header_level": 2}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 8, "header": "Хеширование и проверка паролей", "header_level": 2, "token_count": 199}
{"id": "6a2f6b59c74d474b", "text": "## Работа с JWT токенами { #handle-jwt-tokens }\n\nИмпортируйте установленные модули.\n\nСоздайте случайный секретный ключ, который будет использоваться для подписи JWT-токенов.\n\nДля генерации безопасного случайного секретного ключа используйте команду:\n\n<div class=\"termy\">\n\n```console\n$ openssl rand -hex 32\n\n09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\n```\n\n</div>\n\nИ скопируйте полученный результат в переменную `SECRET_KEY` (не используйте тот, что в примере).\n\nСоздайте переменную `ALGORITHM` с алгоритмом, используемым для подписи JWT-токена, и установите для нее значение `\"HS256\"`.\n\nСоздайте переменную для срока действия токена.\n\nОпределите Pydantic-модель, которая будет использоваться для формирования ответа на запрос на получение токена.\n\nСоздайте служебную функцию для генерации нового токена доступа.\n\n{* ../../docs_src/security/tutorial004_an_py310.py hl[4,7,13:15,29:31,79:87] *}\n\n", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md"}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 9, "header": "Работа с JWT токенами", "header_level": 2, "token_count": 337}
{"id": "35714781ce8e0810", "text": "## Обновление зависимостей { #update-the-dependencies }\n\nОбновите `get_current_user` для получения того же токена, что и раньше, но на этот раз с использованием JWT-токенов.\n\nДекодируйте полученный токен, проверьте его и верните текущего пользователя.\n\nЕсли токен недействителен, то сразу же верните HTTP-ошибку.\n\n{* ../../docs_src/security/tutorial004_an_py310.py hl[90:107] *}\n\n", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md"}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 10, "header": "Обновление зависимостей", "header_level": 2, "token_count": 130}
{"id": "1ea52a5461b39b35", "text": "## Обновление *операции пути* `/token` { #update-the-token-path-operation }\n\nСоздайте `timedelta` со временем истечения срока действия токена.\n\nСоздайте реальный токен доступа JWT и верните его\n\n{* ../../docs_src/security/tutorial004_an_py310.py hl[118:133] *}\n\n", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md"}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 11, "header": "Обновление *операции пути* `/token`", "header_level": 2, "token_count": 87}
{"id": "dcf34938ea5567f8", "text": "### Технические подробности о JWT ключе `sub` { #technical-details-about-the-jwt-subject-sub }\n\nВ спецификации JWT говорится, что существует ключ `sub`, содержащий субъект токена.\n\nЕго использование необязательно, но это именно то место, куда вы должны поместить идентификатор пользователя, и поэтому мы здесь его и используем.\n\nJWT может использоваться и для других целей, помимо идентификации пользователя и предоставления ему возможности выполнять операции непосредственно в вашем API.\n\nНапример, вы могли бы определить \"автомобиль\" или \"запись в блоге\".\n\nЗатем вы могли бы добавить права доступа к этой сущности, например \"управлять\" (для автомобиля) или \"редактировать\" (для блога).\n\nЗатем вы могли бы передать этот JWT-токен пользователю (или боту), и они использовали бы его для выполнения определенных действий (управление автомобилем или редактирование запись в блоге), даже не имея учетной записи, просто используя JWT-токен, сгенерированный вашим API.\n\nИспользуя эти идеи, JWT можно применять для гораздо более сложных сценариев.\n\nВ отдельных случаях несколько сущностей могут иметь один и тот же идентификатор, скажем, `foo` (пользователь `foo`, автомобиль `foo` и запись в блоге `foo`).", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md", "section_header": "Технические подробности о JWT ключе `sub`", "section_header_level": 3}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 12, "header": "Технические подробности о JWT ключе `sub`", "header_level": 3, "token_count": 455}
{"id": "d8c577293cfdd443", "text": "ных случаях несколько сущностей могут иметь один и тот же идентификатор, скажем, `foo` (пользователь `foo`, автомобиль `foo` и запись в блоге `foo`).\n\nПоэтому, чтобы избежать коллизий идентификаторов, при создании JWT-токена для пользователя можно добавить префикс `username` к значению ключа `sub`. Таким образом, в данном примере значение `sub` было бы `username:johndoe`.\n\nВажно помнить, что ключ `sub` должен иметь уникальный идентификатор для всего приложения и представлять собой строку.", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md", "section_header": "Технические подробности о JWT ключе `sub`", "section_header_level": 3}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 13, "header": "Технические подробности о JWT ключе `sub`", "header_level": 3, "token_count": 189}
{"id": "aef90e65b828cc00", "text": "## Проверка в действии { #check-it }\n\nЗапустите сервер и перейдите к документации: <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a>.\n\nВы увидите пользовательский интерфейс вида:\n\n<img src=\"/img/tutorial/security/image07.png\">\n\nПройдите авторизацию так же, как делали раньше.\n\nИспользуя учетные данные пользователя:\n\nUsername: `johndoe`\nPassword: `secret`\n\n/// check | Проверка\nОбратите внимание, что нигде в коде не используется открытый текст пароля \"`secret`\", мы используем только его хэшированную версию.\n///\n\n<img src=\"/img/tutorial/security/image08.png\">\n\nВызвав эндпоинт `/users/me/`, вы получите ответ в виде:\n\n```JSON\n{\n  \"username\": \"johndoe\",\n  \"email\": \"johndoe@example.com\",\n  \"full_name\": \"John Doe\",\n  \"disabled\": false\n}\n```\n\n<img src=\"/img/tutorial/security/image09.png\">\n\nЕсли открыть инструменты разработчика, то можно увидеть, что передаваемые данные включают только токен, пароль передается только в первом запросе для аутентификации пользователя и получения токена доступа, но не в последующих:\n\n<img src=\"/img/tutorial/security/image10.png\">\n\n/// note | Техническая информация\nОбратите внимание на HTTP-заголовок `Authorization`, значение которого начинается с `Bearer `.\n///\n\n", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md"}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 14, "header": "Проверка в действии", "header_level": 2, "token_count": 411}
{"id": "6c38a8cce0722d3d", "text": "## Продвинутое использование `scopes` { #advanced-usage-with-scopes }\n\nВ OAuth2 существует понятие \"диапазоны\" (\"`scopes`\").\n\nС их помощью можно добавить определенный набор разрешений к JWT-токену.\n\nЗатем вы можете передать этот токен непосредственно пользователю или третьей стороне для взаимодействия с вашим API с определенным набором ограничений.\n\nО том, как их использовать и как они интегрированы в **FastAPI**, читайте далее в **Расширенном руководстве пользователя**.\n\n", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md"}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 15, "header": "Продвинутое использование `scopes`", "header_level": 2, "token_count": 184}
{"id": "dcf34938ea5567f8", "text": "## Резюме { #recap }\n\nС учетом того, что вы видели до сих пор, вы можете создать безопасное приложение **FastAPI**, используя такие стандарты, как OAuth2 и JWT.\n\nПрактически в любом фреймворке работа с безопасностью довольно быстро превращается в сложную тему.\n\nМногие пакеты, сильно упрощающие эту задачу, вынуждены идти на многочисленные компромиссы с моделью данных, с базой данных и с доступным функционалом. Некоторые из этих пакетов, которые пытаются уж слишком все упростить, имеют даже \"дыры\" в системе безопасности.\n\n---\n\n**FastAPI** не делает уступок ни одной базе данных, модели данных или инструментарию.\n\nОн предоставляет вам полную свободу действий, позволяя выбирать то, что лучше всего подходит для вашего проекта.\n\nВы можете напрямую использовать многие хорошо поддерживаемые и широко распространенные пакеты, такие как `pwdlib` и `PyJWT`, поскольку **FastAPI** не требует сложных механизмов для интеграции внешних пакетов.\n\nНапротив, он предоставляет инструменты, позволяющие максимально упростить этот процесс без ущерба для гибкости, надежности и безопасности.\n\nПри этом вы можете использовать и реализовывать безопасные стандартные протоколы, такие как OAuth2, относительно простым способом.", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md", "section_header": "Резюме", "section_header_level": 2}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 16, "header": "Резюме", "header_level": 2, "token_count": 499}
{"id": "d8c577293cfdd443", "text": "бкости, надежности и безопасности.\n\nПри этом вы можете использовать и реализовывать безопасные стандартные протоколы, такие как OAuth2, относительно простым способом.\n\nВ **Расширенном руководстве пользователя** вы можете узнать больше о том, как использовать \"диапазоны\" (\"`scopes`\") OAuth2 для создания более точно настроенной системы разрешений в соответствии с теми же стандартами. OAuth2 с диапазонами — это механизм, используемый многими крупными провайдерами сервиса аутентификации, такими как Facebook, Google, GitHub, Microsoft, X (Twitter) и др., для авторизации сторонних приложений на взаимодействие с их API от имени их пользователей.", "metadata": {"title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "source_mtime": "2026-01-12T17:48:13.635228+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\oauth2-jwt.md", "section_header": "Резюме", "section_header_level": 2}, "doc_id": "f608c8d1cf98", "source_path": "docs\\tutorial\\security\\oauth2-jwt.md", "title": "OAuth2 с паролем (и хешированием), Bearer с JWT-токенами", "chunk_index": 17, "header": "Резюме", "header_level": 2, "token_count": 247}
{"id": "d2667089227696c2", "text": "# Простая авторизация OAuth2 с паролем и «Bearer» { #simple-oauth2-with-password-and-bearer }\n\nТеперь, отталкиваясь от предыдущей главы, добавим недостающие части, чтобы получить полный поток безопасности.\n\n", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md"}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 0, "header": "Простая авторизация OAuth2 с паролем и «Bearer»", "header_level": 1, "token_count": 77}
{"id": "9e915f30f2829d82", "text": "## Получение `username` и `password` { #get-the-username-and-password }\n\nДля получения `username` и `password` мы будем использовать утилиты безопасности **FastAPI**.\n\nOAuth2 определяет, что при использовании \"password flow\" (аутентификация по паролю - именно его мы используем) клиент/пользователь должен передавать поля `username` и `password` в полях формы.\n\nВ спецификации сказано, что поля должны быть названы именно так. Поэтому `user-name` или `email` работать не будут.\n\nНо не волнуйтесь, вы можете показать это конечным пользователям во фронтенде в том виде, в котором хотите.\n\nА ваши модели баз данных могут использовать любые другие имена.\n\nНо для логин-операции пути нам нужно использовать именно эти имена, чтобы быть совместимыми со спецификацией (и иметь возможность, например, использовать встроенную систему документации API).\n\nВ спецификации также указано, что `username` и `password` должны передаваться в виде данных формы (так что никакого JSON здесь нет).\n\n", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md"}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 1, "header": "Получение `username` и `password`", "header_level": 2, "token_count": 338}
{"id": "51447f7cdac7cea1", "text": "### `scope` { #scope }\n\nВ спецификации также говорится, что клиент может передать еще одно поле формы — `scope`.\n\nИмя поля формы — `scope` (в единственном числе), но на самом деле это длинная строка, состоящая из отдельных \"scopes\", разделенных пробелами.\n\nКаждый \"scope\" — это просто строка (без пробелов).\n\nОбычно они используются для указания уровней доступа, например:\n\n* `users:read` или `users:write` — распространенные примеры.\n* `instagram_basic` используется Facebook / Instagram.\n* `https://www.googleapis.com/auth/drive` используется Google.\n\n/// info | Дополнительная информация\nВ OAuth2 \"scope\" — это просто строка, которая указывает требуемое конкретное разрешение.\n\nНе имеет значения, содержит ли она другие символы, например `:`, или является ли это URL.\n\nЭти детали зависят от реализации.\n\nДля OAuth2 это просто строки.\n///\n\n", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md"}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 2, "header": "`scope`", "header_level": 3, "token_count": 296}
{"id": "c66cf9272e2d39d0", "text": "## Код для получения `username` и `password` { #code-to-get-the-username-and-password }\n\nТеперь воспользуемся утилитами, предоставляемыми **FastAPI**, чтобы обработать это.\n\n", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md"}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 3, "header": "Код для получения `username` и `password`", "header_level": 2, "token_count": 57}
{"id": "d2667089227696c2", "text": "### `OAuth2PasswordRequestForm` { #oauth2passwordrequestform }\n\nСначала импортируйте `OAuth2PasswordRequestForm` и затем используйте её как зависимость с `Depends` в операции пути для `/token`:\n\n{* ../../docs_src/security/tutorial003_an_py310.py hl[4,78] *}\n\n`OAuth2PasswordRequestForm` — это зависимость-класс, которая объявляет тело формы со следующими полями:\n\n* `username`.\n* `password`.\n* Необязательное поле `scope` в виде большой строки, состоящей из строк, разделенных пробелами.\n* Необязательное поле `grant_type`.\n\n/// tip | Подсказка\nПо спецификации OAuth2 поле `grant_type` обязательно и содержит фиксированное значение `password`, но `OAuth2PasswordRequestForm` это не проверяет строго.\n\nЕсли вам нужно это строгое требование, используйте `OAuth2PasswordRequestFormStrict` вместо `OAuth2PasswordRequestForm`.\n///\n\n* Необязательное поле `client_id` (в нашем примере оно не нужно).\n* Необязательное поле `client_secret` (в нашем примере оно не нужно).\n\n/// info | Дополнительная информация\n`OAuth2PasswordRequestForm` — это не специальный класс для **FastAPI**, как `OAuth2PasswordBearer`.\n\n`OAuth2PasswordBearer` сообщает **FastAPI**, что это схема безопасности. Поэтому она добавляется в OpenAPI соответствующим образом.\n\nА `OAuth2PasswordRequestForm` — это просто зависимость-класс, которую вы могли бы написать сами, или вы могли бы объявить параметры `Form` напрямую.", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md", "section_header": "`OAuth2PasswordRequestForm`", "section_header_level": 3}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 4, "header": "`OAuth2PasswordRequestForm`", "header_level": 3, "token_count": 468}
{"id": "9e915f30f2829d82", "text": "ветствующим образом.\n\nА `OAuth2PasswordRequestForm` — это просто зависимость-класс, которую вы могли бы написать сами, или вы могли бы объявить параметры `Form` напрямую.\n\nНо так как это распространённый вариант использования, он предоставлен **FastAPI** напрямую, чтобы упростить задачу.\n///", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md", "section_header": "`OAuth2PasswordRequestForm`", "section_header_level": 3}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 5, "header": "`OAuth2PasswordRequestForm`", "header_level": 3, "token_count": 111}
{"id": "56b3655cd02491ed", "text": "### Использование данных формы { #use-the-form-data }\n\n/// tip | Подсказка\nУ экземпляра зависимости `OAuth2PasswordRequestForm` не будет атрибута `scope` с длинной строкой, разделенной пробелами. Вместо этого будет атрибут `scopes` со списком отдельных строк — по одной для каждого переданного scope.\n\nВ данном примере мы не используем `scopes`, но если вам это необходимо, функциональность есть.\n///\n\nТеперь получим данные о пользователе из (ненастоящей) базы данных, используя `username` из поля формы.\n\nЕсли такого пользователя нет, то мы возвращаем ошибку \"Incorrect username or password\" (неверное имя пользователя или пароль).\n\nДля ошибки используем исключение `HTTPException`:\n\n{* ../../docs_src/security/tutorial003_an_py310.py hl[3,79:81] *}\n\n", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md"}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 6, "header": "Использование данных формы", "header_level": 3, "token_count": 238}
{"id": "d2667089227696c2", "text": "### Проверка пароля { #check-the-password }\n\nНа данный момент у нас есть данные о пользователе из нашей базы данных, но мы еще не проверили пароль.\n\nДавайте сначала поместим эти данные в Pydantic-модель `UserInDB`.\n\nНикогда нельзя сохранять пароли в открытом виде, поэтому мы будем использовать (пока что ненастоящую) систему хеширования паролей.\n\nЕсли пароли не совпадают, мы возвращаем ту же ошибку.\n\n#### Хеширование паролей { #password-hashing }\n\n\"Хеширование\" означает: преобразование некоторого содержимого (в данном случае пароля) в последовательность байтов (просто строку), которая выглядит как тарабарщина.\n\nКаждый раз, когда вы передаете точно такое же содержимое (точно такой же пароль), вы получаете точно такую же тарабарщину.\n\nНо преобразовать тарабарщину обратно в пароль невозможно.\n\n##### Зачем использовать хеширование паролей { #why-use-password-hashing }\n\nЕсли вашу базу данных украдут, у злоумышленника не будет паролей пользователей в открытом виде, только хэши.\n\nТаким образом, он не сможет попробовать использовать эти же пароли в другой системе (поскольку многие пользователи используют один и тот же пароль повсеместно, это было бы опасно).\n\n{* ../../docs_src/security/tutorial003_an_py310.py hl[82:85] *}\n\n#### Про `**user_dict` { #about-user-dict }\n\n`UserInDB(**user_dict)` означает:", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md", "section_header": "Проверка пароля", "section_header_level": 3}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 7, "header": "Проверка пароля", "header_level": 3, "token_count": 491}
{"id": "9e915f30f2829d82", "text": "же пароль повсеместно, это было бы опасно).\n\n{* ../../docs_src/security/tutorial003_an_py310.py hl[82:85] *}\n\n#### Про `**user_dict` { #about-user-dict }\n\n`UserInDB(**user_dict)` означает:\n\n*Передать ключи и значения `user_dict` непосредственно как аргументы ключ-значение, эквивалентно:*\n\n```Python\nUserInDB(\n    username = user_dict[\"username\"],\n    email = user_dict[\"email\"],\n    full_name = user_dict[\"full_name\"],\n    disabled = user_dict[\"disabled\"],\n    hashed_password = user_dict[\"hashed_password\"],\n)\n```\n\n/// info | Дополнительная информация\nБолее полное объяснение `**user_dict` можно найти в [документации к **Дополнительным моделям**](../extra-models.md#about-user-in-dict){.internal-link target=_blank}.\n///", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md", "section_header": "Проверка пароля", "section_header_level": 3}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 8, "header": "Проверка пароля", "header_level": 3, "token_count": 223}
{"id": "90dbfe4aa4a6010f", "text": "## Возврат токена { #return-the-token }\n\nОтвет операции пути `/token` должен быть объектом JSON.\n\nВ нём должен быть `token_type`. В нашем случае, поскольку мы используем токены типа \"Bearer\", тип токена должен быть `bearer`.\n\nИ в нём должен быть `access_token` — строка, содержащая наш токен доступа.\n\nВ этом простом примере мы намеренно поступим небезопасно и вернём тот же `username` в качестве токена.\n\n/// tip | Подсказка\nВ следующей главе вы увидите реальную защищённую реализацию с хешированием паролей и токенами <abbr title=\"JSON Web Tokens – JSON веб-токены\">JWT</abbr>.\n\nНо пока давайте сосредоточимся на необходимых нам деталях.\n///\n\n{* ../../docs_src/security/tutorial003_an_py310.py hl[87] *}\n\n/// tip | Подсказка\nСогласно спецификации, вы должны возвращать JSON с `access_token` и `token_type`, как в данном примере.\n\nЭто то, что вы должны сделать сами в своём коде и убедиться, что вы используете именно эти JSON-ключи.\n\nЭто практически единственное, о чём нужно не забыть, чтобы соответствовать спецификациям.\n\nОстальное за вас сделает **FastAPI**.\n///\n\n", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md"}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 9, "header": "Возврат токена", "header_level": 2, "token_count": 411}
{"id": "7e2fff3e554d9d94", "text": "## Обновление зависимостей { #update-the-dependencies }\n\nТеперь мы обновим наши зависимости.\n\nМы хотим получить `current_user` только если этот пользователь активен.\n\nПоэтому мы создаём дополнительную зависимость `get_current_active_user`, которая, в свою очередь, использует в качестве зависимости `get_current_user`.\n\nОбе эти зависимости просто вернут HTTP-ошибку, если пользователь не существует или неактивен.\n\nТаким образом, в нашей операции пути мы получим пользователя только в том случае, если он существует, корректно аутентифицирован и активен:\n\n{* ../../docs_src/security/tutorial003_an_py310.py hl[58:66,69:74,94] *}\n\n/// info | Дополнительная информация\nДополнительный HTTP-заголовок `WWW-Authenticate` со значением `Bearer`, который мы здесь возвращаем, также является частью спецификации.\n\nЛюбой HTTP статус-код 401 \"UNAUTHORIZED\" должен также возвращать заголовок `WWW-Authenticate`.\n\nВ случае с bearer-токенами (наш случай) значение этого заголовка должно быть `Bearer`.\n\nФактически, этот дополнительный заголовок можно опустить, и всё будет работать.\n\nНо он приведён здесь для соответствия спецификациям.\n\nКроме того, могут существовать инструменты, которые ожидают его и могут использовать, и это может быть полезно для вас или ваших пользователей — сейчас или в будущем.\n\nВ этом и заключается преимущество стандартов...\n///\n\n", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md"}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 10, "header": "Обновление зависимостей", "header_level": 2, "token_count": 470}
{"id": "6382983c1de8ac53", "text": "## Посмотрим, как это работает { #see-it-in-action }\n\nОткройте интерактивную документацию: <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a>.\n\n", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md"}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 11, "header": "Посмотрим, как это работает", "header_level": 2, "token_count": 74}
{"id": "3a6255e43341e4d9", "text": "### Аутентификация { #authenticate }\n\nНажмите кнопку \"Authorize\".\n\nИспользуйте учётные данные:\n\nПользователь: `johndoe`\n\nПароль: `secret`\n\n<img src=\"/img/tutorial/security/image04.png\">\n\nПосле аутентификации вы увидите следующее:\n\n<img src=\"/img/tutorial/security/image05.png\">\n\n", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md"}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 12, "header": "Аутентификация", "header_level": 3, "token_count": 88}
{"id": "e3c1147c09a33550", "text": "### Получение собственных пользовательских данных { #get-your-own-user-data }\n\nТеперь используйте операцию `GET` с путём `/users/me`.\n\nВы получите свои пользовательские данные, например:\n\n```JSON\n{\n  \"username\": \"johndoe\",\n  \"email\": \"johndoe@example.com\",\n  \"full_name\": \"John Doe\",\n  \"disabled\": false,\n  \"hashed_password\": \"fakehashedsecret\"\n}\n```\n\n<img src=\"/img/tutorial/security/image06.png\">\n\nЕсли щёлкнуть на значке замка и выйти из системы, а затем попытаться выполнить ту же операцию ещё раз, будет выдана ошибка HTTP 401:\n\n```JSON\n{\n  \"detail\": \"Not authenticated\"\n}\n```\n\n", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md"}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 13, "header": "Получение собственных пользовательских данных", "header_level": 3, "token_count": 196}
{"id": "6a1837e8403d2017", "text": "### Неактивный пользователь { #inactive-user }\n\nТеперь попробуйте с неактивным пользователем, аутентифицируйтесь с:\n\nПользователь: `alice`\n\nПароль: `secret2`\n\nИ попробуйте использовать операцию `GET` с путём `/users/me`.\n\nВы получите ошибку \"Inactive user\", как здесь:\n\n```JSON\n{\n  \"detail\": \"Inactive user\"\n}\n```\n\n", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md"}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 14, "header": "Неактивный пользователь", "header_level": 3, "token_count": 113}
{"id": "69dacc58324044b4", "text": "## Резюме { #recap }\n\nТеперь у вас есть инструменты для реализации полноценной системы безопасности на основе `username` и `password` для вашего API.\n\nИспользуя эти средства, можно сделать систему безопасности совместимой с любой базой данных и с любой пользовательской или моделью данных.\n\nЕдинственная деталь, которой не хватает, — система пока ещё не \"защищена\" по-настоящему.\n\nВ следующей главе вы увидите, как использовать библиотеку безопасного хеширования паролей и токены <abbr title=\"JSON Web Tokens – JSON веб-токены\">JWT</abbr>.\n", "metadata": {"title": "Простая авторизация OAuth2 с паролем и «Bearer»", "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "source_mtime": "2026-01-12T17:48:13.640719+00:00", "file_path": "C:\\Users\\klimm\\Desktop\\ITMO\\Third_semester\\LLM\\lab2\\data\\processed\\docs\\tutorial\\security\\simple-oauth2.md"}, "doc_id": "13a4d8ec32f3", "source_path": "docs\\tutorial\\security\\simple-oauth2.md", "title": "Простая авторизация OAuth2 с паролем и «Bearer»", "chunk_index": 15, "header": "Резюме", "header_level": 2, "token_count": 207}
