{
  "datasets": [
    "fastapi_rag_baseline_recursive_1024",
    "fastapi_rag_markdown_512"
  ],
  "questions": [
    {
      "question": "Как работать с базами данных в FastAPI?",
      "expected_chunk_ids": [
        "7933cd1b67cfd069",
        "c72fa3007b9a0a8c",
        "2d9f85dc956ae993",
        "715accd7daa3b1b2",
        "7933cd1b67cfd069",
        "d9e65ccf4aa04a2c",
        "9456ced2a88006ea"
      ],
      "configurations": {
        "fastapi_rag_baseline_recursive_1024": {
          "answer": "Чтобы работать с базами данных в FastAPI, можно использовать библиотеку SQLModel поверх SQLAlchemy. Вот основные шаги:\n\n1. Установите библиотеку `sqlmodel`:\n   ```console\n   $ pip install sqlmodel\n   ```\n\n2. Создайте модель базы данных с использованием SQLModel:\n   - Импортируйте и создайте модель базы данных, например для моделирования объектов `Hero`.\n   - Объявите все поля, которые вы хотите хранить в базе данных.\n   \n3. Сгенерируйте модель-таблицу (ORM) с помощью SQLAlchemy:\n   ```python\n   from sqlalchemy.ext.declarative import declarative_base\n   Base = declarative_base()\n\n   class Hero(Base):\n       __tablename__ = 'heroes'\n       id = Column(Integer, primary_key=True)\n       name = Column(String)\n       age = Column(Integer)\n       secret_name = Column(String)\n\n   # Используйте это для работы с базой данных\n   from sqlalchemy import create_engine\n   engine = create_engine('sqlite:///mydatabase.db')\n   Base.metadata.create_all(engine)\n   ```\n\n4. Создайте функции, которые будут работать с базой данных:\n   - `HeroCreate`: модель данных для создания нового объекта.\n   - `HeroUpdate`: модель данных для обновления существующего объекта.\n   \n5. Используйте `response_model` в декораторах FastAPI для валидации и сериализации данных:\n\n   ```python\n   from fastapi import FastAPI, HTTPException\n\n   app = FastAPI()\n\n   # Пример использования response_model\n   @app.post(\"/heroes/\", response_model=HeroPublic)\n   def create_hero(hero: HeroCreate):\n       new_hero = Hero(**hero.dict())\n       db.session.add(new_hero)\n       db.session.commit()\n       return new_hero\n\n   @app.put(\"/heroes/{hero_id}\", response_model=HeroPublic)\n   def update_hero(hero_id: int, hero_data: dict, response_model=HeroPublic):\n       # Обновление с использованием exclude_unset=True\n       hero_db = Hero.query.get_or_404(hero_id)\n       hero_db.sqlmodel_update(hero_data)\n       db.session.commit()\n       return hero_db\n\n   @app.delete(\"/heroes/{hero_id}\")\n   def delete_hero(hero_id: int):\n      ",
          "retrieved_chunk_ids": [
            "c7925fa01fa4c8bc",
            "ebba04292abcdd2e",
            "4bfd2e2135d56297",
            "7933cd1b67cfd069",
            "3039f0a6acc0cd95"
          ],
          "metrics": {
            "mrr": 0.25,
            "recall@5": 0.1666666666666667,
            "precision@5": 0.2
          }
        },
        "fastapi_rag_markdown_512": {
          "answer": "Работать с базами данных в FastAPI можно благодаря совместимости **FastAPI** с Pydantic, что позволяет автоматически проверять и преобразовывать данные перед их отправкой в базу данных или обратно клиенту. \n\nОсновные шаги для работы с базами данных в FastAPI:\n\n1. Используйте модели Pydantic для описания структуры объектов данных.\n2. Создайте экземпляр вашего SQLAlchemy-драйвера (или другого подходящего драйвера) и подключите его к вашему приложению FastAPI.\n\nПример использования SQLAlchemy:\n\n[Документ 4] показывает, как создать базовый код для FastAPI. Вы можете добавить подключение к базе данных в файл `main.py` следующим образом:\n\n```Python\nfrom typing import Optional\nimport sqlalchemy as sa\n\napp = FastAPI()\n\nDATABASE_URL = \"sqlite:///./test.db\"  # или ваша база данных\n\nengine = sa.create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False})\n\n# Создание таблицы в базе данных (если они еще не созданы)\nsa.MetaData().reflect(engine)\n\n# Подключение моделей к базе данных\nfrom app.models import User  # Импортируйте вашу модель\n\n@app.on_event(\"startup\")\nasync def startup():\n    async with engine.begin() as conn:\n        await conn.run_sync(sa.MetaData().create_all)\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n# Добавьте маршруты для работы с пользователями\n```\n\n[Документ 5] упоминает, что **FastAPI** полностью совместим с Pydantic. Это означает, что вы можете использовать модели Pydantic для представления объектов данных в базе данных и передачи их клиенту.\n\nТакже важно отметить, что [Документ 3] предоставляет дополнительную информацию о преимуществах использования моделей Pydantic, таких как автозавершение кода, преобразование данных и валидация. Это позволяет упростить процесс работы с базами данных и сделать код более чистым и понятным.\n\nИсточники информации:\n1. [Документ 4]\n2. [Документ 5]",
          "retrieved_chunk_ids": [
            "410f3c0b627c5584",
            "19c9c3139898339e",
            "9a611ff7c3818bf2",
            "ec3852f5eecef381",
            "a4512580df001c5f"
          ],
          "metrics": {
            "mrr": 0,
            "recall@5": 0,
            "precision@5": 0
          }
        }
      }
    },
    {
      "question": "Как управлять OpenAPI документацией в FastAPI?",
      "expected_chunk_ids": [
        "bdfb8357d8f70c9e",
        "bee16194ea8648ab",
        "869d2157f37818ee",
        "be181a049a465b0d",
        "59d4886c438cc85a",
        "612ae48c0dcfaf2d",
        "d4a1e64df7104421"
      ],
      "configurations": {
        "fastapi_rag_baseline_recursive_1024": {
          "answer": "Управлять OpenAPI документацией в FastAPI можно несколькими способами, основанными на информации из предоставленных документов. \n\nВо-первых, вы можете переопределить значения по умолчанию при генерации схемы OpenAPI с помощью функции `custom_openapi()`. В этом процессе вы можете добавить расширения, такие как [Redoc](https://github.com/Rebilly/ReDoc) для включения собственного логотипа. Это показано в примерах из документации, где используется вспомогательная функция `fastapi.openapi.utils.get_openapi()`.\n\nВо-вторых, вы можете настроить метаданные для API с помощью параметров `title`, `summary`, `description`, и других, которые используются в спецификации OpenAPI. Это позволяет добавлять дополнительную информацию о вашем API, например, контактные данные или информацию о лицензии.\n\nТакже важно отметить, что вы можете расширить схему OpenAPI для операции пути с помощью параметра `openapi_extra`. Этот подход может быть полезен, если вам нужно объявить дополнительные ответы или другие пользовательские сведения в документации OpenAPI без использования автоматических возможностей FastAPI и Pydantic.\n\nИсточники информации:\n1. [Документ 3]\n2. [Документ 4]\n3. [Документ 5]\n\nЭти подходы позволяют вам управлять и настраивать OpenAPI документацию в соответствии с вашими потребностями, обеспечивая более детализированную и точную информацию для пользователей API.",
          "retrieved_chunk_ids": [
            "6606c2905a786429",
            "6bad2386b0044a19",
            "58b52f4b04dd86c9",
            "91852a5f582dffa2",
            "8b5a9dd3049fc9df"
          ],
          "metrics": {
            "mrr": 0,
            "recall@5": 0,
            "precision@5": 0
          }
        },
        "fastapi_rag_markdown_512": {
          "answer": "Управлять OpenAPI документацией в FastAPI можно несколькими способами, основанными на предоставленной информации из документов:\n\n1. **Настройка схемы OpenAPI**: Вы можете задокументировать дополнительные статус-коды и ответы напрямую в ваш код, используя спецификацию [additional-responses.md](docs\\advanced\\additional-status-codes.md#additional-responses). Это позволяет добавить информацию о новых ответах к схеме OpenAPI.\n\n2. **Использование настроек Pydantic**: Вы можете использовать те же настройки, которые используются для других параметров приложения FastAPI, чтобы задокументировать и настроить сгенерированный OpenAPI и интерфейсы документации. Это можно сделать путем объявления настроек `openapi_url` в переменных окружения или при создании приложения.\n\n3. **Условный режим отключения**: Вы можете отключать OpenAPI (и, следовательно, интерфейсы документации) с помощью переменной окружения `OPENAPI_URL`. Если переменная окружения установлена в пустую строку, FastAPI не будет генерировать и предоставлять эти ресурсы.\n\nИсточники информации:\n1. [Документ 1](docs\\advanced\\additional-status-codes.md#openapi-and-api-docs)\n2. [Документ 2](docs\\tutorial\\security\\index.md#OpenAPI)\n3. [Документ 4](docs\\how-to\\conditional-openapi.md#Условный OpenAPI из настроек и переменных окружения)\n4. [Документ 5](docs\\tutorial\\dependencies\\index.md#Интегрировано с **OpenAPI**)\n\nЭти методы позволяют вам настраивать и управлять документацией API, включая OpenAPI, в соответствии с вашими потребностями.",
          "retrieved_chunk_ids": [
            "fbe2c1f3520b1841",
            "fa5b852591d657e4",
            "81b6aaa763c1ad28",
            "3b7693dc981d8646",
            "843bb8def92d00fa"
          ],
          "metrics": {
            "mrr": 0.2,
            "recall@5": 0.1428571428571428,
            "precision@5": 0.2
          }
        }
      }
    },
    {
      "question": "Как настроить безопасность и конфигурацию в FastAPI?",
      "expected_chunk_ids": [
        "68857fea257435ac",
        "8fbb0d29d774b8e8",
        "bb737298833922c2",
        "129ab07419015e16",
        "11c330cb4143e4cf",
        "d53e2cc55486001c",
        "d36dd4c5c9756029",
        "94eb7f7d076ac846"
      ],
      "configurations": {
        "fastapi_rag_baseline_recursive_1024": {
          "answer": "Настройка безопасности и конфигурации в FastAPI может быть выполнена с использованием различных инструментов, предоставляемых модулем `fastapi.security`. Вот основные шаги для настройки:\n\n1. **Использование безопасных механизмов**: FastAPI предоставляет несколько инструментов для обеспечения безопасности API, таких как авторизация и аутентификация. Например, можно использовать классы из модуля `fastapi.security` для создания различных типов токенов (например, JWT) или других методов аутентификации.\n\n2. **Декораторы операций пути**: Для защиты определенных операций пути можно использовать декораторы, которые автоматически добавляют проверки безопасности в схему OpenAPI. Например, можно использовать `Depends` для использования зависимостей и проверок перед выполнением функции.\n\n3. **Различные уровни доступа**: В FastAPI можно определить разные уровни доступа (например, текущий пользователь, активный пользователь, администратор) и применять эти уровни к различным операциям путей. Это позволяет управлять правами доступа на уровне конкретных операций.\n\n4. **Интеграция с OpenAPI**: FastAPI автоматически интегрируется с системой интерактивной документации, что позволяет легко добавлять параметры проверки и т.д. к вашим операциям путей в схему OpenAPI.\n\n5. **Развертывание на FastAPI Cloud**: Для развертывания приложения можно использовать инструменты FastAPI Cloud, которые автоматически упрощают процесс создания образа, развертывания и доступа к API.\n\nДля более подробной информации по этим вопросам рекомендуется обратиться к следующим источникам:\n\n- [Документ 1] (docs\\tutorial\\security\\index.md)\n- [Документ 2] (docs\\tutorial\\dependencies\\index.md)\n- [Документ 3] (docs\\tutorial\\first-steps.md)\n\nЭти документы содержат более подробные примеры и инструкции по настройке безопасности и конфигурации в FastAPI.",
          "retrieved_chunk_ids": [
            "603626c235ff8539",
            "d4a1e64df7104421",
            "58b52f4b04dd86c9",
            "ebba04292abcdd2e",
            "710755eafba7793e"
          ],
          "metrics": {
            "mrr": 0,
            "recall@5": 0,
            "precision@5": 0
          }
        },
        "fastapi_rag_markdown_512": {
          "answer": "Чтобы настроить безопасность и конфигурацию в FastAPI, вам нужно использовать инструменты безопасности, предоставляемые модулем `fastapi.security`. Вот основные шаги:\n\n1. **Использование OAuth2 с JWT**: Вы можете использовать класс `OAuth2PasswordBearer` из зависимости `fastapi.security.oauth2`, который наследуется от `SecurityBase`. Это позволяет вам использовать стандартные протоколы безопасности, такие как OAuth2 и JWT.\n\n   Пример использования:\n   ```python\n   from fastapi import FastAPI, Depends\n   from fastapi.security.oauth2 import OAuth2PasswordBearer\n\n   app = FastAPI()\n\n   oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n   @app.get(\"/items/\")\n   def read_items(current_user: str = Depends(oauth2_scheme)):\n       return {\"current_user\": current_user}\n   ```\n\n2. **Интеграция с OpenAPI**: FastAPI интегрируется автоматически с OpenAPI, что позволяет использовать различные \"схемы\" безопасности, включая OAuth2 и JWT.\n\n3. **Управление зависимостями**: Если вы хотите установить только стандартные зависимости без `fastapi-cloud-cli`, можно установить пакет следующим образом:\n   ```console\n   $ pip install fastapi[standard-no-fastapi-cloud-cli]\n   ```\n\nДля более подробного описания и примеров работы с безопасностью в FastAPI, рекомендуется обратиться к [документации по безопасности](docs/tutorial/security/index.md) и [OpenAPI](docs/tutorial/security/openapi.md).\n\nИсточники информации:\n1. [Документ 2] (docs\\tutorial\\security\\oauth2-jwt.md#Резюме)\n2. [Документ 3] (docs\\tutorial\\security\\first-steps.md#Использование)\n3. [Документ 4] (docs/tutorial/security/index.md#Преимущества **FastAPI**)\n\nЭти ресурсы содержат детали и примеры кода, которые помогут вам лучше понять настройку безопасности в FastAPI.",
          "retrieved_chunk_ids": [
            "557930387b9371bf",
            "dcf34938ea5567f8",
            "14570a60fb8bb843",
            "5d80166d2c8523cc",
            "fa5b852591d657e4"
          ],
          "metrics": {
            "mrr": 0,
            "recall@5": 0,
            "precision@5": 0
          }
        }
      }
    },
    {
      "question": "Как кастомизировать документацию FastAPI и обработку запросов?",
      "expected_chunk_ids": [
        "6183ebcfce3190d7",
        "b61576003a66e4f9",
        "5e604cb771801750",
        "bdfb8357d8f70c9e",
        "615f7b753dff5e6a"
      ],
      "configurations": {
        "fastapi_rag_baseline_recursive_1024": {
          "answer": "Чтобы кастомизировать документацию FastAPI, вы можете использовать функцию `.openapi()` или переопределить схему OpenAPI вручную. Вот как это можно сделать:\n\n1. **Использование `.openapi()`**: Этот метод позволяет вам возвращать собственную схему OpenAPI из вашего приложения. Например, вы можете изменить заголовок API, его версию или добавить расширения.\n\n2. **Переопределение схемы OpenAPI**: Вы можете использовать ту же функцию `fastapi.openapi.utils.get_openapi()` для генерации схемы OpenAPI и затем переопределить любые необходимые части. Например, вы можете добавить расширение ReDoc для включения собственного логотипа.\n\n3. **Кэширование схемы OpenAPI**: Вы можете использовать свойство `.openapi_schema` как кэш для хранения сгенерированной схемы, чтобы избежать повторного генерирования при каждом запросе документации API.\n\nЭти методы позволяют вам настроить и улучшить документацию вашего FastAPI-приложения в соответствии с вашими потребностями. \n\nИсточники информации:\n1. [Документ 3]\n2. [Документ 4]\n\nТеперь вы можете использовать эти инструкции для кастомизации документации вашего приложения и обработки запросов, добавляя тело запроса в функции-обработчики путей или переопределяя схему OpenAPI.",
          "retrieved_chunk_ids": [
            "60bbf5ad825d084d",
            "4bfd2e2135d56297",
            "a4512580df001c5f",
            "6606c2905a786429",
            "c3121a1925bfcd3b"
          ],
          "metrics": {
            "mrr": 0,
            "recall@5": 0,
            "precision@5": 0
          }
        },
        "fastapi_rag_markdown_512": {
          "answer": "В FastAPI нет прямого способа кастомизировать документацию с самого начала, как это можно сделать напрямую из объекта `Request`. Однако, вы можете настроить и улучшить вашу документацию через несколько методов:\n\n1. **Использование Pydantic моделей для объявления параметров и тела запроса**: FastAPI автоматически генерирует документацию схемы данных в формате OpenAPI, которая затем используется для создания интерактивной документации на основе Swagger UI.\n\n2. **Добавление дополнительных метаданных через декораторы**:\n   - Вы можете использовать декораторы, такие как `Depends`, `Response`, и другие, чтобы добавлять дополнительные сведения о вашем API в схему OpenAPI.\n   \n3. **Использование Swagger UI для ручной настройки**: Если вам нужно более тонкое управление документацией, вы можете использовать Swagger UI напрямую и настроить его через конфигурационные файлы.\n\nДля примера, смотрите [Документ 5] (docs\\tutorial\\body-nested-models.md#Резюме), где показано использование моделей Pydantic для объявления параметров тела запроса. Это автоматически создает документацию в формате OpenAPI.\n\nТаким образом, вы можете настроить и улучшить вашу документацию с помощью Pydantic моделей и дополнительных декораторов, но не существует прямого способа кастомизировать документацию напрямую из объекта `Request`.\n\n[Документ 5]",
          "retrieved_chunk_ids": [
            "ae49926edc022a6e",
            "ca7b34ed805319df",
            "c6b5fe7f47687514",
            "9b87d64542e2716a",
            "9a611ff7c3818bf2"
          ],
          "metrics": {
            "mrr": 0,
            "recall@5": 0,
            "precision@5": 0
          }
        }
      }
    },
    {
      "question": "Преимущества ASGI над WSGI?",
      "expected_chunk_ids": [
        "b5ab154702003e71",
        "a7647da5e70f4924",
        "7535ba386c046ecb",
        "b3f814160a920f9e",
        "5e8abc9fe2623190",
        "eff27aac06ea8d76",
        "fb4cec1c24f1303c",
        "63312a4ae101aae6"
      ],
      "configurations": {
        "fastapi_rag_baseline_recursive_1024": {
          "answer": "ASGI (Asynchronous Server Gateway Interface) предпочтительнее WSGI (Web Server Gateway Interface) из-за нескольких ключевых преимуществ:\n\n1. **Асинхронность**: ASGI поддерживает асинхронные приложения, что позволяет эффективно использовать мощности современных процессоров и сетевого оборудования для выполнения многозадачных операций без блокировки потока.\n\n2. **Высокая производительность**: ASGI-серверы, такие как Uvicorn, могут обеспечить лучшую производительность по сравнению с WSGI-серверами. Это особенно важно для современных веб-приложений, которые требуют высокой скорости и стабильности.\n\n3. **Более гибкость**: ASGI предоставляет большую гибкость при разработке и поддержке веб-приложений. Он позволяет использовать различные типы серверов и фреймворков, что делает его более универсальным инструментом.\n\n4. **Более широкий спектр поддерживаемых серверов**: ASGI поддерживает множество различных серверов, включая Uvicorn, Hypercorn, Daphne для Django Channels и NGINX Unit, что позволяет использовать его с разными инфраструктурными решениями.\n\nИсточники информации:\n1. [Документ 3]\n2. [Документ 4]",
          "retrieved_chunk_ids": [
            "7535ba386c046ecb",
            "b5ab154702003e71",
            "0397bb04fc9090f9",
            "5e8abc9fe2623190",
            "a733dbdd72f0ad57"
          ],
          "metrics": {
            "mrr": 1,
            "recall@5": 0.375,
            "precision@5": 0.6
          }
        },
        "fastapi_rag_markdown_512": {
          "answer": "ASGI (Asynchronous Server Gateway Interface) имеет ряд преимуществ над WSGI (Web Server Gateway Interface), особенно в контексте современных асинхронных веб-приложений, таких как FastAPI.\n\n1. **Асинхронность**: ASGI является асинхронным стандартом, что делает его идеальным для работы с веб-серверами на основе событий (event-driven servers), такими как Uvicorn, Hypercorn и Daphne. Это позволяет эффективно использовать мощные серверы, такие как NGINX Unit, которые могут быть более производительными и гибкими по сравнению с традиционными веб-серверами на основе событий.\n\n2. **Универсальность**: ASGI не зависит от конкретного фреймворка или сервера. Он предоставляет общую спецификацию для асинхронных веб-приложений, что делает его универсальным и позволяет легко заменять серверы или инструменты.\n\n3. **Документация и поддержка**: Хотя ASGI не является стандартом Python (PEP), он уже используется как «стандарт» несколькими инструментами, что улучшает совместимость и доступность информации о нем. Это особенно важно для новых веб-фреймворков, таких как FastAPI.\n\n4. **Мiddleware**: ASGI предоставляет более гибкий подход к использованию middleware. В отличие от WSGI, где middleware обычно нужно реализовывать самостоятельно или использовать готовые решения, ASGI предлагает более простой и автоматизированный способ добавления middleware с помощью метода `app.add_middleware()`.\n\nТаким образом, ASGI предоставляет больше гибкости, производительности и универсальности по сравнению с WSGI в контексте современных асинхронных веб-приложений.",
          "retrieved_chunk_ids": [
            "5a7a71ae2fa06250",
            "b3001ee9925e05ae",
            "02701967a4842869",
            "92b47a49dd815ae2",
            "d6911119f0339cab"
          ],
          "metrics": {
            "mrr": 1,
            "recall@5": 0.25,
            "precision@5": 0.4
          }
        }
      }
    },
    {
      "question": "Как FastAPI автоматически проверяет входящие данные и преобразует (сериализует) исходящие данные в JSON? Что происходит, если данные не проходят валидацию?",
      "expected_chunk_ids": [
        "b89cb77618936866",
        "615f7b753dff5e6a",
        "bdfb8357d8f70c9e",
        "6183ebcfce3190d7",
        "acace34fc412931f",
        "c72fa3007b9a0a8c",
        "d6911119f0339cab",
        "5e8abc9fe2623190"
      ],
      "configurations": {
        "fastapi_rag_baseline_recursive_1024": {
          "answer": "FastAPI автоматически проверяет входящие данные при создании операций пути, используя Pydantic-модели для валидации данных перед их обработкой. Если данные не проходят валидацию, FastAPI генерирует ошибку `RequestValidationError`, которая содержит информацию о том, какие части данных были недействительны и где они находятся.\n\nВ случае если данные не прошли валидацию, FastAPI автоматически преобразует их в текстовую строку с помощью метода `jsonable_encoder` из Pydantic. Это позволяет пользователю видеть детализированную информацию об ошибке на уровне HTTP-ответа, вместо того чтобы получать сложные структуры данных.\n\nТаким образом, если данные не проходят валидацию, FastAPI преобразует их в текстовую строку и добавляет её в тело ответа с помощью `JSONResponse` или пользовательского `Response`.\n\nИсточник информации: [Документ 4]",
          "retrieved_chunk_ids": [
            "8902297d57a5fdb0",
            "c3121a1925bfcd3b",
            "58d066b11a743c09",
            "91bdaae93cf9df6f",
            "60bbf5ad825d084d"
          ],
          "metrics": {
            "mrr": 0,
            "recall@5": 0,
            "precision@5": 0
          }
        },
        "fastapi_rag_markdown_512": {
          "answer": "FastAPI автоматически проверяет входящие данные при помощи кастомных валидаторов, которые можно определить самостоятельно или использовать из библиотеки Pydantic. Эти валидаторы используют те же данные, что и пришли в запросе.\n\nЕсли данные не проходят валидацию, FastAPI автоматически генерирует JSON-ответ с ошибками. Это происходит посредством обработчиков исключений, которые можно переопределить на свои собственные.\n\nВ случае, если параметр пути имеет значение, которое не соответствует ожидаемому типу (например, строка вместо числа), FastAPI генерирует ошибку типа `int_parsing`, указывая конкретное место в коде и причину проблемы. Например:\n\n```JSON\n{\n  \"detail\": [\n    {\n      \"type\": \"int_parsing\",\n      \"loc\": [\n        \"path\",\n        \"item_id\"\n      ],\n      \"msg\": \"Input should be a valid integer, unable to parse string as an integer\",\n      \"input\": \"foo\"\n    }\n  ]\n}\n```\n\nТакже FastAPI автоматически преобразует данные из запроса и возвращает их в формате JSON при помощи объекта `Request` или Pydantic моделей. Если же данные не проходят валидацию, FastAPI генерирует соответствующие ошибки.\n\nИсточники информации:\n1. [Документ 1]\n2. [Документ 5]",
          "retrieved_chunk_ids": [
            "3c0816d62e4b03f9",
            "9b87d64542e2716a",
            "2513429c7179a513",
            "88824a170676923a",
            "7fa1502101867292"
          ],
          "metrics": {
            "mrr": 0,
            "recall@5": 0,
            "precision@5": 0
          }
        }
      }
    },
    {
      "question": "Как работает Pydantic в FastAPI? Как использовать Pydantic модели для определения структуры тела запроса (request body) и ответа (response model)?",
      "expected_chunk_ids": [
        "a4512580df001c5f",
        "b70711b58700f501",
        "d5dfbdc699e18c09",
        "91bdaae93cf9df6f"
      ],
      "configurations": {
        "fastapi_rag_baseline_recursive_1024": {
          "answer": "Pydantic используется в FastAPI для автоматической валидации, сериализации и документирования данных HTTP-запросов и -ответов. Для определения структуры тела запроса (request body) и ответа (response model) можно использовать Pydantic модели.\n\nДля создания моделей тела запроса или ответа используется следующий подход:\n\n1. Импортируйте `BaseModel` из пакета `pydantic`.\n2. Создайте класс, наследующийся от `BaseModel`, и опишите его атрибуты с использованием стандартных типов Python.\n3. Объявите модель как параметр в операции пути.\n\nПример использования модели тела запроса:\n\n```python\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n    return {\"item\": item}\n```\n\nДля создания модели ответа с использованием Pydantic можно сделать следующее:\n\n```python\nfrom pydantic import BaseModel\n\nclass Author(BaseModel):\n    name: str\n    items: list[Item]\n\n@app.get(\"/authors/\")\nasync def get_authors():\n    return {\"authors\": [Author(name=\"John Doe\", items=[Item(name=\"Book 1\", price=20.0), Item(name=\"Book 2\", price=30.0)])]}\n```\n\nВ этом примере мы создали модель `Author` с атрибутами `name` и `items`, где `items` является списком моделей `Item`. Мы также использовали эти модели в качестве параметров операций пути.\n\nPydantic поддерживает вложенные структуры данных, что позволяет легко создавать сложные объекты для ответов. Также Pydantic автоматически генерирует документацию для этих моделей, что упрощает процесс разработки и тестирования.\n\nИсточники информации:\n1. [Документ 3]\n2. [Документ 4]",
          "retrieved_chunk_ids": [
            "7b2f8d1e9898bece",
            "81496accb49f70b1",
            "aac6185d122b2f2e",
            "91bdaae93cf9df6f",
            "bdfb8357d8f70c9e"
          ],
          "metrics": {
            "mrr": 0.25,
            "recall@5": 0.25,
            "precision@5": 0.2
          }
        },
        "fastapi_rag_markdown_512": {
          "answer": "Pydantic модели в FastAPI используются для определения структуры тела запроса (request body) и ответа (response model). Они предоставляют гибкость, простоту и элегантность вашего кода. Вот как это работает:\n\n1. **Тело запроса**: Вы можете объявить параметры пути и тело запроса одновременно. FastAPI распознает, что параметры функции, соответствующие параметрам пути, должны быть получены из пути, а параметры функции, объявленные как модели Pydantic, должны быть получены из тела запроса.\n\n2. **Ответы**: Вы также можете комбинировать информацию об ответах из разных мест, включая `response_model`, `status_code` и `responses`. FastAPI сохраняет дополнительную информацию из `responses` и объединяет её с JSON-схемой из вашей модели.\n\n3. **Резюме Pydantic**: С помощью FastAPI вы получаете максимальную гибкость, предоставляемую моделями Pydantic, сохраняя при этом простоту, краткость и элегантность вашего кода. Это включает поддержку редактора кода (автозавершение доступно везде!), преобразование данных (парсинг/serilization), валидацию данных, документацию схемы данных и автоматическую генерацию документации.\n\n4. **Дополнительный ответ с `model`**: Вы можете передать вашим декораторам операций пути параметр `responses`, который принимает словарь: ключи — это статус-коды для каждого ответа (например, `200`), а значения — другие словари с информацией для каждого из них. Каждый из этих словарей для ответа может иметь ключ `model`, содержащий Pydantic-модель.\n\nИсточники информации:\n1. [Документ 1]\n2. [Документ 2]\n3. [Документ 3]\n4. [Документ 4]\n\nЭто позволяет вам создавать более гибкие и управляемые API с использованием моделей Pydantic для структурирования данных в телах запросов и ответах.",
          "retrieved_chunk_ids": [
            "8d42254530b0b882",
            "e6f96a682b18fb84",
            "d7d0a0728a6244ae",
            "9a611ff7c3818bf2",
            "7b2f8d1e9898bece"
          ],
          "metrics": {
            "mrr": 0,
            "recall@5": 0,
            "precision@5": 0
          }
        }
      }
    },
    {
      "question": "Как работать с callbacks и webhooks?",
      "expected_chunk_ids": [
        "13fa035d5f3c24e0",
        "ea14bf3ceeeecafc",
        "6439f82fd6005ce3",
        "722ea1384edf0d4a",
        "735bd4e078cd9aa6",
        "ec0b81cac56cf074"
      ],
      "configurations": {
        "fastapi_rag_baseline_recursive_1024": {
          "answer": "Чтобы работать с callbacks и webhooks на основе предоставленного контекста, необходимо выполнить следующие шаги:\n\n### 1. Создание операций пути обратных вызовов (callbacks)\n\n- **Добавьте маршрутизатор обратных вызовов**: В вашем приложении нужно создать объект `APIRouter`, который будет использоваться для управления операциями пути, которые будут инициированы внешним API. Это можно сделать следующим образом:\n\n  ```python\n  from fastapi import APIRouter\n\n  invoices_callback_router = APIRouter()\n  ```\n\n- **Добавьте операцию пути обратного вызова**: Используйте декоратор `@invoices_callback_router.route` для определения операции пути, которая будет инициировать HTTP-запрос в внешнее API. Например:\n\n  ```python\n  @invoices_callback_router.post(\"/callback\")\n  async def handle_invoice_event(request: InvoiceEvent):\n      # Реализуйте логику обработки события и отправки обратного вызова\n      pass\n  ```\n\n### 2. Документирование операций пути обратных вызовов\n\n- **Добавьте параметр `callbacks` в декоратор**: В операции пути обратного вызова нужно использовать атрибут `.routes` из маршрутизатора обратных вызовов, чтобы документировать его для внешнего API. Например:\n\n  ```python\n  @invoices_callback_router.post(\"/callback\", callbacks=invoices_callback_router.routes)\n  async def handle_invoice_event(request: InvoiceEvent):\n      # Реализуйте логику обработки события и отправки обратного вызова\n      pass\n  ```\n\n### 3. Создание операций пути вебхуков (webhooks)\n\n- **Добавьте операцию пути вебхука**: В вашем приложении нужно создать операцию пути, которая будет обрабатывать HTTP-запросы от внешнего API и вызывать соответствующие действия внутри вашего приложения. Например:\n\n  ```python\n  @app.webhooks.post(\"new-subscription\")\n  async def handle_new_subscription(request: SubscriptionEvent):\n      # Реализуйте логику обработки нового подписчика\n      pass\n  ```\n\n- **Добавьте параметр `callbacks` в декоратор операции пути**: В операцию пути веб",
          "retrieved_chunk_ids": [
            "ec0b81cac56cf074",
            "722ea1384edf0d4a",
            "735bd4e078cd9aa6",
            "13fa035d5f3c24e0",
            "6439f82fd6005ce3"
          ],
          "metrics": {
            "mrr": 1,
            "recall@5": 0.8333333333333334,
            "precision@5": 1
          }
        },
        "fastapi_rag_markdown_512": {
          "answer": "Советую обратить внимание на два основных типа асинхронной работы с API: callbacks (обратные вызовы) и webhooks.\n\n**Обратные вызовы**: Это механизм, который позволяет внешнему разработчику подключать свои функции к операциям пути вашего приложения. В контексте FastAPI это делается через параметр `callbacks` в декораторе операции пути вашего API. Вы передаете атрибут `.routes` маршрутизатора обратных вызовов, который содержит список всех маршрутов и операций путей.\n\n**Вебхуки**: Это механизм, позволяющий вашему приложению отправлять запросы в сторонние системы (например, внешним API) по определенным событиям. В FastAPI это делается через атрибут `webhooks`, который позволяет объявлять вебхуки так же, как операции пути. Эти вебхуки автоматически добавляются в схему OpenAPI и интерфейс документации вашего приложения.\n\n[Документ 1] и [Документ 2] описывают подробно работу с обратными вызовами. В контексте [Документ 3], мы видим, что это отличается от вебхуков, которые используются для отправки запросов из вашей системы в сторонние системы.\n\n[Документ 4] и [Документ 5] дают больше информации о работе с асинхронным кодом в FastAPI.",
          "retrieved_chunk_ids": [
            "9539605f5f548358",
            "ea14bf3ceeeecafc",
            "ec0b81cac56cf074",
            "6e25009a59788e2f",
            "bd21db178c4f2247"
          ],
          "metrics": {
            "mrr": 1,
            "recall@5": 0.6,
            "precision@5": 0.6
          }
        }
      }
    },
    {
      "question": "Что такое зависимости в контексте FastAPI?",
      "expected_chunk_ids": [
        "b5ab154702003e71",
        "dd86b078cd0b8d5e",
        "b70711b58700f501",
        "c4054daf0fe7bfd7",
        "dc3c32a156ba0d4f",
        "4b0150c154d1e0f7",
        "cf3f871259e1dd4c"
      ],
      "configurations": {
        "fastapi_rag_baseline_recursive_1024": {
          "answer": "В контексте FastAPI зависимости представляют собой функции, которые могут принимать те же параметры, что и *функции обработчика путей* (или операции пути). Они могут возвращать любое значение. \n\nДля объявления зависимостей используется инструмент `Depends`. Зависимости могут быть использованы для предоставления общего кода или логики, которые должны выполняться перед выполнением *функции обработчика путей*. Они также могут быть использованы для создания безопасных и аутентифицированных API-эндпоинтов.\n\nИногда требуется объявить зависимость ко всему приложению или группе операций путей, что можно сделать с помощью параметра `dependencies` в декораторах *функций обработчиков путей*. \n\nТаким образом, зависимости позволяют интегрировать внешние компоненты и провайдеры (например, ресурсы, сервисы или внедряемые зависимости) с вашими API-функциями.\n\nИсточник информации: [Документ 1] (docs\\advanced\\advanced-dependencies.md), [Документ 2] (docs\\tutorial\\dependencies\\index.md), [Документ 3] (docs\\tutorial\\dependencies\\index.md), [Документ 4] (docs/tutorial/global-dependencies.md), [Документ 5] (docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md)",
          "retrieved_chunk_ids": [
            "4b0150c154d1e0f7",
            "a8adab76f0c06eae",
            "b534c3ab389d0bd8",
            "a795d22cf3d0f18e",
            "282b1770609bb18e"
          ],
          "metrics": {
            "mrr": 1,
            "recall@5": 0.1428571428571428,
            "precision@5": 0.2
          }
        },
        "fastapi_rag_markdown_512": {
          "answer": "В контексте FastAPI зависимости представляют собой механизм внедрения зависимостей, который позволяет создавать сложные системы с использованием вложенных зависимостей. Это означает, что даже зависимости могут иметь свои зависимости, создавая иерархию или \"граф\" зависимостей.\n\nFastAPI автоматически управляет всеми этими зависимостями, включая даже зависимости, которые могут быть вызваны из запросов. Все это обеспечивает автоматическую проверку параметров операций пути и поддерживает сложные системы аутентификации пользователей, соединений с базами данных и других интеграций.\n\nДля управления зависимостями FastAPI использует систему внедрения зависимостей. Она включает в себя возможности, такие как возможность добавления зависимостей ко всему приложению (глобальные зависимости), использование `Depends(scope=\"function\")` для раннего завершения функции-обработчика пути и использования `Depends(scope=\"request\")` для выполнения кода после отправки ответа клиенту.\n\nИсточники информации:\n1. [Документ 1]\n2. [Документ 2]\n3. [Документ 4]",
          "retrieved_chunk_ids": [
            "d4b79e49b237fcb5",
            "9d821a248718d91c",
            "15eb710115361ba2",
            "6242f4fdd69c03ea",
            "a795d22cf3d0f18e"
          ],
          "metrics": {
            "mrr": 0.3333333333333333,
            "recall@5": 0.1428571428571428,
            "precision@5": 0.2
          }
        }
      }
    },
    {
      "question": "Какие существуют варианты и этапы развертывания FastAPI приложений, включая FastAPI Cloud, Docker контейнеризацию, настройку Uvicorn воркеров и основные концепции продакшен-деплоя?",
      "expected_chunk_ids": [
        "61ccf398e4b84515",
        "a1fb697aca307723",
        "43bd1295fddc5190",
        "605fa00c1ed16c08",
        "0da58613dc5e4ba7",
        "e548999b51d8e52b",
        "18824cdd08d67f0a",
        "127dace191ca9db0",
        "c72fa3007b9a0a8c"
      ],
      "configurations": {
        "fastapi_rag_baseline_recursive_1024": {
          "answer": "Существуют различные варианты и этапы развертывания FastAPI приложений, включая использование FastAPI Cloud, Docker контейнеризацию, настройку Uvicorn воркеров и основные концепции продакшен-деплоя. Вот краткое описание каждого:\n\n1. **FastAPI Cloud**: Это облачное решение для развертывания приложений FastAPI. Оно упрощает процесс создания образа, развертывания и доступа к API при минимальных усилиях. При использовании FastAPI Cloud вы можете развернуть свое приложение с помощью одной команды.\n\n2. **Docker контейнеризация**: Docker позволяет инкапсулировать приложения в отдельные контейнеры, что обеспечивает их изолированность и повторное использование. Для контейнеризации FastAPI можно использовать готовые образы или собрать свой собственный образ с нуля.\n\n3. **Настройка Uvicorn воркеров**: Утилита Uvicorn используется для запуска приложений FastAPI как сервера. Он поддерживает опцию командной строки `--workers`, которая позволяет задействовать несколько процессов (воркеров) для обработки большего количества запросов, что особенно полезно в продакшен-сценариях.\n\n4. **Основные концепции продакшен-деплоя**: При развертывании приложений FastAPI в продакшен-режиме необходимо учитывать несколько ключевых концепций:\n\n   - **Репликация (количество запущенных процессов)**: Для задействования нескольких ядер и обработки большего количества запросов может быть использована репликация процессов.\n   - **Память**: Необходимо убедиться, что суммарное потребление памяти контейнером не превышает доступную память.\n   - **Перезапуски**: При возникновении ошибок или необходимости обновления приложения необходимо обеспечить автоматическое перезапуск процессов.\n   - **Безопасность HTTPS**: Для обеспечения безопасности приложений рекомендуется использовать протокол HTTPS.\n   - **Предварительные шаги перед запуском**: В контейнер",
          "retrieved_chunk_ids": [
            "3d429107cccab6ac",
            "753a6fa09a4cb185",
            "71001f398b218d38",
            "b440b244f3348173",
            "0951d69170daf903"
          ],
          "metrics": {
            "mrr": 0,
            "recall@5": 0,
            "precision@5": 0
          }
        },
        "fastapi_rag_markdown_512": {
          "answer": "Существуют несколько вариантов и этапов развертывания FastAPI приложений, включая использование FastAPI Cloud, Docker контейнеризацию, настройку Uvicorn воркеров и основные концепции продакшен-деплоя. Вот об этом немного больше информации:\n\n1. **FastAPI Cloud**: Это облачное решение от команды разработчиков FastAPI, которое упрощает процесс развертывания приложений FastAPI в облаке. Он предлагает простые инструменты для создания и управления контейнерами Docker, а также настройки Uvicorn воркеров.\n\n2. **Docker контейнеризацию**: С помощью Docker можно создать собственный образ с нуля, который будет использовать один процесс Uvicorn для запуска приложения FastAPI. Это простой подход и может быть полезен при использовании распределённой системы управления контейнерами, такой как Kubernetes.\n\n3. **Настройка Uvicorn воркеров**: Вы можете задействовать многоядерные CPU, запустив несколько процессов параллельно с помощью опции командной строки `--workers` для команды `fastapi` или `uvicorn`. Это позволяет использовать все доступные ядра процессора.\n\n4. **Основные концепции продакшен-деплоя**: В контексте FastAPI и других веб-приложений, основными концепциями продакшен-деплоя являются использование облачных провайдеров для развертывания приложений, настройка серверов или облаков для автоматизации процесса запуска приложения, а также управление масштабированием и устойчивостью системы.\n\nИсточники информации:\n1. [Документ 1] (docs\\deployment\\server-workers.md#Контейнеры и Docker)\n2. [Документ 2] (docs\\index.md#Разверните приложение (опционально))\n3. [Документ 5] (docs\\deployment\\index.md#Стратегии развёртывания)\n\nЭти варианты и этапы развертывания позволяют разработчикам управлять их приложениями в различных облачных средах, обеспечивая надежность, масш",
          "retrieved_chunk_ids": [
            "b63fdedfe51fe05d",
            "d7202fa05c28e8a2",
            "93b74fd474ff41ab",
            "9457270e018829d1",
            "7b94501cc247dbab"
          ],
          "metrics": {
            "mrr": 0,
            "recall@5": 0,
            "precision@5": 0
          }
        }
      }
    }
  ]
}